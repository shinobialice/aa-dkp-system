
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserTags
 * 
 */
export type UserTags = $Result.DefaultSelection<Prisma.$UserTagsPayload>
/**
 * Model UserInventory
 * 
 */
export type UserInventory = $Result.DefaultSelection<Prisma.$UserInventoryPayload>
/**
 * Model Tasks
 * 
 */
export type Tasks = $Result.DefaultSelection<Prisma.$TasksPayload>
/**
 * Model Raid
 * 
 */
export type Raid = $Result.DefaultSelection<Prisma.$RaidPayload>
/**
 * Model Boss
 * 
 */
export type Boss = $Result.DefaultSelection<Prisma.$BossPayload>
/**
 * Model RaidBoss
 * 
 */
export type RaidBoss = $Result.DefaultSelection<Prisma.$RaidBossPayload>
/**
 * Model RaidAttendance
 * 
 */
export type RaidAttendance = $Result.DefaultSelection<Prisma.$RaidAttendancePayload>
/**
 * Model ItemType
 * 
 */
export type ItemType = $Result.DefaultSelection<Prisma.$ItemTypePayload>
/**
 * Model Loot
 * 
 */
export type Loot = $Result.DefaultSelection<Prisma.$LootPayload>
/**
 * Model TasksUser
 * 
 */
export type TasksUser = $Result.DefaultSelection<Prisma.$TasksUserPayload>
/**
 * Model LootQueue
 * 
 */
export type LootQueue = $Result.DefaultSelection<Prisma.$LootQueuePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTags`: Exposes CRUD operations for the **UserTags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTags
    * const userTags = await prisma.userTags.findMany()
    * ```
    */
  get userTags(): Prisma.UserTagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userInventory`: Exposes CRUD operations for the **UserInventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInventories
    * const userInventories = await prisma.userInventory.findMany()
    * ```
    */
  get userInventory(): Prisma.UserInventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tasks`: Exposes CRUD operations for the **Tasks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.tasks.findMany()
    * ```
    */
  get tasks(): Prisma.TasksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raid`: Exposes CRUD operations for the **Raid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Raids
    * const raids = await prisma.raid.findMany()
    * ```
    */
  get raid(): Prisma.RaidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boss`: Exposes CRUD operations for the **Boss** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bosses
    * const bosses = await prisma.boss.findMany()
    * ```
    */
  get boss(): Prisma.BossDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raidBoss`: Exposes CRUD operations for the **RaidBoss** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaidBosses
    * const raidBosses = await prisma.raidBoss.findMany()
    * ```
    */
  get raidBoss(): Prisma.RaidBossDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raidAttendance`: Exposes CRUD operations for the **RaidAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaidAttendances
    * const raidAttendances = await prisma.raidAttendance.findMany()
    * ```
    */
  get raidAttendance(): Prisma.RaidAttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemType`: Exposes CRUD operations for the **ItemType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemTypes
    * const itemTypes = await prisma.itemType.findMany()
    * ```
    */
  get itemType(): Prisma.ItemTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loot`: Exposes CRUD operations for the **Loot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loots
    * const loots = await prisma.loot.findMany()
    * ```
    */
  get loot(): Prisma.LootDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tasksUser`: Exposes CRUD operations for the **TasksUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TasksUsers
    * const tasksUsers = await prisma.tasksUser.findMany()
    * ```
    */
  get tasksUser(): Prisma.TasksUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lootQueue`: Exposes CRUD operations for the **LootQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LootQueues
    * const lootQueues = await prisma.lootQueue.findMany()
    * ```
    */
  get lootQueue(): Prisma.LootQueueDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserTags: 'UserTags',
    UserInventory: 'UserInventory',
    Tasks: 'Tasks',
    Raid: 'Raid',
    Boss: 'Boss',
    RaidBoss: 'RaidBoss',
    RaidAttendance: 'RaidAttendance',
    ItemType: 'ItemType',
    Loot: 'Loot',
    TasksUser: 'TasksUser',
    LootQueue: 'LootQueue'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userTags" | "userInventory" | "tasks" | "raid" | "boss" | "raidBoss" | "raidAttendance" | "itemType" | "loot" | "tasksUser" | "lootQueue"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserTags: {
        payload: Prisma.$UserTagsPayload<ExtArgs>
        fields: Prisma.UserTagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          findFirst: {
            args: Prisma.UserTagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          findMany: {
            args: Prisma.UserTagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>[]
          }
          create: {
            args: Prisma.UserTagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          createMany: {
            args: Prisma.UserTagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>[]
          }
          delete: {
            args: Prisma.UserTagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          update: {
            args: Prisma.UserTagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          deleteMany: {
            args: Prisma.UserTagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>[]
          }
          upsert: {
            args: Prisma.UserTagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          aggregate: {
            args: Prisma.UserTagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTags>
          }
          groupBy: {
            args: Prisma.UserTagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTagsCountArgs<ExtArgs>
            result: $Utils.Optional<UserTagsCountAggregateOutputType> | number
          }
        }
      }
      UserInventory: {
        payload: Prisma.$UserInventoryPayload<ExtArgs>
        fields: Prisma.UserInventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>
          }
          findFirst: {
            args: Prisma.UserInventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>
          }
          findMany: {
            args: Prisma.UserInventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>[]
          }
          create: {
            args: Prisma.UserInventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>
          }
          createMany: {
            args: Prisma.UserInventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>[]
          }
          delete: {
            args: Prisma.UserInventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>
          }
          update: {
            args: Prisma.UserInventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>
          }
          deleteMany: {
            args: Prisma.UserInventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserInventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>[]
          }
          upsert: {
            args: Prisma.UserInventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>
          }
          aggregate: {
            args: Prisma.UserInventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInventory>
          }
          groupBy: {
            args: Prisma.UserInventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInventoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserInventoryCountAggregateOutputType> | number
          }
        }
      }
      Tasks: {
        payload: Prisma.$TasksPayload<ExtArgs>
        fields: Prisma.TasksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TasksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TasksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          findFirst: {
            args: Prisma.TasksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TasksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          findMany: {
            args: Prisma.TasksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>[]
          }
          create: {
            args: Prisma.TasksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          createMany: {
            args: Prisma.TasksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TasksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>[]
          }
          delete: {
            args: Prisma.TasksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          update: {
            args: Prisma.TasksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          deleteMany: {
            args: Prisma.TasksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TasksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TasksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>[]
          }
          upsert: {
            args: Prisma.TasksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          aggregate: {
            args: Prisma.TasksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTasks>
          }
          groupBy: {
            args: Prisma.TasksGroupByArgs<ExtArgs>
            result: $Utils.Optional<TasksGroupByOutputType>[]
          }
          count: {
            args: Prisma.TasksCountArgs<ExtArgs>
            result: $Utils.Optional<TasksCountAggregateOutputType> | number
          }
        }
      }
      Raid: {
        payload: Prisma.$RaidPayload<ExtArgs>
        fields: Prisma.RaidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          findFirst: {
            args: Prisma.RaidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          findMany: {
            args: Prisma.RaidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>[]
          }
          create: {
            args: Prisma.RaidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          createMany: {
            args: Prisma.RaidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>[]
          }
          delete: {
            args: Prisma.RaidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          update: {
            args: Prisma.RaidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          deleteMany: {
            args: Prisma.RaidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>[]
          }
          upsert: {
            args: Prisma.RaidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          aggregate: {
            args: Prisma.RaidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaid>
          }
          groupBy: {
            args: Prisma.RaidGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaidGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaidCountArgs<ExtArgs>
            result: $Utils.Optional<RaidCountAggregateOutputType> | number
          }
        }
      }
      Boss: {
        payload: Prisma.$BossPayload<ExtArgs>
        fields: Prisma.BossFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BossFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BossFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>
          }
          findFirst: {
            args: Prisma.BossFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BossFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>
          }
          findMany: {
            args: Prisma.BossFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>[]
          }
          create: {
            args: Prisma.BossCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>
          }
          createMany: {
            args: Prisma.BossCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BossCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>[]
          }
          delete: {
            args: Prisma.BossDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>
          }
          update: {
            args: Prisma.BossUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>
          }
          deleteMany: {
            args: Prisma.BossDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BossUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BossUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>[]
          }
          upsert: {
            args: Prisma.BossUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>
          }
          aggregate: {
            args: Prisma.BossAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoss>
          }
          groupBy: {
            args: Prisma.BossGroupByArgs<ExtArgs>
            result: $Utils.Optional<BossGroupByOutputType>[]
          }
          count: {
            args: Prisma.BossCountArgs<ExtArgs>
            result: $Utils.Optional<BossCountAggregateOutputType> | number
          }
        }
      }
      RaidBoss: {
        payload: Prisma.$RaidBossPayload<ExtArgs>
        fields: Prisma.RaidBossFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaidBossFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaidBossFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>
          }
          findFirst: {
            args: Prisma.RaidBossFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaidBossFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>
          }
          findMany: {
            args: Prisma.RaidBossFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>[]
          }
          create: {
            args: Prisma.RaidBossCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>
          }
          createMany: {
            args: Prisma.RaidBossCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaidBossCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>[]
          }
          delete: {
            args: Prisma.RaidBossDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>
          }
          update: {
            args: Prisma.RaidBossUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>
          }
          deleteMany: {
            args: Prisma.RaidBossDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaidBossUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaidBossUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>[]
          }
          upsert: {
            args: Prisma.RaidBossUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>
          }
          aggregate: {
            args: Prisma.RaidBossAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaidBoss>
          }
          groupBy: {
            args: Prisma.RaidBossGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaidBossGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaidBossCountArgs<ExtArgs>
            result: $Utils.Optional<RaidBossCountAggregateOutputType> | number
          }
        }
      }
      RaidAttendance: {
        payload: Prisma.$RaidAttendancePayload<ExtArgs>
        fields: Prisma.RaidAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaidAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaidAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>
          }
          findFirst: {
            args: Prisma.RaidAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaidAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>
          }
          findMany: {
            args: Prisma.RaidAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>[]
          }
          create: {
            args: Prisma.RaidAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>
          }
          createMany: {
            args: Prisma.RaidAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaidAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>[]
          }
          delete: {
            args: Prisma.RaidAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>
          }
          update: {
            args: Prisma.RaidAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>
          }
          deleteMany: {
            args: Prisma.RaidAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaidAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaidAttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>[]
          }
          upsert: {
            args: Prisma.RaidAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>
          }
          aggregate: {
            args: Prisma.RaidAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaidAttendance>
          }
          groupBy: {
            args: Prisma.RaidAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaidAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaidAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<RaidAttendanceCountAggregateOutputType> | number
          }
        }
      }
      ItemType: {
        payload: Prisma.$ItemTypePayload<ExtArgs>
        fields: Prisma.ItemTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          findFirst: {
            args: Prisma.ItemTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          findMany: {
            args: Prisma.ItemTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>[]
          }
          create: {
            args: Prisma.ItemTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          createMany: {
            args: Prisma.ItemTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>[]
          }
          delete: {
            args: Prisma.ItemTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          update: {
            args: Prisma.ItemTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          deleteMany: {
            args: Prisma.ItemTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>[]
          }
          upsert: {
            args: Prisma.ItemTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          aggregate: {
            args: Prisma.ItemTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemType>
          }
          groupBy: {
            args: Prisma.ItemTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ItemTypeCountAggregateOutputType> | number
          }
        }
      }
      Loot: {
        payload: Prisma.$LootPayload<ExtArgs>
        fields: Prisma.LootFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LootFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LootFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>
          }
          findFirst: {
            args: Prisma.LootFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LootFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>
          }
          findMany: {
            args: Prisma.LootFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>[]
          }
          create: {
            args: Prisma.LootCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>
          }
          createMany: {
            args: Prisma.LootCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LootCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>[]
          }
          delete: {
            args: Prisma.LootDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>
          }
          update: {
            args: Prisma.LootUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>
          }
          deleteMany: {
            args: Prisma.LootDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LootUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LootUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>[]
          }
          upsert: {
            args: Prisma.LootUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>
          }
          aggregate: {
            args: Prisma.LootAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoot>
          }
          groupBy: {
            args: Prisma.LootGroupByArgs<ExtArgs>
            result: $Utils.Optional<LootGroupByOutputType>[]
          }
          count: {
            args: Prisma.LootCountArgs<ExtArgs>
            result: $Utils.Optional<LootCountAggregateOutputType> | number
          }
        }
      }
      TasksUser: {
        payload: Prisma.$TasksUserPayload<ExtArgs>
        fields: Prisma.TasksUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TasksUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TasksUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>
          }
          findFirst: {
            args: Prisma.TasksUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TasksUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>
          }
          findMany: {
            args: Prisma.TasksUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>[]
          }
          create: {
            args: Prisma.TasksUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>
          }
          createMany: {
            args: Prisma.TasksUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TasksUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>[]
          }
          delete: {
            args: Prisma.TasksUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>
          }
          update: {
            args: Prisma.TasksUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>
          }
          deleteMany: {
            args: Prisma.TasksUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TasksUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TasksUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>[]
          }
          upsert: {
            args: Prisma.TasksUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>
          }
          aggregate: {
            args: Prisma.TasksUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTasksUser>
          }
          groupBy: {
            args: Prisma.TasksUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<TasksUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.TasksUserCountArgs<ExtArgs>
            result: $Utils.Optional<TasksUserCountAggregateOutputType> | number
          }
        }
      }
      LootQueue: {
        payload: Prisma.$LootQueuePayload<ExtArgs>
        fields: Prisma.LootQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LootQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LootQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>
          }
          findFirst: {
            args: Prisma.LootQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LootQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>
          }
          findMany: {
            args: Prisma.LootQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>[]
          }
          create: {
            args: Prisma.LootQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>
          }
          createMany: {
            args: Prisma.LootQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LootQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>[]
          }
          delete: {
            args: Prisma.LootQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>
          }
          update: {
            args: Prisma.LootQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>
          }
          deleteMany: {
            args: Prisma.LootQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LootQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LootQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>[]
          }
          upsert: {
            args: Prisma.LootQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>
          }
          aggregate: {
            args: Prisma.LootQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLootQueue>
          }
          groupBy: {
            args: Prisma.LootQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<LootQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.LootQueueCountArgs<ExtArgs>
            result: $Utils.Optional<LootQueueCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userTags?: UserTagsOmit
    userInventory?: UserInventoryOmit
    tasks?: TasksOmit
    raid?: RaidOmit
    boss?: BossOmit
    raidBoss?: RaidBossOmit
    raidAttendance?: RaidAttendanceOmit
    itemType?: ItemTypeOmit
    loot?: LootOmit
    tasksUser?: TasksUserOmit
    lootQueue?: LootQueueOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    inventory: number
    tasks: number
    raidAttendance: number
    tasksAssigned: number
    tags: number
    soldLoot: number
    lootQueue: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | UserCountOutputTypeCountInventoryArgs
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    raidAttendance?: boolean | UserCountOutputTypeCountRaidAttendanceArgs
    tasksAssigned?: boolean | UserCountOutputTypeCountTasksAssignedArgs
    tags?: boolean | UserCountOutputTypeCountTagsArgs
    soldLoot?: boolean | UserCountOutputTypeCountSoldLootArgs
    lootQueue?: boolean | UserCountOutputTypeCountLootQueueArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInventoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRaidAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidAttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSoldLootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LootWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLootQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LootQueueWhereInput
  }


  /**
   * Count Type TasksCountOutputType
   */

  export type TasksCountOutputType = {
    assignedTo: number
  }

  export type TasksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | TasksCountOutputTypeCountAssignedToArgs
  }

  // Custom InputTypes
  /**
   * TasksCountOutputType without action
   */
  export type TasksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCountOutputType
     */
    select?: TasksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TasksCountOutputType without action
   */
  export type TasksCountOutputTypeCountAssignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksUserWhereInput
  }


  /**
   * Count Type RaidCountOutputType
   */

  export type RaidCountOutputType = {
    raidBosses: number
    attendance: number
  }

  export type RaidCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raidBosses?: boolean | RaidCountOutputTypeCountRaidBossesArgs
    attendance?: boolean | RaidCountOutputTypeCountAttendanceArgs
  }

  // Custom InputTypes
  /**
   * RaidCountOutputType without action
   */
  export type RaidCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidCountOutputType
     */
    select?: RaidCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaidCountOutputType without action
   */
  export type RaidCountOutputTypeCountRaidBossesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidBossWhereInput
  }

  /**
   * RaidCountOutputType without action
   */
  export type RaidCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidAttendanceWhereInput
  }


  /**
   * Count Type BossCountOutputType
   */

  export type BossCountOutputType = {
    raidBosses: number
  }

  export type BossCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raidBosses?: boolean | BossCountOutputTypeCountRaidBossesArgs
  }

  // Custom InputTypes
  /**
   * BossCountOutputType without action
   */
  export type BossCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BossCountOutputType
     */
    select?: BossCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BossCountOutputType without action
   */
  export type BossCountOutputTypeCountRaidBossesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidBossWhereInput
  }


  /**
   * Count Type ItemTypeCountOutputType
   */

  export type ItemTypeCountOutputType = {
    loot: number
    lootQueue: number
  }

  export type ItemTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loot?: boolean | ItemTypeCountOutputTypeCountLootArgs
    lootQueue?: boolean | ItemTypeCountOutputTypeCountLootQueueArgs
  }

  // Custom InputTypes
  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTypeCountOutputType
     */
    select?: ItemTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeCountLootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LootWhereInput
  }

  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeCountLootQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LootQueueWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    class_gear_score: number | null
    secondary_class_gear_score: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    class_gear_score: number | null
    secondary_class_gear_score: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    class: string | null
    secondary_class: string | null
    class_gear_score: number | null
    secondary_class_gear_score: number | null
    vk_name: string | null
    active: boolean | null
    is_eligible_for_salary: boolean | null
    joined_at: Date | null
    created_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    class: string | null
    secondary_class: string | null
    class_gear_score: number | null
    secondary_class_gear_score: number | null
    vk_name: string | null
    active: boolean | null
    is_eligible_for_salary: boolean | null
    joined_at: Date | null
    created_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    class: number
    secondary_class: number
    class_gear_score: number
    secondary_class_gear_score: number
    vk_name: number
    active: number
    is_eligible_for_salary: number
    joined_at: number
    created_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    class_gear_score?: true
    secondary_class_gear_score?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    class_gear_score?: true
    secondary_class_gear_score?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    class?: true
    secondary_class?: true
    class_gear_score?: true
    secondary_class_gear_score?: true
    vk_name?: true
    active?: true
    is_eligible_for_salary?: true
    joined_at?: true
    created_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    class?: true
    secondary_class?: true
    class_gear_score?: true
    secondary_class_gear_score?: true
    vk_name?: true
    active?: true
    is_eligible_for_salary?: true
    joined_at?: true
    created_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    class?: true
    secondary_class?: true
    class_gear_score?: true
    secondary_class_gear_score?: true
    vk_name?: true
    active?: true
    is_eligible_for_salary?: true
    joined_at?: true
    created_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    class: string | null
    secondary_class: string | null
    class_gear_score: number | null
    secondary_class_gear_score: number | null
    vk_name: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at: Date | null
    created_at: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    class?: boolean
    secondary_class?: boolean
    class_gear_score?: boolean
    secondary_class_gear_score?: boolean
    vk_name?: boolean
    active?: boolean
    is_eligible_for_salary?: boolean
    joined_at?: boolean
    created_at?: boolean
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    raidAttendance?: boolean | User$raidAttendanceArgs<ExtArgs>
    tasksAssigned?: boolean | User$tasksAssignedArgs<ExtArgs>
    tags?: boolean | User$tagsArgs<ExtArgs>
    soldLoot?: boolean | User$soldLootArgs<ExtArgs>
    lootQueue?: boolean | User$lootQueueArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    class?: boolean
    secondary_class?: boolean
    class_gear_score?: boolean
    secondary_class_gear_score?: boolean
    vk_name?: boolean
    active?: boolean
    is_eligible_for_salary?: boolean
    joined_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    class?: boolean
    secondary_class?: boolean
    class_gear_score?: boolean
    secondary_class_gear_score?: boolean
    vk_name?: boolean
    active?: boolean
    is_eligible_for_salary?: boolean
    joined_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    class?: boolean
    secondary_class?: boolean
    class_gear_score?: boolean
    secondary_class_gear_score?: boolean
    vk_name?: boolean
    active?: boolean
    is_eligible_for_salary?: boolean
    joined_at?: boolean
    created_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "class" | "secondary_class" | "class_gear_score" | "secondary_class_gear_score" | "vk_name" | "active" | "is_eligible_for_salary" | "joined_at" | "created_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    raidAttendance?: boolean | User$raidAttendanceArgs<ExtArgs>
    tasksAssigned?: boolean | User$tasksAssignedArgs<ExtArgs>
    tags?: boolean | User$tagsArgs<ExtArgs>
    soldLoot?: boolean | User$soldLootArgs<ExtArgs>
    lootQueue?: boolean | User$lootQueueArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      inventory: Prisma.$UserInventoryPayload<ExtArgs>[]
      tasks: Prisma.$TasksPayload<ExtArgs>[]
      raidAttendance: Prisma.$RaidAttendancePayload<ExtArgs>[]
      tasksAssigned: Prisma.$TasksUserPayload<ExtArgs>[]
      tags: Prisma.$UserTagsPayload<ExtArgs>[]
      soldLoot: Prisma.$LootPayload<ExtArgs>[]
      lootQueue: Prisma.$LootQueuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      class: string | null
      secondary_class: string | null
      class_gear_score: number | null
      secondary_class_gear_score: number | null
      vk_name: string | null
      active: boolean
      is_eligible_for_salary: boolean
      joined_at: Date | null
      created_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventory<T extends User$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends User$tasksArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raidAttendance<T extends User$raidAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, User$raidAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasksAssigned<T extends User$tasksAssignedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends User$tagsArgs<ExtArgs> = {}>(args?: Subset<T, User$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soldLoot<T extends User$soldLootArgs<ExtArgs> = {}>(args?: Subset<T, User$soldLootArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lootQueue<T extends User$lootQueueArgs<ExtArgs> = {}>(args?: Subset<T, User$lootQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly class: FieldRef<"User", 'String'>
    readonly secondary_class: FieldRef<"User", 'String'>
    readonly class_gear_score: FieldRef<"User", 'Int'>
    readonly secondary_class_gear_score: FieldRef<"User", 'Int'>
    readonly vk_name: FieldRef<"User", 'String'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly is_eligible_for_salary: FieldRef<"User", 'Boolean'>
    readonly joined_at: FieldRef<"User", 'DateTime'>
    readonly created_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.inventory
   */
  export type User$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    where?: UserInventoryWhereInput
    orderBy?: UserInventoryOrderByWithRelationInput | UserInventoryOrderByWithRelationInput[]
    cursor?: UserInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInventoryScalarFieldEnum | UserInventoryScalarFieldEnum[]
  }

  /**
   * User.tasks
   */
  export type User$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    where?: TasksWhereInput
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    cursor?: TasksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * User.raidAttendance
   */
  export type User$raidAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    where?: RaidAttendanceWhereInput
    orderBy?: RaidAttendanceOrderByWithRelationInput | RaidAttendanceOrderByWithRelationInput[]
    cursor?: RaidAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaidAttendanceScalarFieldEnum | RaidAttendanceScalarFieldEnum[]
  }

  /**
   * User.tasksAssigned
   */
  export type User$tasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    where?: TasksUserWhereInput
    orderBy?: TasksUserOrderByWithRelationInput | TasksUserOrderByWithRelationInput[]
    cursor?: TasksUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TasksUserScalarFieldEnum | TasksUserScalarFieldEnum[]
  }

  /**
   * User.tags
   */
  export type User$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    where?: UserTagsWhereInput
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    cursor?: UserTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * User.soldLoot
   */
  export type User$soldLootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    where?: LootWhereInput
    orderBy?: LootOrderByWithRelationInput | LootOrderByWithRelationInput[]
    cursor?: LootWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LootScalarFieldEnum | LootScalarFieldEnum[]
  }

  /**
   * User.lootQueue
   */
  export type User$lootQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    where?: LootQueueWhereInput
    orderBy?: LootQueueOrderByWithRelationInput | LootQueueOrderByWithRelationInput[]
    cursor?: LootQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LootQueueScalarFieldEnum | LootQueueScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserTags
   */

  export type AggregateUserTags = {
    _count: UserTagsCountAggregateOutputType | null
    _avg: UserTagsAvgAggregateOutputType | null
    _sum: UserTagsSumAggregateOutputType | null
    _min: UserTagsMinAggregateOutputType | null
    _max: UserTagsMaxAggregateOutputType | null
  }

  export type UserTagsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type UserTagsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type UserTagsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    tag: string | null
    created_at: Date | null
  }

  export type UserTagsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    tag: string | null
    created_at: Date | null
  }

  export type UserTagsCountAggregateOutputType = {
    id: number
    user_id: number
    tag: number
    created_at: number
    _all: number
  }


  export type UserTagsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserTagsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserTagsMinAggregateInputType = {
    id?: true
    user_id?: true
    tag?: true
    created_at?: true
  }

  export type UserTagsMaxAggregateInputType = {
    id?: true
    user_id?: true
    tag?: true
    created_at?: true
  }

  export type UserTagsCountAggregateInputType = {
    id?: true
    user_id?: true
    tag?: true
    created_at?: true
    _all?: true
  }

  export type UserTagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTags to aggregate.
     */
    where?: UserTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTags
    **/
    _count?: true | UserTagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTagsMaxAggregateInputType
  }

  export type GetUserTagsAggregateType<T extends UserTagsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTags[P]>
      : GetScalarType<T[P], AggregateUserTags[P]>
  }




  export type UserTagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagsWhereInput
    orderBy?: UserTagsOrderByWithAggregationInput | UserTagsOrderByWithAggregationInput[]
    by: UserTagsScalarFieldEnum[] | UserTagsScalarFieldEnum
    having?: UserTagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTagsCountAggregateInputType | true
    _avg?: UserTagsAvgAggregateInputType
    _sum?: UserTagsSumAggregateInputType
    _min?: UserTagsMinAggregateInputType
    _max?: UserTagsMaxAggregateInputType
  }

  export type UserTagsGroupByOutputType = {
    id: number
    user_id: number
    tag: string
    created_at: Date
    _count: UserTagsCountAggregateOutputType | null
    _avg: UserTagsAvgAggregateOutputType | null
    _sum: UserTagsSumAggregateOutputType | null
    _min: UserTagsMinAggregateOutputType | null
    _max: UserTagsMaxAggregateOutputType | null
  }

  type GetUserTagsGroupByPayload<T extends UserTagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTagsGroupByOutputType[P]>
            : GetScalarType<T[P], UserTagsGroupByOutputType[P]>
        }
      >
    >


  export type UserTagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    tag?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTags"]>

  export type UserTagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    tag?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTags"]>

  export type UserTagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    tag?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTags"]>

  export type UserTagsSelectScalar = {
    id?: boolean
    user_id?: boolean
    tag?: boolean
    created_at?: boolean
  }

  export type UserTagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "tag" | "created_at", ExtArgs["result"]["userTags"]>
  export type UserTagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserTagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserTagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserTagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTags"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      tag: string
      created_at: Date
    }, ExtArgs["result"]["userTags"]>
    composites: {}
  }

  type UserTagsGetPayload<S extends boolean | null | undefined | UserTagsDefaultArgs> = $Result.GetResult<Prisma.$UserTagsPayload, S>

  type UserTagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTagsCountAggregateInputType | true
    }

  export interface UserTagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTags'], meta: { name: 'UserTags' } }
    /**
     * Find zero or one UserTags that matches the filter.
     * @param {UserTagsFindUniqueArgs} args - Arguments to find a UserTags
     * @example
     * // Get one UserTags
     * const userTags = await prisma.userTags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTagsFindUniqueArgs>(args: SelectSubset<T, UserTagsFindUniqueArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTagsFindUniqueOrThrowArgs} args - Arguments to find a UserTags
     * @example
     * // Get one UserTags
     * const userTags = await prisma.userTags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTagsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsFindFirstArgs} args - Arguments to find a UserTags
     * @example
     * // Get one UserTags
     * const userTags = await prisma.userTags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTagsFindFirstArgs>(args?: SelectSubset<T, UserTagsFindFirstArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsFindFirstOrThrowArgs} args - Arguments to find a UserTags
     * @example
     * // Get one UserTags
     * const userTags = await prisma.userTags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTagsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTags
     * const userTags = await prisma.userTags.findMany()
     * 
     * // Get first 10 UserTags
     * const userTags = await prisma.userTags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTagsWithIdOnly = await prisma.userTags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTagsFindManyArgs>(args?: SelectSubset<T, UserTagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTags.
     * @param {UserTagsCreateArgs} args - Arguments to create a UserTags.
     * @example
     * // Create one UserTags
     * const UserTags = await prisma.userTags.create({
     *   data: {
     *     // ... data to create a UserTags
     *   }
     * })
     * 
     */
    create<T extends UserTagsCreateArgs>(args: SelectSubset<T, UserTagsCreateArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTags.
     * @param {UserTagsCreateManyArgs} args - Arguments to create many UserTags.
     * @example
     * // Create many UserTags
     * const userTags = await prisma.userTags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTagsCreateManyArgs>(args?: SelectSubset<T, UserTagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTags and returns the data saved in the database.
     * @param {UserTagsCreateManyAndReturnArgs} args - Arguments to create many UserTags.
     * @example
     * // Create many UserTags
     * const userTags = await prisma.userTags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTags and only return the `id`
     * const userTagsWithIdOnly = await prisma.userTags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTagsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTags.
     * @param {UserTagsDeleteArgs} args - Arguments to delete one UserTags.
     * @example
     * // Delete one UserTags
     * const UserTags = await prisma.userTags.delete({
     *   where: {
     *     // ... filter to delete one UserTags
     *   }
     * })
     * 
     */
    delete<T extends UserTagsDeleteArgs>(args: SelectSubset<T, UserTagsDeleteArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTags.
     * @param {UserTagsUpdateArgs} args - Arguments to update one UserTags.
     * @example
     * // Update one UserTags
     * const userTags = await prisma.userTags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTagsUpdateArgs>(args: SelectSubset<T, UserTagsUpdateArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTags.
     * @param {UserTagsDeleteManyArgs} args - Arguments to filter UserTags to delete.
     * @example
     * // Delete a few UserTags
     * const { count } = await prisma.userTags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTagsDeleteManyArgs>(args?: SelectSubset<T, UserTagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTags
     * const userTags = await prisma.userTags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTagsUpdateManyArgs>(args: SelectSubset<T, UserTagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTags and returns the data updated in the database.
     * @param {UserTagsUpdateManyAndReturnArgs} args - Arguments to update many UserTags.
     * @example
     * // Update many UserTags
     * const userTags = await prisma.userTags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTags and only return the `id`
     * const userTagsWithIdOnly = await prisma.userTags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTagsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTags.
     * @param {UserTagsUpsertArgs} args - Arguments to update or create a UserTags.
     * @example
     * // Update or create a UserTags
     * const userTags = await prisma.userTags.upsert({
     *   create: {
     *     // ... data to create a UserTags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTags we want to update
     *   }
     * })
     */
    upsert<T extends UserTagsUpsertArgs>(args: SelectSubset<T, UserTagsUpsertArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsCountArgs} args - Arguments to filter UserTags to count.
     * @example
     * // Count the number of UserTags
     * const count = await prisma.userTags.count({
     *   where: {
     *     // ... the filter for the UserTags we want to count
     *   }
     * })
    **/
    count<T extends UserTagsCountArgs>(
      args?: Subset<T, UserTagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTagsAggregateArgs>(args: Subset<T, UserTagsAggregateArgs>): Prisma.PrismaPromise<GetUserTagsAggregateType<T>>

    /**
     * Group by UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTagsGroupByArgs['orderBy'] }
        : { orderBy?: UserTagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTags model
   */
  readonly fields: UserTagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTags model
   */
  interface UserTagsFieldRefs {
    readonly id: FieldRef<"UserTags", 'Int'>
    readonly user_id: FieldRef<"UserTags", 'Int'>
    readonly tag: FieldRef<"UserTags", 'String'>
    readonly created_at: FieldRef<"UserTags", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTags findUnique
   */
  export type UserTagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where: UserTagsWhereUniqueInput
  }

  /**
   * UserTags findUniqueOrThrow
   */
  export type UserTagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where: UserTagsWhereUniqueInput
  }

  /**
   * UserTags findFirst
   */
  export type UserTagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where?: UserTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     */
    cursor?: UserTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     */
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * UserTags findFirstOrThrow
   */
  export type UserTagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where?: UserTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     */
    cursor?: UserTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     */
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * UserTags findMany
   */
  export type UserTagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where?: UserTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTags.
     */
    cursor?: UserTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * UserTags create
   */
  export type UserTagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTags.
     */
    data: XOR<UserTagsCreateInput, UserTagsUncheckedCreateInput>
  }

  /**
   * UserTags createMany
   */
  export type UserTagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTags.
     */
    data: UserTagsCreateManyInput | UserTagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTags createManyAndReturn
   */
  export type UserTagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * The data used to create many UserTags.
     */
    data: UserTagsCreateManyInput | UserTagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTags update
   */
  export type UserTagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTags.
     */
    data: XOR<UserTagsUpdateInput, UserTagsUncheckedUpdateInput>
    /**
     * Choose, which UserTags to update.
     */
    where: UserTagsWhereUniqueInput
  }

  /**
   * UserTags updateMany
   */
  export type UserTagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTags.
     */
    data: XOR<UserTagsUpdateManyMutationInput, UserTagsUncheckedUpdateManyInput>
    /**
     * Filter which UserTags to update
     */
    where?: UserTagsWhereInput
    /**
     * Limit how many UserTags to update.
     */
    limit?: number
  }

  /**
   * UserTags updateManyAndReturn
   */
  export type UserTagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * The data used to update UserTags.
     */
    data: XOR<UserTagsUpdateManyMutationInput, UserTagsUncheckedUpdateManyInput>
    /**
     * Filter which UserTags to update
     */
    where?: UserTagsWhereInput
    /**
     * Limit how many UserTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTags upsert
   */
  export type UserTagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTags to update in case it exists.
     */
    where: UserTagsWhereUniqueInput
    /**
     * In case the UserTags found by the `where` argument doesn't exist, create a new UserTags with this data.
     */
    create: XOR<UserTagsCreateInput, UserTagsUncheckedCreateInput>
    /**
     * In case the UserTags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTagsUpdateInput, UserTagsUncheckedUpdateInput>
  }

  /**
   * UserTags delete
   */
  export type UserTagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter which UserTags to delete.
     */
    where: UserTagsWhereUniqueInput
  }

  /**
   * UserTags deleteMany
   */
  export type UserTagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTags to delete
     */
    where?: UserTagsWhereInput
    /**
     * Limit how many UserTags to delete.
     */
    limit?: number
  }

  /**
   * UserTags without action
   */
  export type UserTagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
  }


  /**
   * Model UserInventory
   */

  export type AggregateUserInventory = {
    _count: UserInventoryCountAggregateOutputType | null
    _avg: UserInventoryAvgAggregateOutputType | null
    _sum: UserInventorySumAggregateOutputType | null
    _min: UserInventoryMinAggregateOutputType | null
    _max: UserInventoryMaxAggregateOutputType | null
  }

  export type UserInventoryAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type UserInventorySumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type UserInventoryMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    type: string | null
    name: string | null
    quality: string | null
    created_at: Date | null
  }

  export type UserInventoryMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    type: string | null
    name: string | null
    quality: string | null
    created_at: Date | null
  }

  export type UserInventoryCountAggregateOutputType = {
    id: number
    user_id: number
    type: number
    name: number
    quality: number
    created_at: number
    _all: number
  }


  export type UserInventoryAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserInventorySumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserInventoryMinAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    name?: true
    quality?: true
    created_at?: true
  }

  export type UserInventoryMaxAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    name?: true
    quality?: true
    created_at?: true
  }

  export type UserInventoryCountAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    name?: true
    quality?: true
    created_at?: true
    _all?: true
  }

  export type UserInventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInventory to aggregate.
     */
    where?: UserInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventories to fetch.
     */
    orderBy?: UserInventoryOrderByWithRelationInput | UserInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInventories
    **/
    _count?: true | UserInventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserInventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserInventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInventoryMaxAggregateInputType
  }

  export type GetUserInventoryAggregateType<T extends UserInventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInventory[P]>
      : GetScalarType<T[P], AggregateUserInventory[P]>
  }




  export type UserInventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInventoryWhereInput
    orderBy?: UserInventoryOrderByWithAggregationInput | UserInventoryOrderByWithAggregationInput[]
    by: UserInventoryScalarFieldEnum[] | UserInventoryScalarFieldEnum
    having?: UserInventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInventoryCountAggregateInputType | true
    _avg?: UserInventoryAvgAggregateInputType
    _sum?: UserInventorySumAggregateInputType
    _min?: UserInventoryMinAggregateInputType
    _max?: UserInventoryMaxAggregateInputType
  }

  export type UserInventoryGroupByOutputType = {
    id: number
    user_id: number
    type: string | null
    name: string | null
    quality: string | null
    created_at: Date
    _count: UserInventoryCountAggregateOutputType | null
    _avg: UserInventoryAvgAggregateOutputType | null
    _sum: UserInventorySumAggregateOutputType | null
    _min: UserInventoryMinAggregateOutputType | null
    _max: UserInventoryMaxAggregateOutputType | null
  }

  type GetUserInventoryGroupByPayload<T extends UserInventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInventoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserInventoryGroupByOutputType[P]>
        }
      >
    >


  export type UserInventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    name?: boolean
    quality?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInventory"]>

  export type UserInventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    name?: boolean
    quality?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInventory"]>

  export type UserInventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    name?: boolean
    quality?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInventory"]>

  export type UserInventorySelectScalar = {
    id?: boolean
    user_id?: boolean
    type?: boolean
    name?: boolean
    quality?: boolean
    created_at?: boolean
  }

  export type UserInventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "type" | "name" | "quality" | "created_at", ExtArgs["result"]["userInventory"]>
  export type UserInventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserInventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserInventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserInventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInventory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      type: string | null
      name: string | null
      quality: string | null
      created_at: Date
    }, ExtArgs["result"]["userInventory"]>
    composites: {}
  }

  type UserInventoryGetPayload<S extends boolean | null | undefined | UserInventoryDefaultArgs> = $Result.GetResult<Prisma.$UserInventoryPayload, S>

  type UserInventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserInventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserInventoryCountAggregateInputType | true
    }

  export interface UserInventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInventory'], meta: { name: 'UserInventory' } }
    /**
     * Find zero or one UserInventory that matches the filter.
     * @param {UserInventoryFindUniqueArgs} args - Arguments to find a UserInventory
     * @example
     * // Get one UserInventory
     * const userInventory = await prisma.userInventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInventoryFindUniqueArgs>(args: SelectSubset<T, UserInventoryFindUniqueArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserInventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserInventoryFindUniqueOrThrowArgs} args - Arguments to find a UserInventory
     * @example
     * // Get one UserInventory
     * const userInventory = await prisma.userInventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryFindFirstArgs} args - Arguments to find a UserInventory
     * @example
     * // Get one UserInventory
     * const userInventory = await prisma.userInventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInventoryFindFirstArgs>(args?: SelectSubset<T, UserInventoryFindFirstArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryFindFirstOrThrowArgs} args - Arguments to find a UserInventory
     * @example
     * // Get one UserInventory
     * const userInventory = await prisma.userInventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserInventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInventories
     * const userInventories = await prisma.userInventory.findMany()
     * 
     * // Get first 10 UserInventories
     * const userInventories = await prisma.userInventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInventoryWithIdOnly = await prisma.userInventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInventoryFindManyArgs>(args?: SelectSubset<T, UserInventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserInventory.
     * @param {UserInventoryCreateArgs} args - Arguments to create a UserInventory.
     * @example
     * // Create one UserInventory
     * const UserInventory = await prisma.userInventory.create({
     *   data: {
     *     // ... data to create a UserInventory
     *   }
     * })
     * 
     */
    create<T extends UserInventoryCreateArgs>(args: SelectSubset<T, UserInventoryCreateArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserInventories.
     * @param {UserInventoryCreateManyArgs} args - Arguments to create many UserInventories.
     * @example
     * // Create many UserInventories
     * const userInventory = await prisma.userInventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInventoryCreateManyArgs>(args?: SelectSubset<T, UserInventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInventories and returns the data saved in the database.
     * @param {UserInventoryCreateManyAndReturnArgs} args - Arguments to create many UserInventories.
     * @example
     * // Create many UserInventories
     * const userInventory = await prisma.userInventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInventories and only return the `id`
     * const userInventoryWithIdOnly = await prisma.userInventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserInventory.
     * @param {UserInventoryDeleteArgs} args - Arguments to delete one UserInventory.
     * @example
     * // Delete one UserInventory
     * const UserInventory = await prisma.userInventory.delete({
     *   where: {
     *     // ... filter to delete one UserInventory
     *   }
     * })
     * 
     */
    delete<T extends UserInventoryDeleteArgs>(args: SelectSubset<T, UserInventoryDeleteArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserInventory.
     * @param {UserInventoryUpdateArgs} args - Arguments to update one UserInventory.
     * @example
     * // Update one UserInventory
     * const userInventory = await prisma.userInventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInventoryUpdateArgs>(args: SelectSubset<T, UserInventoryUpdateArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserInventories.
     * @param {UserInventoryDeleteManyArgs} args - Arguments to filter UserInventories to delete.
     * @example
     * // Delete a few UserInventories
     * const { count } = await prisma.userInventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInventoryDeleteManyArgs>(args?: SelectSubset<T, UserInventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInventories
     * const userInventory = await prisma.userInventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInventoryUpdateManyArgs>(args: SelectSubset<T, UserInventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInventories and returns the data updated in the database.
     * @param {UserInventoryUpdateManyAndReturnArgs} args - Arguments to update many UserInventories.
     * @example
     * // Update many UserInventories
     * const userInventory = await prisma.userInventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserInventories and only return the `id`
     * const userInventoryWithIdOnly = await prisma.userInventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserInventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserInventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserInventory.
     * @param {UserInventoryUpsertArgs} args - Arguments to update or create a UserInventory.
     * @example
     * // Update or create a UserInventory
     * const userInventory = await prisma.userInventory.upsert({
     *   create: {
     *     // ... data to create a UserInventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInventory we want to update
     *   }
     * })
     */
    upsert<T extends UserInventoryUpsertArgs>(args: SelectSubset<T, UserInventoryUpsertArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryCountArgs} args - Arguments to filter UserInventories to count.
     * @example
     * // Count the number of UserInventories
     * const count = await prisma.userInventory.count({
     *   where: {
     *     // ... the filter for the UserInventories we want to count
     *   }
     * })
    **/
    count<T extends UserInventoryCountArgs>(
      args?: Subset<T, UserInventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInventoryAggregateArgs>(args: Subset<T, UserInventoryAggregateArgs>): Prisma.PrismaPromise<GetUserInventoryAggregateType<T>>

    /**
     * Group by UserInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInventoryGroupByArgs['orderBy'] }
        : { orderBy?: UserInventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInventory model
   */
  readonly fields: UserInventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInventory model
   */
  interface UserInventoryFieldRefs {
    readonly id: FieldRef<"UserInventory", 'Int'>
    readonly user_id: FieldRef<"UserInventory", 'Int'>
    readonly type: FieldRef<"UserInventory", 'String'>
    readonly name: FieldRef<"UserInventory", 'String'>
    readonly quality: FieldRef<"UserInventory", 'String'>
    readonly created_at: FieldRef<"UserInventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserInventory findUnique
   */
  export type UserInventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * Filter, which UserInventory to fetch.
     */
    where: UserInventoryWhereUniqueInput
  }

  /**
   * UserInventory findUniqueOrThrow
   */
  export type UserInventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * Filter, which UserInventory to fetch.
     */
    where: UserInventoryWhereUniqueInput
  }

  /**
   * UserInventory findFirst
   */
  export type UserInventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * Filter, which UserInventory to fetch.
     */
    where?: UserInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventories to fetch.
     */
    orderBy?: UserInventoryOrderByWithRelationInput | UserInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInventories.
     */
    cursor?: UserInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInventories.
     */
    distinct?: UserInventoryScalarFieldEnum | UserInventoryScalarFieldEnum[]
  }

  /**
   * UserInventory findFirstOrThrow
   */
  export type UserInventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * Filter, which UserInventory to fetch.
     */
    where?: UserInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventories to fetch.
     */
    orderBy?: UserInventoryOrderByWithRelationInput | UserInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInventories.
     */
    cursor?: UserInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInventories.
     */
    distinct?: UserInventoryScalarFieldEnum | UserInventoryScalarFieldEnum[]
  }

  /**
   * UserInventory findMany
   */
  export type UserInventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * Filter, which UserInventories to fetch.
     */
    where?: UserInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventories to fetch.
     */
    orderBy?: UserInventoryOrderByWithRelationInput | UserInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInventories.
     */
    cursor?: UserInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventories.
     */
    skip?: number
    distinct?: UserInventoryScalarFieldEnum | UserInventoryScalarFieldEnum[]
  }

  /**
   * UserInventory create
   */
  export type UserInventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInventory.
     */
    data: XOR<UserInventoryCreateInput, UserInventoryUncheckedCreateInput>
  }

  /**
   * UserInventory createMany
   */
  export type UserInventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInventories.
     */
    data: UserInventoryCreateManyInput | UserInventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserInventory createManyAndReturn
   */
  export type UserInventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * The data used to create many UserInventories.
     */
    data: UserInventoryCreateManyInput | UserInventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInventory update
   */
  export type UserInventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInventory.
     */
    data: XOR<UserInventoryUpdateInput, UserInventoryUncheckedUpdateInput>
    /**
     * Choose, which UserInventory to update.
     */
    where: UserInventoryWhereUniqueInput
  }

  /**
   * UserInventory updateMany
   */
  export type UserInventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInventories.
     */
    data: XOR<UserInventoryUpdateManyMutationInput, UserInventoryUncheckedUpdateManyInput>
    /**
     * Filter which UserInventories to update
     */
    where?: UserInventoryWhereInput
    /**
     * Limit how many UserInventories to update.
     */
    limit?: number
  }

  /**
   * UserInventory updateManyAndReturn
   */
  export type UserInventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * The data used to update UserInventories.
     */
    data: XOR<UserInventoryUpdateManyMutationInput, UserInventoryUncheckedUpdateManyInput>
    /**
     * Filter which UserInventories to update
     */
    where?: UserInventoryWhereInput
    /**
     * Limit how many UserInventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInventory upsert
   */
  export type UserInventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInventory to update in case it exists.
     */
    where: UserInventoryWhereUniqueInput
    /**
     * In case the UserInventory found by the `where` argument doesn't exist, create a new UserInventory with this data.
     */
    create: XOR<UserInventoryCreateInput, UserInventoryUncheckedCreateInput>
    /**
     * In case the UserInventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInventoryUpdateInput, UserInventoryUncheckedUpdateInput>
  }

  /**
   * UserInventory delete
   */
  export type UserInventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * Filter which UserInventory to delete.
     */
    where: UserInventoryWhereUniqueInput
  }

  /**
   * UserInventory deleteMany
   */
  export type UserInventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInventories to delete
     */
    where?: UserInventoryWhereInput
    /**
     * Limit how many UserInventories to delete.
     */
    limit?: number
  }

  /**
   * UserInventory without action
   */
  export type UserInventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
  }


  /**
   * Model Tasks
   */

  export type AggregateTasks = {
    _count: TasksCountAggregateOutputType | null
    _avg: TasksAvgAggregateOutputType | null
    _sum: TasksSumAggregateOutputType | null
    _min: TasksMinAggregateOutputType | null
    _max: TasksMaxAggregateOutputType | null
  }

  export type TasksAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type TasksSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type TasksMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    completed_at: Date | null
    created_at: Date | null
  }

  export type TasksMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    completed_at: Date | null
    created_at: Date | null
  }

  export type TasksCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    completed_at: number
    created_at: number
    _all: number
  }


  export type TasksAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type TasksSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type TasksMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    completed_at?: true
    created_at?: true
  }

  export type TasksMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    completed_at?: true
    created_at?: true
  }

  export type TasksCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    completed_at?: true
    created_at?: true
    _all?: true
  }

  export type TasksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to aggregate.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TasksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TasksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TasksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TasksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TasksMaxAggregateInputType
  }

  export type GetTasksAggregateType<T extends TasksAggregateArgs> = {
        [P in keyof T & keyof AggregateTasks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTasks[P]>
      : GetScalarType<T[P], AggregateTasks[P]>
  }




  export type TasksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksWhereInput
    orderBy?: TasksOrderByWithAggregationInput | TasksOrderByWithAggregationInput[]
    by: TasksScalarFieldEnum[] | TasksScalarFieldEnum
    having?: TasksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TasksCountAggregateInputType | true
    _avg?: TasksAvgAggregateInputType
    _sum?: TasksSumAggregateInputType
    _min?: TasksMinAggregateInputType
    _max?: TasksMaxAggregateInputType
  }

  export type TasksGroupByOutputType = {
    id: number
    user_id: number
    name: string | null
    completed_at: Date | null
    created_at: Date
    _count: TasksCountAggregateOutputType | null
    _avg: TasksAvgAggregateOutputType | null
    _sum: TasksSumAggregateOutputType | null
    _min: TasksMinAggregateOutputType | null
    _max: TasksMaxAggregateOutputType | null
  }

  type GetTasksGroupByPayload<T extends TasksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TasksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TasksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TasksGroupByOutputType[P]>
            : GetScalarType<T[P], TasksGroupByOutputType[P]>
        }
      >
    >


  export type TasksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    completed_at?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Tasks$assignedToArgs<ExtArgs>
    _count?: boolean | TasksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasks"]>

  export type TasksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    completed_at?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasks"]>

  export type TasksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    completed_at?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasks"]>

  export type TasksSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    completed_at?: boolean
    created_at?: boolean
  }

  export type TasksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "name" | "completed_at" | "created_at", ExtArgs["result"]["tasks"]>
  export type TasksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Tasks$assignedToArgs<ExtArgs>
    _count?: boolean | TasksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TasksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TasksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TasksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tasks"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$TasksUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      name: string | null
      completed_at: Date | null
      created_at: Date
    }, ExtArgs["result"]["tasks"]>
    composites: {}
  }

  type TasksGetPayload<S extends boolean | null | undefined | TasksDefaultArgs> = $Result.GetResult<Prisma.$TasksPayload, S>

  type TasksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TasksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TasksCountAggregateInputType | true
    }

  export interface TasksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tasks'], meta: { name: 'Tasks' } }
    /**
     * Find zero or one Tasks that matches the filter.
     * @param {TasksFindUniqueArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TasksFindUniqueArgs>(args: SelectSubset<T, TasksFindUniqueArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tasks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TasksFindUniqueOrThrowArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TasksFindUniqueOrThrowArgs>(args: SelectSubset<T, TasksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindFirstArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TasksFindFirstArgs>(args?: SelectSubset<T, TasksFindFirstArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tasks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindFirstOrThrowArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TasksFindFirstOrThrowArgs>(args?: SelectSubset<T, TasksFindFirstOrThrowArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.tasks.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.tasks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tasksWithIdOnly = await prisma.tasks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TasksFindManyArgs>(args?: SelectSubset<T, TasksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tasks.
     * @param {TasksCreateArgs} args - Arguments to create a Tasks.
     * @example
     * // Create one Tasks
     * const Tasks = await prisma.tasks.create({
     *   data: {
     *     // ... data to create a Tasks
     *   }
     * })
     * 
     */
    create<T extends TasksCreateArgs>(args: SelectSubset<T, TasksCreateArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TasksCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const tasks = await prisma.tasks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TasksCreateManyArgs>(args?: SelectSubset<T, TasksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TasksCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const tasks = await prisma.tasks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const tasksWithIdOnly = await prisma.tasks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TasksCreateManyAndReturnArgs>(args?: SelectSubset<T, TasksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tasks.
     * @param {TasksDeleteArgs} args - Arguments to delete one Tasks.
     * @example
     * // Delete one Tasks
     * const Tasks = await prisma.tasks.delete({
     *   where: {
     *     // ... filter to delete one Tasks
     *   }
     * })
     * 
     */
    delete<T extends TasksDeleteArgs>(args: SelectSubset<T, TasksDeleteArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tasks.
     * @param {TasksUpdateArgs} args - Arguments to update one Tasks.
     * @example
     * // Update one Tasks
     * const tasks = await prisma.tasks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TasksUpdateArgs>(args: SelectSubset<T, TasksUpdateArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TasksDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.tasks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TasksDeleteManyArgs>(args?: SelectSubset<T, TasksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const tasks = await prisma.tasks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TasksUpdateManyArgs>(args: SelectSubset<T, TasksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TasksUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const tasks = await prisma.tasks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const tasksWithIdOnly = await prisma.tasks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TasksUpdateManyAndReturnArgs>(args: SelectSubset<T, TasksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tasks.
     * @param {TasksUpsertArgs} args - Arguments to update or create a Tasks.
     * @example
     * // Update or create a Tasks
     * const tasks = await prisma.tasks.upsert({
     *   create: {
     *     // ... data to create a Tasks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tasks we want to update
     *   }
     * })
     */
    upsert<T extends TasksUpsertArgs>(args: SelectSubset<T, TasksUpsertArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.tasks.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TasksCountArgs>(
      args?: Subset<T, TasksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TasksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TasksAggregateArgs>(args: Subset<T, TasksAggregateArgs>): Prisma.PrismaPromise<GetTasksAggregateType<T>>

    /**
     * Group by Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TasksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TasksGroupByArgs['orderBy'] }
        : { orderBy?: TasksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TasksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTasksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tasks model
   */
  readonly fields: TasksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tasks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TasksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends Tasks$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Tasks$assignedToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tasks model
   */
  interface TasksFieldRefs {
    readonly id: FieldRef<"Tasks", 'Int'>
    readonly user_id: FieldRef<"Tasks", 'Int'>
    readonly name: FieldRef<"Tasks", 'String'>
    readonly completed_at: FieldRef<"Tasks", 'DateTime'>
    readonly created_at: FieldRef<"Tasks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tasks findUnique
   */
  export type TasksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks findUniqueOrThrow
   */
  export type TasksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks findFirst
   */
  export type TasksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Tasks findFirstOrThrow
   */
  export type TasksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Tasks findMany
   */
  export type TasksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Tasks create
   */
  export type TasksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * The data needed to create a Tasks.
     */
    data: XOR<TasksCreateInput, TasksUncheckedCreateInput>
  }

  /**
   * Tasks createMany
   */
  export type TasksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TasksCreateManyInput | TasksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tasks createManyAndReturn
   */
  export type TasksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TasksCreateManyInput | TasksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tasks update
   */
  export type TasksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * The data needed to update a Tasks.
     */
    data: XOR<TasksUpdateInput, TasksUncheckedUpdateInput>
    /**
     * Choose, which Tasks to update.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks updateMany
   */
  export type TasksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TasksWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Tasks updateManyAndReturn
   */
  export type TasksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TasksWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tasks upsert
   */
  export type TasksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * The filter to search for the Tasks to update in case it exists.
     */
    where: TasksWhereUniqueInput
    /**
     * In case the Tasks found by the `where` argument doesn't exist, create a new Tasks with this data.
     */
    create: XOR<TasksCreateInput, TasksUncheckedCreateInput>
    /**
     * In case the Tasks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TasksUpdateInput, TasksUncheckedUpdateInput>
  }

  /**
   * Tasks delete
   */
  export type TasksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter which Tasks to delete.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks deleteMany
   */
  export type TasksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TasksWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Tasks.assignedTo
   */
  export type Tasks$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    where?: TasksUserWhereInput
    orderBy?: TasksUserOrderByWithRelationInput | TasksUserOrderByWithRelationInput[]
    cursor?: TasksUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TasksUserScalarFieldEnum | TasksUserScalarFieldEnum[]
  }

  /**
   * Tasks without action
   */
  export type TasksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
  }


  /**
   * Model Raid
   */

  export type AggregateRaid = {
    _count: RaidCountAggregateOutputType | null
    _avg: RaidAvgAggregateOutputType | null
    _sum: RaidSumAggregateOutputType | null
    _min: RaidMinAggregateOutputType | null
    _max: RaidMaxAggregateOutputType | null
  }

  export type RaidAvgAggregateOutputType = {
    id: number | null
    dkp_summary: number | null
  }

  export type RaidSumAggregateOutputType = {
    id: number | null
    dkp_summary: number | null
  }

  export type RaidMinAggregateOutputType = {
    id: number | null
    type: string | null
    is_pvp: boolean | null
    is_pvp_long: boolean | null
    start_date: Date | null
    created_at: Date | null
    dkp_summary: number | null
  }

  export type RaidMaxAggregateOutputType = {
    id: number | null
    type: string | null
    is_pvp: boolean | null
    is_pvp_long: boolean | null
    start_date: Date | null
    created_at: Date | null
    dkp_summary: number | null
  }

  export type RaidCountAggregateOutputType = {
    id: number
    type: number
    is_pvp: number
    is_pvp_long: number
    start_date: number
    created_at: number
    dkp_summary: number
    _all: number
  }


  export type RaidAvgAggregateInputType = {
    id?: true
    dkp_summary?: true
  }

  export type RaidSumAggregateInputType = {
    id?: true
    dkp_summary?: true
  }

  export type RaidMinAggregateInputType = {
    id?: true
    type?: true
    is_pvp?: true
    is_pvp_long?: true
    start_date?: true
    created_at?: true
    dkp_summary?: true
  }

  export type RaidMaxAggregateInputType = {
    id?: true
    type?: true
    is_pvp?: true
    is_pvp_long?: true
    start_date?: true
    created_at?: true
    dkp_summary?: true
  }

  export type RaidCountAggregateInputType = {
    id?: true
    type?: true
    is_pvp?: true
    is_pvp_long?: true
    start_date?: true
    created_at?: true
    dkp_summary?: true
    _all?: true
  }

  export type RaidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Raid to aggregate.
     */
    where?: RaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Raids to fetch.
     */
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Raids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Raids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Raids
    **/
    _count?: true | RaidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaidMaxAggregateInputType
  }

  export type GetRaidAggregateType<T extends RaidAggregateArgs> = {
        [P in keyof T & keyof AggregateRaid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaid[P]>
      : GetScalarType<T[P], AggregateRaid[P]>
  }




  export type RaidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidWhereInput
    orderBy?: RaidOrderByWithAggregationInput | RaidOrderByWithAggregationInput[]
    by: RaidScalarFieldEnum[] | RaidScalarFieldEnum
    having?: RaidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaidCountAggregateInputType | true
    _avg?: RaidAvgAggregateInputType
    _sum?: RaidSumAggregateInputType
    _min?: RaidMinAggregateInputType
    _max?: RaidMaxAggregateInputType
  }

  export type RaidGroupByOutputType = {
    id: number
    type: string | null
    is_pvp: boolean
    is_pvp_long: boolean
    start_date: Date | null
    created_at: Date
    dkp_summary: number
    _count: RaidCountAggregateOutputType | null
    _avg: RaidAvgAggregateOutputType | null
    _sum: RaidSumAggregateOutputType | null
    _min: RaidMinAggregateOutputType | null
    _max: RaidMaxAggregateOutputType | null
  }

  type GetRaidGroupByPayload<T extends RaidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaidGroupByOutputType[P]>
            : GetScalarType<T[P], RaidGroupByOutputType[P]>
        }
      >
    >


  export type RaidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    is_pvp?: boolean
    is_pvp_long?: boolean
    start_date?: boolean
    created_at?: boolean
    dkp_summary?: boolean
    raidBosses?: boolean | Raid$raidBossesArgs<ExtArgs>
    attendance?: boolean | Raid$attendanceArgs<ExtArgs>
    _count?: boolean | RaidCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raid"]>

  export type RaidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    is_pvp?: boolean
    is_pvp_long?: boolean
    start_date?: boolean
    created_at?: boolean
    dkp_summary?: boolean
  }, ExtArgs["result"]["raid"]>

  export type RaidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    is_pvp?: boolean
    is_pvp_long?: boolean
    start_date?: boolean
    created_at?: boolean
    dkp_summary?: boolean
  }, ExtArgs["result"]["raid"]>

  export type RaidSelectScalar = {
    id?: boolean
    type?: boolean
    is_pvp?: boolean
    is_pvp_long?: boolean
    start_date?: boolean
    created_at?: boolean
    dkp_summary?: boolean
  }

  export type RaidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "is_pvp" | "is_pvp_long" | "start_date" | "created_at" | "dkp_summary", ExtArgs["result"]["raid"]>
  export type RaidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raidBosses?: boolean | Raid$raidBossesArgs<ExtArgs>
    attendance?: boolean | Raid$attendanceArgs<ExtArgs>
    _count?: boolean | RaidCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RaidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RaidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RaidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Raid"
    objects: {
      raidBosses: Prisma.$RaidBossPayload<ExtArgs>[]
      attendance: Prisma.$RaidAttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string | null
      is_pvp: boolean
      is_pvp_long: boolean
      start_date: Date | null
      created_at: Date
      dkp_summary: number
    }, ExtArgs["result"]["raid"]>
    composites: {}
  }

  type RaidGetPayload<S extends boolean | null | undefined | RaidDefaultArgs> = $Result.GetResult<Prisma.$RaidPayload, S>

  type RaidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaidCountAggregateInputType | true
    }

  export interface RaidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Raid'], meta: { name: 'Raid' } }
    /**
     * Find zero or one Raid that matches the filter.
     * @param {RaidFindUniqueArgs} args - Arguments to find a Raid
     * @example
     * // Get one Raid
     * const raid = await prisma.raid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaidFindUniqueArgs>(args: SelectSubset<T, RaidFindUniqueArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Raid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaidFindUniqueOrThrowArgs} args - Arguments to find a Raid
     * @example
     * // Get one Raid
     * const raid = await prisma.raid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaidFindUniqueOrThrowArgs>(args: SelectSubset<T, RaidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Raid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidFindFirstArgs} args - Arguments to find a Raid
     * @example
     * // Get one Raid
     * const raid = await prisma.raid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaidFindFirstArgs>(args?: SelectSubset<T, RaidFindFirstArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Raid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidFindFirstOrThrowArgs} args - Arguments to find a Raid
     * @example
     * // Get one Raid
     * const raid = await prisma.raid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaidFindFirstOrThrowArgs>(args?: SelectSubset<T, RaidFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Raids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Raids
     * const raids = await prisma.raid.findMany()
     * 
     * // Get first 10 Raids
     * const raids = await prisma.raid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raidWithIdOnly = await prisma.raid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaidFindManyArgs>(args?: SelectSubset<T, RaidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Raid.
     * @param {RaidCreateArgs} args - Arguments to create a Raid.
     * @example
     * // Create one Raid
     * const Raid = await prisma.raid.create({
     *   data: {
     *     // ... data to create a Raid
     *   }
     * })
     * 
     */
    create<T extends RaidCreateArgs>(args: SelectSubset<T, RaidCreateArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Raids.
     * @param {RaidCreateManyArgs} args - Arguments to create many Raids.
     * @example
     * // Create many Raids
     * const raid = await prisma.raid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaidCreateManyArgs>(args?: SelectSubset<T, RaidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Raids and returns the data saved in the database.
     * @param {RaidCreateManyAndReturnArgs} args - Arguments to create many Raids.
     * @example
     * // Create many Raids
     * const raid = await prisma.raid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Raids and only return the `id`
     * const raidWithIdOnly = await prisma.raid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaidCreateManyAndReturnArgs>(args?: SelectSubset<T, RaidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Raid.
     * @param {RaidDeleteArgs} args - Arguments to delete one Raid.
     * @example
     * // Delete one Raid
     * const Raid = await prisma.raid.delete({
     *   where: {
     *     // ... filter to delete one Raid
     *   }
     * })
     * 
     */
    delete<T extends RaidDeleteArgs>(args: SelectSubset<T, RaidDeleteArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Raid.
     * @param {RaidUpdateArgs} args - Arguments to update one Raid.
     * @example
     * // Update one Raid
     * const raid = await prisma.raid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaidUpdateArgs>(args: SelectSubset<T, RaidUpdateArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Raids.
     * @param {RaidDeleteManyArgs} args - Arguments to filter Raids to delete.
     * @example
     * // Delete a few Raids
     * const { count } = await prisma.raid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaidDeleteManyArgs>(args?: SelectSubset<T, RaidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Raids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Raids
     * const raid = await prisma.raid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaidUpdateManyArgs>(args: SelectSubset<T, RaidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Raids and returns the data updated in the database.
     * @param {RaidUpdateManyAndReturnArgs} args - Arguments to update many Raids.
     * @example
     * // Update many Raids
     * const raid = await prisma.raid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Raids and only return the `id`
     * const raidWithIdOnly = await prisma.raid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaidUpdateManyAndReturnArgs>(args: SelectSubset<T, RaidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Raid.
     * @param {RaidUpsertArgs} args - Arguments to update or create a Raid.
     * @example
     * // Update or create a Raid
     * const raid = await prisma.raid.upsert({
     *   create: {
     *     // ... data to create a Raid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Raid we want to update
     *   }
     * })
     */
    upsert<T extends RaidUpsertArgs>(args: SelectSubset<T, RaidUpsertArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Raids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidCountArgs} args - Arguments to filter Raids to count.
     * @example
     * // Count the number of Raids
     * const count = await prisma.raid.count({
     *   where: {
     *     // ... the filter for the Raids we want to count
     *   }
     * })
    **/
    count<T extends RaidCountArgs>(
      args?: Subset<T, RaidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Raid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaidAggregateArgs>(args: Subset<T, RaidAggregateArgs>): Prisma.PrismaPromise<GetRaidAggregateType<T>>

    /**
     * Group by Raid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaidGroupByArgs['orderBy'] }
        : { orderBy?: RaidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Raid model
   */
  readonly fields: RaidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Raid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    raidBosses<T extends Raid$raidBossesArgs<ExtArgs> = {}>(args?: Subset<T, Raid$raidBossesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends Raid$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Raid$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Raid model
   */
  interface RaidFieldRefs {
    readonly id: FieldRef<"Raid", 'Int'>
    readonly type: FieldRef<"Raid", 'String'>
    readonly is_pvp: FieldRef<"Raid", 'Boolean'>
    readonly is_pvp_long: FieldRef<"Raid", 'Boolean'>
    readonly start_date: FieldRef<"Raid", 'DateTime'>
    readonly created_at: FieldRef<"Raid", 'DateTime'>
    readonly dkp_summary: FieldRef<"Raid", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Raid findUnique
   */
  export type RaidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raid to fetch.
     */
    where: RaidWhereUniqueInput
  }

  /**
   * Raid findUniqueOrThrow
   */
  export type RaidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raid to fetch.
     */
    where: RaidWhereUniqueInput
  }

  /**
   * Raid findFirst
   */
  export type RaidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raid to fetch.
     */
    where?: RaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Raids to fetch.
     */
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Raids.
     */
    cursor?: RaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Raids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Raids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Raids.
     */
    distinct?: RaidScalarFieldEnum | RaidScalarFieldEnum[]
  }

  /**
   * Raid findFirstOrThrow
   */
  export type RaidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raid to fetch.
     */
    where?: RaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Raids to fetch.
     */
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Raids.
     */
    cursor?: RaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Raids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Raids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Raids.
     */
    distinct?: RaidScalarFieldEnum | RaidScalarFieldEnum[]
  }

  /**
   * Raid findMany
   */
  export type RaidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raids to fetch.
     */
    where?: RaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Raids to fetch.
     */
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Raids.
     */
    cursor?: RaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Raids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Raids.
     */
    skip?: number
    distinct?: RaidScalarFieldEnum | RaidScalarFieldEnum[]
  }

  /**
   * Raid create
   */
  export type RaidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * The data needed to create a Raid.
     */
    data?: XOR<RaidCreateInput, RaidUncheckedCreateInput>
  }

  /**
   * Raid createMany
   */
  export type RaidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Raids.
     */
    data: RaidCreateManyInput | RaidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Raid createManyAndReturn
   */
  export type RaidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * The data used to create many Raids.
     */
    data: RaidCreateManyInput | RaidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Raid update
   */
  export type RaidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * The data needed to update a Raid.
     */
    data: XOR<RaidUpdateInput, RaidUncheckedUpdateInput>
    /**
     * Choose, which Raid to update.
     */
    where: RaidWhereUniqueInput
  }

  /**
   * Raid updateMany
   */
  export type RaidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Raids.
     */
    data: XOR<RaidUpdateManyMutationInput, RaidUncheckedUpdateManyInput>
    /**
     * Filter which Raids to update
     */
    where?: RaidWhereInput
    /**
     * Limit how many Raids to update.
     */
    limit?: number
  }

  /**
   * Raid updateManyAndReturn
   */
  export type RaidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * The data used to update Raids.
     */
    data: XOR<RaidUpdateManyMutationInput, RaidUncheckedUpdateManyInput>
    /**
     * Filter which Raids to update
     */
    where?: RaidWhereInput
    /**
     * Limit how many Raids to update.
     */
    limit?: number
  }

  /**
   * Raid upsert
   */
  export type RaidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * The filter to search for the Raid to update in case it exists.
     */
    where: RaidWhereUniqueInput
    /**
     * In case the Raid found by the `where` argument doesn't exist, create a new Raid with this data.
     */
    create: XOR<RaidCreateInput, RaidUncheckedCreateInput>
    /**
     * In case the Raid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaidUpdateInput, RaidUncheckedUpdateInput>
  }

  /**
   * Raid delete
   */
  export type RaidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter which Raid to delete.
     */
    where: RaidWhereUniqueInput
  }

  /**
   * Raid deleteMany
   */
  export type RaidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Raids to delete
     */
    where?: RaidWhereInput
    /**
     * Limit how many Raids to delete.
     */
    limit?: number
  }

  /**
   * Raid.raidBosses
   */
  export type Raid$raidBossesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    where?: RaidBossWhereInput
    orderBy?: RaidBossOrderByWithRelationInput | RaidBossOrderByWithRelationInput[]
    cursor?: RaidBossWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaidBossScalarFieldEnum | RaidBossScalarFieldEnum[]
  }

  /**
   * Raid.attendance
   */
  export type Raid$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    where?: RaidAttendanceWhereInput
    orderBy?: RaidAttendanceOrderByWithRelationInput | RaidAttendanceOrderByWithRelationInput[]
    cursor?: RaidAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaidAttendanceScalarFieldEnum | RaidAttendanceScalarFieldEnum[]
  }

  /**
   * Raid without action
   */
  export type RaidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
  }


  /**
   * Model Boss
   */

  export type AggregateBoss = {
    _count: BossCountAggregateOutputType | null
    _avg: BossAvgAggregateOutputType | null
    _sum: BossSumAggregateOutputType | null
    _min: BossMinAggregateOutputType | null
    _max: BossMaxAggregateOutputType | null
  }

  export type BossAvgAggregateOutputType = {
    id: number | null
    dkp_points: number | null
  }

  export type BossSumAggregateOutputType = {
    id: number | null
    dkp_points: number | null
  }

  export type BossMinAggregateOutputType = {
    id: number | null
    boss_name: string | null
    dkp_points: number | null
    category: string | null
  }

  export type BossMaxAggregateOutputType = {
    id: number | null
    boss_name: string | null
    dkp_points: number | null
    category: string | null
  }

  export type BossCountAggregateOutputType = {
    id: number
    boss_name: number
    dkp_points: number
    category: number
    _all: number
  }


  export type BossAvgAggregateInputType = {
    id?: true
    dkp_points?: true
  }

  export type BossSumAggregateInputType = {
    id?: true
    dkp_points?: true
  }

  export type BossMinAggregateInputType = {
    id?: true
    boss_name?: true
    dkp_points?: true
    category?: true
  }

  export type BossMaxAggregateInputType = {
    id?: true
    boss_name?: true
    dkp_points?: true
    category?: true
  }

  export type BossCountAggregateInputType = {
    id?: true
    boss_name?: true
    dkp_points?: true
    category?: true
    _all?: true
  }

  export type BossAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boss to aggregate.
     */
    where?: BossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bosses to fetch.
     */
    orderBy?: BossOrderByWithRelationInput | BossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bosses
    **/
    _count?: true | BossCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BossAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BossSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BossMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BossMaxAggregateInputType
  }

  export type GetBossAggregateType<T extends BossAggregateArgs> = {
        [P in keyof T & keyof AggregateBoss]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoss[P]>
      : GetScalarType<T[P], AggregateBoss[P]>
  }




  export type BossGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BossWhereInput
    orderBy?: BossOrderByWithAggregationInput | BossOrderByWithAggregationInput[]
    by: BossScalarFieldEnum[] | BossScalarFieldEnum
    having?: BossScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BossCountAggregateInputType | true
    _avg?: BossAvgAggregateInputType
    _sum?: BossSumAggregateInputType
    _min?: BossMinAggregateInputType
    _max?: BossMaxAggregateInputType
  }

  export type BossGroupByOutputType = {
    id: number
    boss_name: string
    dkp_points: number
    category: string
    _count: BossCountAggregateOutputType | null
    _avg: BossAvgAggregateOutputType | null
    _sum: BossSumAggregateOutputType | null
    _min: BossMinAggregateOutputType | null
    _max: BossMaxAggregateOutputType | null
  }

  type GetBossGroupByPayload<T extends BossGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BossGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BossGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BossGroupByOutputType[P]>
            : GetScalarType<T[P], BossGroupByOutputType[P]>
        }
      >
    >


  export type BossSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boss_name?: boolean
    dkp_points?: boolean
    category?: boolean
    raidBosses?: boolean | Boss$raidBossesArgs<ExtArgs>
    _count?: boolean | BossCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boss"]>

  export type BossSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boss_name?: boolean
    dkp_points?: boolean
    category?: boolean
  }, ExtArgs["result"]["boss"]>

  export type BossSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boss_name?: boolean
    dkp_points?: boolean
    category?: boolean
  }, ExtArgs["result"]["boss"]>

  export type BossSelectScalar = {
    id?: boolean
    boss_name?: boolean
    dkp_points?: boolean
    category?: boolean
  }

  export type BossOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "boss_name" | "dkp_points" | "category", ExtArgs["result"]["boss"]>
  export type BossInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raidBosses?: boolean | Boss$raidBossesArgs<ExtArgs>
    _count?: boolean | BossCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BossIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BossIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BossPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Boss"
    objects: {
      raidBosses: Prisma.$RaidBossPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      boss_name: string
      dkp_points: number
      category: string
    }, ExtArgs["result"]["boss"]>
    composites: {}
  }

  type BossGetPayload<S extends boolean | null | undefined | BossDefaultArgs> = $Result.GetResult<Prisma.$BossPayload, S>

  type BossCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BossFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BossCountAggregateInputType | true
    }

  export interface BossDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Boss'], meta: { name: 'Boss' } }
    /**
     * Find zero or one Boss that matches the filter.
     * @param {BossFindUniqueArgs} args - Arguments to find a Boss
     * @example
     * // Get one Boss
     * const boss = await prisma.boss.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BossFindUniqueArgs>(args: SelectSubset<T, BossFindUniqueArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Boss that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BossFindUniqueOrThrowArgs} args - Arguments to find a Boss
     * @example
     * // Get one Boss
     * const boss = await prisma.boss.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BossFindUniqueOrThrowArgs>(args: SelectSubset<T, BossFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boss that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossFindFirstArgs} args - Arguments to find a Boss
     * @example
     * // Get one Boss
     * const boss = await prisma.boss.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BossFindFirstArgs>(args?: SelectSubset<T, BossFindFirstArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boss that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossFindFirstOrThrowArgs} args - Arguments to find a Boss
     * @example
     * // Get one Boss
     * const boss = await prisma.boss.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BossFindFirstOrThrowArgs>(args?: SelectSubset<T, BossFindFirstOrThrowArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bosses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bosses
     * const bosses = await prisma.boss.findMany()
     * 
     * // Get first 10 Bosses
     * const bosses = await prisma.boss.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bossWithIdOnly = await prisma.boss.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BossFindManyArgs>(args?: SelectSubset<T, BossFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Boss.
     * @param {BossCreateArgs} args - Arguments to create a Boss.
     * @example
     * // Create one Boss
     * const Boss = await prisma.boss.create({
     *   data: {
     *     // ... data to create a Boss
     *   }
     * })
     * 
     */
    create<T extends BossCreateArgs>(args: SelectSubset<T, BossCreateArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bosses.
     * @param {BossCreateManyArgs} args - Arguments to create many Bosses.
     * @example
     * // Create many Bosses
     * const boss = await prisma.boss.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BossCreateManyArgs>(args?: SelectSubset<T, BossCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bosses and returns the data saved in the database.
     * @param {BossCreateManyAndReturnArgs} args - Arguments to create many Bosses.
     * @example
     * // Create many Bosses
     * const boss = await prisma.boss.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bosses and only return the `id`
     * const bossWithIdOnly = await prisma.boss.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BossCreateManyAndReturnArgs>(args?: SelectSubset<T, BossCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Boss.
     * @param {BossDeleteArgs} args - Arguments to delete one Boss.
     * @example
     * // Delete one Boss
     * const Boss = await prisma.boss.delete({
     *   where: {
     *     // ... filter to delete one Boss
     *   }
     * })
     * 
     */
    delete<T extends BossDeleteArgs>(args: SelectSubset<T, BossDeleteArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Boss.
     * @param {BossUpdateArgs} args - Arguments to update one Boss.
     * @example
     * // Update one Boss
     * const boss = await prisma.boss.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BossUpdateArgs>(args: SelectSubset<T, BossUpdateArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bosses.
     * @param {BossDeleteManyArgs} args - Arguments to filter Bosses to delete.
     * @example
     * // Delete a few Bosses
     * const { count } = await prisma.boss.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BossDeleteManyArgs>(args?: SelectSubset<T, BossDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bosses
     * const boss = await prisma.boss.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BossUpdateManyArgs>(args: SelectSubset<T, BossUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bosses and returns the data updated in the database.
     * @param {BossUpdateManyAndReturnArgs} args - Arguments to update many Bosses.
     * @example
     * // Update many Bosses
     * const boss = await prisma.boss.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bosses and only return the `id`
     * const bossWithIdOnly = await prisma.boss.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BossUpdateManyAndReturnArgs>(args: SelectSubset<T, BossUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Boss.
     * @param {BossUpsertArgs} args - Arguments to update or create a Boss.
     * @example
     * // Update or create a Boss
     * const boss = await prisma.boss.upsert({
     *   create: {
     *     // ... data to create a Boss
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Boss we want to update
     *   }
     * })
     */
    upsert<T extends BossUpsertArgs>(args: SelectSubset<T, BossUpsertArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossCountArgs} args - Arguments to filter Bosses to count.
     * @example
     * // Count the number of Bosses
     * const count = await prisma.boss.count({
     *   where: {
     *     // ... the filter for the Bosses we want to count
     *   }
     * })
    **/
    count<T extends BossCountArgs>(
      args?: Subset<T, BossCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BossCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Boss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BossAggregateArgs>(args: Subset<T, BossAggregateArgs>): Prisma.PrismaPromise<GetBossAggregateType<T>>

    /**
     * Group by Boss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BossGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BossGroupByArgs['orderBy'] }
        : { orderBy?: BossGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BossGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBossGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Boss model
   */
  readonly fields: BossFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Boss.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BossClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    raidBosses<T extends Boss$raidBossesArgs<ExtArgs> = {}>(args?: Subset<T, Boss$raidBossesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Boss model
   */
  interface BossFieldRefs {
    readonly id: FieldRef<"Boss", 'Int'>
    readonly boss_name: FieldRef<"Boss", 'String'>
    readonly dkp_points: FieldRef<"Boss", 'Int'>
    readonly category: FieldRef<"Boss", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Boss findUnique
   */
  export type BossFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * Filter, which Boss to fetch.
     */
    where: BossWhereUniqueInput
  }

  /**
   * Boss findUniqueOrThrow
   */
  export type BossFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * Filter, which Boss to fetch.
     */
    where: BossWhereUniqueInput
  }

  /**
   * Boss findFirst
   */
  export type BossFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * Filter, which Boss to fetch.
     */
    where?: BossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bosses to fetch.
     */
    orderBy?: BossOrderByWithRelationInput | BossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bosses.
     */
    cursor?: BossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bosses.
     */
    distinct?: BossScalarFieldEnum | BossScalarFieldEnum[]
  }

  /**
   * Boss findFirstOrThrow
   */
  export type BossFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * Filter, which Boss to fetch.
     */
    where?: BossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bosses to fetch.
     */
    orderBy?: BossOrderByWithRelationInput | BossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bosses.
     */
    cursor?: BossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bosses.
     */
    distinct?: BossScalarFieldEnum | BossScalarFieldEnum[]
  }

  /**
   * Boss findMany
   */
  export type BossFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * Filter, which Bosses to fetch.
     */
    where?: BossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bosses to fetch.
     */
    orderBy?: BossOrderByWithRelationInput | BossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bosses.
     */
    cursor?: BossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bosses.
     */
    skip?: number
    distinct?: BossScalarFieldEnum | BossScalarFieldEnum[]
  }

  /**
   * Boss create
   */
  export type BossCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * The data needed to create a Boss.
     */
    data: XOR<BossCreateInput, BossUncheckedCreateInput>
  }

  /**
   * Boss createMany
   */
  export type BossCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bosses.
     */
    data: BossCreateManyInput | BossCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Boss createManyAndReturn
   */
  export type BossCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * The data used to create many Bosses.
     */
    data: BossCreateManyInput | BossCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Boss update
   */
  export type BossUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * The data needed to update a Boss.
     */
    data: XOR<BossUpdateInput, BossUncheckedUpdateInput>
    /**
     * Choose, which Boss to update.
     */
    where: BossWhereUniqueInput
  }

  /**
   * Boss updateMany
   */
  export type BossUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bosses.
     */
    data: XOR<BossUpdateManyMutationInput, BossUncheckedUpdateManyInput>
    /**
     * Filter which Bosses to update
     */
    where?: BossWhereInput
    /**
     * Limit how many Bosses to update.
     */
    limit?: number
  }

  /**
   * Boss updateManyAndReturn
   */
  export type BossUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * The data used to update Bosses.
     */
    data: XOR<BossUpdateManyMutationInput, BossUncheckedUpdateManyInput>
    /**
     * Filter which Bosses to update
     */
    where?: BossWhereInput
    /**
     * Limit how many Bosses to update.
     */
    limit?: number
  }

  /**
   * Boss upsert
   */
  export type BossUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * The filter to search for the Boss to update in case it exists.
     */
    where: BossWhereUniqueInput
    /**
     * In case the Boss found by the `where` argument doesn't exist, create a new Boss with this data.
     */
    create: XOR<BossCreateInput, BossUncheckedCreateInput>
    /**
     * In case the Boss was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BossUpdateInput, BossUncheckedUpdateInput>
  }

  /**
   * Boss delete
   */
  export type BossDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * Filter which Boss to delete.
     */
    where: BossWhereUniqueInput
  }

  /**
   * Boss deleteMany
   */
  export type BossDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bosses to delete
     */
    where?: BossWhereInput
    /**
     * Limit how many Bosses to delete.
     */
    limit?: number
  }

  /**
   * Boss.raidBosses
   */
  export type Boss$raidBossesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    where?: RaidBossWhereInput
    orderBy?: RaidBossOrderByWithRelationInput | RaidBossOrderByWithRelationInput[]
    cursor?: RaidBossWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaidBossScalarFieldEnum | RaidBossScalarFieldEnum[]
  }

  /**
   * Boss without action
   */
  export type BossDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
  }


  /**
   * Model RaidBoss
   */

  export type AggregateRaidBoss = {
    _count: RaidBossCountAggregateOutputType | null
    _avg: RaidBossAvgAggregateOutputType | null
    _sum: RaidBossSumAggregateOutputType | null
    _min: RaidBossMinAggregateOutputType | null
    _max: RaidBossMaxAggregateOutputType | null
  }

  export type RaidBossAvgAggregateOutputType = {
    raid_id: number | null
    boss_id: number | null
  }

  export type RaidBossSumAggregateOutputType = {
    raid_id: number | null
    boss_id: number | null
  }

  export type RaidBossMinAggregateOutputType = {
    raid_id: number | null
    boss_id: number | null
  }

  export type RaidBossMaxAggregateOutputType = {
    raid_id: number | null
    boss_id: number | null
  }

  export type RaidBossCountAggregateOutputType = {
    raid_id: number
    boss_id: number
    _all: number
  }


  export type RaidBossAvgAggregateInputType = {
    raid_id?: true
    boss_id?: true
  }

  export type RaidBossSumAggregateInputType = {
    raid_id?: true
    boss_id?: true
  }

  export type RaidBossMinAggregateInputType = {
    raid_id?: true
    boss_id?: true
  }

  export type RaidBossMaxAggregateInputType = {
    raid_id?: true
    boss_id?: true
  }

  export type RaidBossCountAggregateInputType = {
    raid_id?: true
    boss_id?: true
    _all?: true
  }

  export type RaidBossAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaidBoss to aggregate.
     */
    where?: RaidBossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidBosses to fetch.
     */
    orderBy?: RaidBossOrderByWithRelationInput | RaidBossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaidBossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidBosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidBosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaidBosses
    **/
    _count?: true | RaidBossCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaidBossAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaidBossSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaidBossMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaidBossMaxAggregateInputType
  }

  export type GetRaidBossAggregateType<T extends RaidBossAggregateArgs> = {
        [P in keyof T & keyof AggregateRaidBoss]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaidBoss[P]>
      : GetScalarType<T[P], AggregateRaidBoss[P]>
  }




  export type RaidBossGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidBossWhereInput
    orderBy?: RaidBossOrderByWithAggregationInput | RaidBossOrderByWithAggregationInput[]
    by: RaidBossScalarFieldEnum[] | RaidBossScalarFieldEnum
    having?: RaidBossScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaidBossCountAggregateInputType | true
    _avg?: RaidBossAvgAggregateInputType
    _sum?: RaidBossSumAggregateInputType
    _min?: RaidBossMinAggregateInputType
    _max?: RaidBossMaxAggregateInputType
  }

  export type RaidBossGroupByOutputType = {
    raid_id: number
    boss_id: number
    _count: RaidBossCountAggregateOutputType | null
    _avg: RaidBossAvgAggregateOutputType | null
    _sum: RaidBossSumAggregateOutputType | null
    _min: RaidBossMinAggregateOutputType | null
    _max: RaidBossMaxAggregateOutputType | null
  }

  type GetRaidBossGroupByPayload<T extends RaidBossGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaidBossGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaidBossGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaidBossGroupByOutputType[P]>
            : GetScalarType<T[P], RaidBossGroupByOutputType[P]>
        }
      >
    >


  export type RaidBossSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raid_id?: boolean
    boss_id?: boolean
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    boss?: boolean | BossDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raidBoss"]>

  export type RaidBossSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raid_id?: boolean
    boss_id?: boolean
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    boss?: boolean | BossDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raidBoss"]>

  export type RaidBossSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raid_id?: boolean
    boss_id?: boolean
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    boss?: boolean | BossDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raidBoss"]>

  export type RaidBossSelectScalar = {
    raid_id?: boolean
    boss_id?: boolean
  }

  export type RaidBossOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"raid_id" | "boss_id", ExtArgs["result"]["raidBoss"]>
  export type RaidBossInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    boss?: boolean | BossDefaultArgs<ExtArgs>
  }
  export type RaidBossIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    boss?: boolean | BossDefaultArgs<ExtArgs>
  }
  export type RaidBossIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    boss?: boolean | BossDefaultArgs<ExtArgs>
  }

  export type $RaidBossPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaidBoss"
    objects: {
      raid: Prisma.$RaidPayload<ExtArgs>
      boss: Prisma.$BossPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      raid_id: number
      boss_id: number
    }, ExtArgs["result"]["raidBoss"]>
    composites: {}
  }

  type RaidBossGetPayload<S extends boolean | null | undefined | RaidBossDefaultArgs> = $Result.GetResult<Prisma.$RaidBossPayload, S>

  type RaidBossCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaidBossFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaidBossCountAggregateInputType | true
    }

  export interface RaidBossDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaidBoss'], meta: { name: 'RaidBoss' } }
    /**
     * Find zero or one RaidBoss that matches the filter.
     * @param {RaidBossFindUniqueArgs} args - Arguments to find a RaidBoss
     * @example
     * // Get one RaidBoss
     * const raidBoss = await prisma.raidBoss.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaidBossFindUniqueArgs>(args: SelectSubset<T, RaidBossFindUniqueArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaidBoss that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaidBossFindUniqueOrThrowArgs} args - Arguments to find a RaidBoss
     * @example
     * // Get one RaidBoss
     * const raidBoss = await prisma.raidBoss.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaidBossFindUniqueOrThrowArgs>(args: SelectSubset<T, RaidBossFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaidBoss that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossFindFirstArgs} args - Arguments to find a RaidBoss
     * @example
     * // Get one RaidBoss
     * const raidBoss = await prisma.raidBoss.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaidBossFindFirstArgs>(args?: SelectSubset<T, RaidBossFindFirstArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaidBoss that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossFindFirstOrThrowArgs} args - Arguments to find a RaidBoss
     * @example
     * // Get one RaidBoss
     * const raidBoss = await prisma.raidBoss.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaidBossFindFirstOrThrowArgs>(args?: SelectSubset<T, RaidBossFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaidBosses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaidBosses
     * const raidBosses = await prisma.raidBoss.findMany()
     * 
     * // Get first 10 RaidBosses
     * const raidBosses = await prisma.raidBoss.findMany({ take: 10 })
     * 
     * // Only select the `raid_id`
     * const raidBossWithRaid_idOnly = await prisma.raidBoss.findMany({ select: { raid_id: true } })
     * 
     */
    findMany<T extends RaidBossFindManyArgs>(args?: SelectSubset<T, RaidBossFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaidBoss.
     * @param {RaidBossCreateArgs} args - Arguments to create a RaidBoss.
     * @example
     * // Create one RaidBoss
     * const RaidBoss = await prisma.raidBoss.create({
     *   data: {
     *     // ... data to create a RaidBoss
     *   }
     * })
     * 
     */
    create<T extends RaidBossCreateArgs>(args: SelectSubset<T, RaidBossCreateArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaidBosses.
     * @param {RaidBossCreateManyArgs} args - Arguments to create many RaidBosses.
     * @example
     * // Create many RaidBosses
     * const raidBoss = await prisma.raidBoss.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaidBossCreateManyArgs>(args?: SelectSubset<T, RaidBossCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RaidBosses and returns the data saved in the database.
     * @param {RaidBossCreateManyAndReturnArgs} args - Arguments to create many RaidBosses.
     * @example
     * // Create many RaidBosses
     * const raidBoss = await prisma.raidBoss.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RaidBosses and only return the `raid_id`
     * const raidBossWithRaid_idOnly = await prisma.raidBoss.createManyAndReturn({
     *   select: { raid_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaidBossCreateManyAndReturnArgs>(args?: SelectSubset<T, RaidBossCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RaidBoss.
     * @param {RaidBossDeleteArgs} args - Arguments to delete one RaidBoss.
     * @example
     * // Delete one RaidBoss
     * const RaidBoss = await prisma.raidBoss.delete({
     *   where: {
     *     // ... filter to delete one RaidBoss
     *   }
     * })
     * 
     */
    delete<T extends RaidBossDeleteArgs>(args: SelectSubset<T, RaidBossDeleteArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaidBoss.
     * @param {RaidBossUpdateArgs} args - Arguments to update one RaidBoss.
     * @example
     * // Update one RaidBoss
     * const raidBoss = await prisma.raidBoss.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaidBossUpdateArgs>(args: SelectSubset<T, RaidBossUpdateArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaidBosses.
     * @param {RaidBossDeleteManyArgs} args - Arguments to filter RaidBosses to delete.
     * @example
     * // Delete a few RaidBosses
     * const { count } = await prisma.raidBoss.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaidBossDeleteManyArgs>(args?: SelectSubset<T, RaidBossDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaidBosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaidBosses
     * const raidBoss = await prisma.raidBoss.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaidBossUpdateManyArgs>(args: SelectSubset<T, RaidBossUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaidBosses and returns the data updated in the database.
     * @param {RaidBossUpdateManyAndReturnArgs} args - Arguments to update many RaidBosses.
     * @example
     * // Update many RaidBosses
     * const raidBoss = await prisma.raidBoss.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RaidBosses and only return the `raid_id`
     * const raidBossWithRaid_idOnly = await prisma.raidBoss.updateManyAndReturn({
     *   select: { raid_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaidBossUpdateManyAndReturnArgs>(args: SelectSubset<T, RaidBossUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RaidBoss.
     * @param {RaidBossUpsertArgs} args - Arguments to update or create a RaidBoss.
     * @example
     * // Update or create a RaidBoss
     * const raidBoss = await prisma.raidBoss.upsert({
     *   create: {
     *     // ... data to create a RaidBoss
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaidBoss we want to update
     *   }
     * })
     */
    upsert<T extends RaidBossUpsertArgs>(args: SelectSubset<T, RaidBossUpsertArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaidBosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossCountArgs} args - Arguments to filter RaidBosses to count.
     * @example
     * // Count the number of RaidBosses
     * const count = await prisma.raidBoss.count({
     *   where: {
     *     // ... the filter for the RaidBosses we want to count
     *   }
     * })
    **/
    count<T extends RaidBossCountArgs>(
      args?: Subset<T, RaidBossCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaidBossCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaidBoss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaidBossAggregateArgs>(args: Subset<T, RaidBossAggregateArgs>): Prisma.PrismaPromise<GetRaidBossAggregateType<T>>

    /**
     * Group by RaidBoss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaidBossGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaidBossGroupByArgs['orderBy'] }
        : { orderBy?: RaidBossGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaidBossGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaidBossGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaidBoss model
   */
  readonly fields: RaidBossFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaidBoss.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaidBossClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    raid<T extends RaidDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaidDefaultArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    boss<T extends BossDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BossDefaultArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaidBoss model
   */
  interface RaidBossFieldRefs {
    readonly raid_id: FieldRef<"RaidBoss", 'Int'>
    readonly boss_id: FieldRef<"RaidBoss", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RaidBoss findUnique
   */
  export type RaidBossFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * Filter, which RaidBoss to fetch.
     */
    where: RaidBossWhereUniqueInput
  }

  /**
   * RaidBoss findUniqueOrThrow
   */
  export type RaidBossFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * Filter, which RaidBoss to fetch.
     */
    where: RaidBossWhereUniqueInput
  }

  /**
   * RaidBoss findFirst
   */
  export type RaidBossFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * Filter, which RaidBoss to fetch.
     */
    where?: RaidBossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidBosses to fetch.
     */
    orderBy?: RaidBossOrderByWithRelationInput | RaidBossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaidBosses.
     */
    cursor?: RaidBossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidBosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidBosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaidBosses.
     */
    distinct?: RaidBossScalarFieldEnum | RaidBossScalarFieldEnum[]
  }

  /**
   * RaidBoss findFirstOrThrow
   */
  export type RaidBossFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * Filter, which RaidBoss to fetch.
     */
    where?: RaidBossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidBosses to fetch.
     */
    orderBy?: RaidBossOrderByWithRelationInput | RaidBossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaidBosses.
     */
    cursor?: RaidBossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidBosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidBosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaidBosses.
     */
    distinct?: RaidBossScalarFieldEnum | RaidBossScalarFieldEnum[]
  }

  /**
   * RaidBoss findMany
   */
  export type RaidBossFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * Filter, which RaidBosses to fetch.
     */
    where?: RaidBossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidBosses to fetch.
     */
    orderBy?: RaidBossOrderByWithRelationInput | RaidBossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaidBosses.
     */
    cursor?: RaidBossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidBosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidBosses.
     */
    skip?: number
    distinct?: RaidBossScalarFieldEnum | RaidBossScalarFieldEnum[]
  }

  /**
   * RaidBoss create
   */
  export type RaidBossCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * The data needed to create a RaidBoss.
     */
    data: XOR<RaidBossCreateInput, RaidBossUncheckedCreateInput>
  }

  /**
   * RaidBoss createMany
   */
  export type RaidBossCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaidBosses.
     */
    data: RaidBossCreateManyInput | RaidBossCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaidBoss createManyAndReturn
   */
  export type RaidBossCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * The data used to create many RaidBosses.
     */
    data: RaidBossCreateManyInput | RaidBossCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaidBoss update
   */
  export type RaidBossUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * The data needed to update a RaidBoss.
     */
    data: XOR<RaidBossUpdateInput, RaidBossUncheckedUpdateInput>
    /**
     * Choose, which RaidBoss to update.
     */
    where: RaidBossWhereUniqueInput
  }

  /**
   * RaidBoss updateMany
   */
  export type RaidBossUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaidBosses.
     */
    data: XOR<RaidBossUpdateManyMutationInput, RaidBossUncheckedUpdateManyInput>
    /**
     * Filter which RaidBosses to update
     */
    where?: RaidBossWhereInput
    /**
     * Limit how many RaidBosses to update.
     */
    limit?: number
  }

  /**
   * RaidBoss updateManyAndReturn
   */
  export type RaidBossUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * The data used to update RaidBosses.
     */
    data: XOR<RaidBossUpdateManyMutationInput, RaidBossUncheckedUpdateManyInput>
    /**
     * Filter which RaidBosses to update
     */
    where?: RaidBossWhereInput
    /**
     * Limit how many RaidBosses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaidBoss upsert
   */
  export type RaidBossUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * The filter to search for the RaidBoss to update in case it exists.
     */
    where: RaidBossWhereUniqueInput
    /**
     * In case the RaidBoss found by the `where` argument doesn't exist, create a new RaidBoss with this data.
     */
    create: XOR<RaidBossCreateInput, RaidBossUncheckedCreateInput>
    /**
     * In case the RaidBoss was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaidBossUpdateInput, RaidBossUncheckedUpdateInput>
  }

  /**
   * RaidBoss delete
   */
  export type RaidBossDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * Filter which RaidBoss to delete.
     */
    where: RaidBossWhereUniqueInput
  }

  /**
   * RaidBoss deleteMany
   */
  export type RaidBossDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaidBosses to delete
     */
    where?: RaidBossWhereInput
    /**
     * Limit how many RaidBosses to delete.
     */
    limit?: number
  }

  /**
   * RaidBoss without action
   */
  export type RaidBossDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
  }


  /**
   * Model RaidAttendance
   */

  export type AggregateRaidAttendance = {
    _count: RaidAttendanceCountAggregateOutputType | null
    _avg: RaidAttendanceAvgAggregateOutputType | null
    _sum: RaidAttendanceSumAggregateOutputType | null
    _min: RaidAttendanceMinAggregateOutputType | null
    _max: RaidAttendanceMaxAggregateOutputType | null
  }

  export type RaidAttendanceAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    raid_id: number | null
  }

  export type RaidAttendanceSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    raid_id: number | null
  }

  export type RaidAttendanceMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    raid_id: number | null
    created_at: Date | null
  }

  export type RaidAttendanceMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    raid_id: number | null
    created_at: Date | null
  }

  export type RaidAttendanceCountAggregateOutputType = {
    id: number
    user_id: number
    raid_id: number
    created_at: number
    _all: number
  }


  export type RaidAttendanceAvgAggregateInputType = {
    id?: true
    user_id?: true
    raid_id?: true
  }

  export type RaidAttendanceSumAggregateInputType = {
    id?: true
    user_id?: true
    raid_id?: true
  }

  export type RaidAttendanceMinAggregateInputType = {
    id?: true
    user_id?: true
    raid_id?: true
    created_at?: true
  }

  export type RaidAttendanceMaxAggregateInputType = {
    id?: true
    user_id?: true
    raid_id?: true
    created_at?: true
  }

  export type RaidAttendanceCountAggregateInputType = {
    id?: true
    user_id?: true
    raid_id?: true
    created_at?: true
    _all?: true
  }

  export type RaidAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaidAttendance to aggregate.
     */
    where?: RaidAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidAttendances to fetch.
     */
    orderBy?: RaidAttendanceOrderByWithRelationInput | RaidAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaidAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaidAttendances
    **/
    _count?: true | RaidAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaidAttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaidAttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaidAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaidAttendanceMaxAggregateInputType
  }

  export type GetRaidAttendanceAggregateType<T extends RaidAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateRaidAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaidAttendance[P]>
      : GetScalarType<T[P], AggregateRaidAttendance[P]>
  }




  export type RaidAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidAttendanceWhereInput
    orderBy?: RaidAttendanceOrderByWithAggregationInput | RaidAttendanceOrderByWithAggregationInput[]
    by: RaidAttendanceScalarFieldEnum[] | RaidAttendanceScalarFieldEnum
    having?: RaidAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaidAttendanceCountAggregateInputType | true
    _avg?: RaidAttendanceAvgAggregateInputType
    _sum?: RaidAttendanceSumAggregateInputType
    _min?: RaidAttendanceMinAggregateInputType
    _max?: RaidAttendanceMaxAggregateInputType
  }

  export type RaidAttendanceGroupByOutputType = {
    id: number
    user_id: number
    raid_id: number
    created_at: Date
    _count: RaidAttendanceCountAggregateOutputType | null
    _avg: RaidAttendanceAvgAggregateOutputType | null
    _sum: RaidAttendanceSumAggregateOutputType | null
    _min: RaidAttendanceMinAggregateOutputType | null
    _max: RaidAttendanceMaxAggregateOutputType | null
  }

  type GetRaidAttendanceGroupByPayload<T extends RaidAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaidAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaidAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaidAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], RaidAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type RaidAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    raid_id?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    raid?: boolean | RaidDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raidAttendance"]>

  export type RaidAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    raid_id?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    raid?: boolean | RaidDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raidAttendance"]>

  export type RaidAttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    raid_id?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    raid?: boolean | RaidDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raidAttendance"]>

  export type RaidAttendanceSelectScalar = {
    id?: boolean
    user_id?: boolean
    raid_id?: boolean
    created_at?: boolean
  }

  export type RaidAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "raid_id" | "created_at", ExtArgs["result"]["raidAttendance"]>
  export type RaidAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    raid?: boolean | RaidDefaultArgs<ExtArgs>
  }
  export type RaidAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    raid?: boolean | RaidDefaultArgs<ExtArgs>
  }
  export type RaidAttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    raid?: boolean | RaidDefaultArgs<ExtArgs>
  }

  export type $RaidAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaidAttendance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      raid: Prisma.$RaidPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      raid_id: number
      created_at: Date
    }, ExtArgs["result"]["raidAttendance"]>
    composites: {}
  }

  type RaidAttendanceGetPayload<S extends boolean | null | undefined | RaidAttendanceDefaultArgs> = $Result.GetResult<Prisma.$RaidAttendancePayload, S>

  type RaidAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaidAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaidAttendanceCountAggregateInputType | true
    }

  export interface RaidAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaidAttendance'], meta: { name: 'RaidAttendance' } }
    /**
     * Find zero or one RaidAttendance that matches the filter.
     * @param {RaidAttendanceFindUniqueArgs} args - Arguments to find a RaidAttendance
     * @example
     * // Get one RaidAttendance
     * const raidAttendance = await prisma.raidAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaidAttendanceFindUniqueArgs>(args: SelectSubset<T, RaidAttendanceFindUniqueArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaidAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaidAttendanceFindUniqueOrThrowArgs} args - Arguments to find a RaidAttendance
     * @example
     * // Get one RaidAttendance
     * const raidAttendance = await prisma.raidAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaidAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, RaidAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaidAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceFindFirstArgs} args - Arguments to find a RaidAttendance
     * @example
     * // Get one RaidAttendance
     * const raidAttendance = await prisma.raidAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaidAttendanceFindFirstArgs>(args?: SelectSubset<T, RaidAttendanceFindFirstArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaidAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceFindFirstOrThrowArgs} args - Arguments to find a RaidAttendance
     * @example
     * // Get one RaidAttendance
     * const raidAttendance = await prisma.raidAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaidAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, RaidAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaidAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaidAttendances
     * const raidAttendances = await prisma.raidAttendance.findMany()
     * 
     * // Get first 10 RaidAttendances
     * const raidAttendances = await prisma.raidAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raidAttendanceWithIdOnly = await prisma.raidAttendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaidAttendanceFindManyArgs>(args?: SelectSubset<T, RaidAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaidAttendance.
     * @param {RaidAttendanceCreateArgs} args - Arguments to create a RaidAttendance.
     * @example
     * // Create one RaidAttendance
     * const RaidAttendance = await prisma.raidAttendance.create({
     *   data: {
     *     // ... data to create a RaidAttendance
     *   }
     * })
     * 
     */
    create<T extends RaidAttendanceCreateArgs>(args: SelectSubset<T, RaidAttendanceCreateArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaidAttendances.
     * @param {RaidAttendanceCreateManyArgs} args - Arguments to create many RaidAttendances.
     * @example
     * // Create many RaidAttendances
     * const raidAttendance = await prisma.raidAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaidAttendanceCreateManyArgs>(args?: SelectSubset<T, RaidAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RaidAttendances and returns the data saved in the database.
     * @param {RaidAttendanceCreateManyAndReturnArgs} args - Arguments to create many RaidAttendances.
     * @example
     * // Create many RaidAttendances
     * const raidAttendance = await prisma.raidAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RaidAttendances and only return the `id`
     * const raidAttendanceWithIdOnly = await prisma.raidAttendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaidAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, RaidAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RaidAttendance.
     * @param {RaidAttendanceDeleteArgs} args - Arguments to delete one RaidAttendance.
     * @example
     * // Delete one RaidAttendance
     * const RaidAttendance = await prisma.raidAttendance.delete({
     *   where: {
     *     // ... filter to delete one RaidAttendance
     *   }
     * })
     * 
     */
    delete<T extends RaidAttendanceDeleteArgs>(args: SelectSubset<T, RaidAttendanceDeleteArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaidAttendance.
     * @param {RaidAttendanceUpdateArgs} args - Arguments to update one RaidAttendance.
     * @example
     * // Update one RaidAttendance
     * const raidAttendance = await prisma.raidAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaidAttendanceUpdateArgs>(args: SelectSubset<T, RaidAttendanceUpdateArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaidAttendances.
     * @param {RaidAttendanceDeleteManyArgs} args - Arguments to filter RaidAttendances to delete.
     * @example
     * // Delete a few RaidAttendances
     * const { count } = await prisma.raidAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaidAttendanceDeleteManyArgs>(args?: SelectSubset<T, RaidAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaidAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaidAttendances
     * const raidAttendance = await prisma.raidAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaidAttendanceUpdateManyArgs>(args: SelectSubset<T, RaidAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaidAttendances and returns the data updated in the database.
     * @param {RaidAttendanceUpdateManyAndReturnArgs} args - Arguments to update many RaidAttendances.
     * @example
     * // Update many RaidAttendances
     * const raidAttendance = await prisma.raidAttendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RaidAttendances and only return the `id`
     * const raidAttendanceWithIdOnly = await prisma.raidAttendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaidAttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, RaidAttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RaidAttendance.
     * @param {RaidAttendanceUpsertArgs} args - Arguments to update or create a RaidAttendance.
     * @example
     * // Update or create a RaidAttendance
     * const raidAttendance = await prisma.raidAttendance.upsert({
     *   create: {
     *     // ... data to create a RaidAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaidAttendance we want to update
     *   }
     * })
     */
    upsert<T extends RaidAttendanceUpsertArgs>(args: SelectSubset<T, RaidAttendanceUpsertArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaidAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceCountArgs} args - Arguments to filter RaidAttendances to count.
     * @example
     * // Count the number of RaidAttendances
     * const count = await prisma.raidAttendance.count({
     *   where: {
     *     // ... the filter for the RaidAttendances we want to count
     *   }
     * })
    **/
    count<T extends RaidAttendanceCountArgs>(
      args?: Subset<T, RaidAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaidAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaidAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaidAttendanceAggregateArgs>(args: Subset<T, RaidAttendanceAggregateArgs>): Prisma.PrismaPromise<GetRaidAttendanceAggregateType<T>>

    /**
     * Group by RaidAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaidAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaidAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: RaidAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaidAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaidAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaidAttendance model
   */
  readonly fields: RaidAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaidAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaidAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    raid<T extends RaidDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaidDefaultArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaidAttendance model
   */
  interface RaidAttendanceFieldRefs {
    readonly id: FieldRef<"RaidAttendance", 'Int'>
    readonly user_id: FieldRef<"RaidAttendance", 'Int'>
    readonly raid_id: FieldRef<"RaidAttendance", 'Int'>
    readonly created_at: FieldRef<"RaidAttendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RaidAttendance findUnique
   */
  export type RaidAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RaidAttendance to fetch.
     */
    where: RaidAttendanceWhereUniqueInput
  }

  /**
   * RaidAttendance findUniqueOrThrow
   */
  export type RaidAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RaidAttendance to fetch.
     */
    where: RaidAttendanceWhereUniqueInput
  }

  /**
   * RaidAttendance findFirst
   */
  export type RaidAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RaidAttendance to fetch.
     */
    where?: RaidAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidAttendances to fetch.
     */
    orderBy?: RaidAttendanceOrderByWithRelationInput | RaidAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaidAttendances.
     */
    cursor?: RaidAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaidAttendances.
     */
    distinct?: RaidAttendanceScalarFieldEnum | RaidAttendanceScalarFieldEnum[]
  }

  /**
   * RaidAttendance findFirstOrThrow
   */
  export type RaidAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RaidAttendance to fetch.
     */
    where?: RaidAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidAttendances to fetch.
     */
    orderBy?: RaidAttendanceOrderByWithRelationInput | RaidAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaidAttendances.
     */
    cursor?: RaidAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaidAttendances.
     */
    distinct?: RaidAttendanceScalarFieldEnum | RaidAttendanceScalarFieldEnum[]
  }

  /**
   * RaidAttendance findMany
   */
  export type RaidAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RaidAttendances to fetch.
     */
    where?: RaidAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidAttendances to fetch.
     */
    orderBy?: RaidAttendanceOrderByWithRelationInput | RaidAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaidAttendances.
     */
    cursor?: RaidAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidAttendances.
     */
    skip?: number
    distinct?: RaidAttendanceScalarFieldEnum | RaidAttendanceScalarFieldEnum[]
  }

  /**
   * RaidAttendance create
   */
  export type RaidAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a RaidAttendance.
     */
    data: XOR<RaidAttendanceCreateInput, RaidAttendanceUncheckedCreateInput>
  }

  /**
   * RaidAttendance createMany
   */
  export type RaidAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaidAttendances.
     */
    data: RaidAttendanceCreateManyInput | RaidAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaidAttendance createManyAndReturn
   */
  export type RaidAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many RaidAttendances.
     */
    data: RaidAttendanceCreateManyInput | RaidAttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaidAttendance update
   */
  export type RaidAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a RaidAttendance.
     */
    data: XOR<RaidAttendanceUpdateInput, RaidAttendanceUncheckedUpdateInput>
    /**
     * Choose, which RaidAttendance to update.
     */
    where: RaidAttendanceWhereUniqueInput
  }

  /**
   * RaidAttendance updateMany
   */
  export type RaidAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaidAttendances.
     */
    data: XOR<RaidAttendanceUpdateManyMutationInput, RaidAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which RaidAttendances to update
     */
    where?: RaidAttendanceWhereInput
    /**
     * Limit how many RaidAttendances to update.
     */
    limit?: number
  }

  /**
   * RaidAttendance updateManyAndReturn
   */
  export type RaidAttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * The data used to update RaidAttendances.
     */
    data: XOR<RaidAttendanceUpdateManyMutationInput, RaidAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which RaidAttendances to update
     */
    where?: RaidAttendanceWhereInput
    /**
     * Limit how many RaidAttendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaidAttendance upsert
   */
  export type RaidAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the RaidAttendance to update in case it exists.
     */
    where: RaidAttendanceWhereUniqueInput
    /**
     * In case the RaidAttendance found by the `where` argument doesn't exist, create a new RaidAttendance with this data.
     */
    create: XOR<RaidAttendanceCreateInput, RaidAttendanceUncheckedCreateInput>
    /**
     * In case the RaidAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaidAttendanceUpdateInput, RaidAttendanceUncheckedUpdateInput>
  }

  /**
   * RaidAttendance delete
   */
  export type RaidAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * Filter which RaidAttendance to delete.
     */
    where: RaidAttendanceWhereUniqueInput
  }

  /**
   * RaidAttendance deleteMany
   */
  export type RaidAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaidAttendances to delete
     */
    where?: RaidAttendanceWhereInput
    /**
     * Limit how many RaidAttendances to delete.
     */
    limit?: number
  }

  /**
   * RaidAttendance without action
   */
  export type RaidAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model ItemType
   */

  export type AggregateItemType = {
    _count: ItemTypeCountAggregateOutputType | null
    _avg: ItemTypeAvgAggregateOutputType | null
    _sum: ItemTypeSumAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  export type ItemTypeAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ItemTypeSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ItemTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
  }

  export type ItemTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
  }

  export type ItemTypeCountAggregateOutputType = {
    id: number
    name: number
    price: number
    _all: number
  }


  export type ItemTypeAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type ItemTypeSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type ItemTypeMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
  }

  export type ItemTypeMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
  }

  export type ItemTypeCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    _all?: true
  }

  export type ItemTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemType to aggregate.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemTypes
    **/
    _count?: true | ItemTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemTypeMaxAggregateInputType
  }

  export type GetItemTypeAggregateType<T extends ItemTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateItemType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemType[P]>
      : GetScalarType<T[P], AggregateItemType[P]>
  }




  export type ItemTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemTypeWhereInput
    orderBy?: ItemTypeOrderByWithAggregationInput | ItemTypeOrderByWithAggregationInput[]
    by: ItemTypeScalarFieldEnum[] | ItemTypeScalarFieldEnum
    having?: ItemTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemTypeCountAggregateInputType | true
    _avg?: ItemTypeAvgAggregateInputType
    _sum?: ItemTypeSumAggregateInputType
    _min?: ItemTypeMinAggregateInputType
    _max?: ItemTypeMaxAggregateInputType
  }

  export type ItemTypeGroupByOutputType = {
    id: number
    name: string
    price: number | null
    _count: ItemTypeCountAggregateOutputType | null
    _avg: ItemTypeAvgAggregateOutputType | null
    _sum: ItemTypeSumAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  type GetItemTypeGroupByPayload<T extends ItemTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
        }
      >
    >


  export type ItemTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    loot?: boolean | ItemType$lootArgs<ExtArgs>
    lootQueue?: boolean | ItemType$lootQueueArgs<ExtArgs>
    _count?: boolean | ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemType"]>

  export type ItemTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
  }, ExtArgs["result"]["itemType"]>

  export type ItemTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
  }, ExtArgs["result"]["itemType"]>

  export type ItemTypeSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
  }

  export type ItemTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price", ExtArgs["result"]["itemType"]>
  export type ItemTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loot?: boolean | ItemType$lootArgs<ExtArgs>
    lootQueue?: boolean | ItemType$lootQueueArgs<ExtArgs>
    _count?: boolean | ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemType"
    objects: {
      loot: Prisma.$LootPayload<ExtArgs>[]
      lootQueue: Prisma.$LootQueuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      price: number | null
    }, ExtArgs["result"]["itemType"]>
    composites: {}
  }

  type ItemTypeGetPayload<S extends boolean | null | undefined | ItemTypeDefaultArgs> = $Result.GetResult<Prisma.$ItemTypePayload, S>

  type ItemTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemTypeCountAggregateInputType | true
    }

  export interface ItemTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemType'], meta: { name: 'ItemType' } }
    /**
     * Find zero or one ItemType that matches the filter.
     * @param {ItemTypeFindUniqueArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemTypeFindUniqueArgs>(args: SelectSubset<T, ItemTypeFindUniqueArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemTypeFindUniqueOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemTypeFindFirstArgs>(args?: SelectSubset<T, ItemTypeFindFirstArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemTypes
     * const itemTypes = await prisma.itemType.findMany()
     * 
     * // Get first 10 ItemTypes
     * const itemTypes = await prisma.itemType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemTypeWithIdOnly = await prisma.itemType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemTypeFindManyArgs>(args?: SelectSubset<T, ItemTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemType.
     * @param {ItemTypeCreateArgs} args - Arguments to create a ItemType.
     * @example
     * // Create one ItemType
     * const ItemType = await prisma.itemType.create({
     *   data: {
     *     // ... data to create a ItemType
     *   }
     * })
     * 
     */
    create<T extends ItemTypeCreateArgs>(args: SelectSubset<T, ItemTypeCreateArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemTypes.
     * @param {ItemTypeCreateManyArgs} args - Arguments to create many ItemTypes.
     * @example
     * // Create many ItemTypes
     * const itemType = await prisma.itemType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemTypeCreateManyArgs>(args?: SelectSubset<T, ItemTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemTypes and returns the data saved in the database.
     * @param {ItemTypeCreateManyAndReturnArgs} args - Arguments to create many ItemTypes.
     * @example
     * // Create many ItemTypes
     * const itemType = await prisma.itemType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemTypes and only return the `id`
     * const itemTypeWithIdOnly = await prisma.itemType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemType.
     * @param {ItemTypeDeleteArgs} args - Arguments to delete one ItemType.
     * @example
     * // Delete one ItemType
     * const ItemType = await prisma.itemType.delete({
     *   where: {
     *     // ... filter to delete one ItemType
     *   }
     * })
     * 
     */
    delete<T extends ItemTypeDeleteArgs>(args: SelectSubset<T, ItemTypeDeleteArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemType.
     * @param {ItemTypeUpdateArgs} args - Arguments to update one ItemType.
     * @example
     * // Update one ItemType
     * const itemType = await prisma.itemType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemTypeUpdateArgs>(args: SelectSubset<T, ItemTypeUpdateArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemTypes.
     * @param {ItemTypeDeleteManyArgs} args - Arguments to filter ItemTypes to delete.
     * @example
     * // Delete a few ItemTypes
     * const { count } = await prisma.itemType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemTypeDeleteManyArgs>(args?: SelectSubset<T, ItemTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemTypes
     * const itemType = await prisma.itemType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemTypeUpdateManyArgs>(args: SelectSubset<T, ItemTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTypes and returns the data updated in the database.
     * @param {ItemTypeUpdateManyAndReturnArgs} args - Arguments to update many ItemTypes.
     * @example
     * // Update many ItemTypes
     * const itemType = await prisma.itemType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemTypes and only return the `id`
     * const itemTypeWithIdOnly = await prisma.itemType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemType.
     * @param {ItemTypeUpsertArgs} args - Arguments to update or create a ItemType.
     * @example
     * // Update or create a ItemType
     * const itemType = await prisma.itemType.upsert({
     *   create: {
     *     // ... data to create a ItemType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemType we want to update
     *   }
     * })
     */
    upsert<T extends ItemTypeUpsertArgs>(args: SelectSubset<T, ItemTypeUpsertArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeCountArgs} args - Arguments to filter ItemTypes to count.
     * @example
     * // Count the number of ItemTypes
     * const count = await prisma.itemType.count({
     *   where: {
     *     // ... the filter for the ItemTypes we want to count
     *   }
     * })
    **/
    count<T extends ItemTypeCountArgs>(
      args?: Subset<T, ItemTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemTypeAggregateArgs>(args: Subset<T, ItemTypeAggregateArgs>): Prisma.PrismaPromise<GetItemTypeAggregateType<T>>

    /**
     * Group by ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemTypeGroupByArgs['orderBy'] }
        : { orderBy?: ItemTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemType model
   */
  readonly fields: ItemTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loot<T extends ItemType$lootArgs<ExtArgs> = {}>(args?: Subset<T, ItemType$lootArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lootQueue<T extends ItemType$lootQueueArgs<ExtArgs> = {}>(args?: Subset<T, ItemType$lootQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemType model
   */
  interface ItemTypeFieldRefs {
    readonly id: FieldRef<"ItemType", 'Int'>
    readonly name: FieldRef<"ItemType", 'String'>
    readonly price: FieldRef<"ItemType", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ItemType findUnique
   */
  export type ItemTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType findUniqueOrThrow
   */
  export type ItemTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType findFirst
   */
  export type ItemTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     */
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }

  /**
   * ItemType findFirstOrThrow
   */
  export type ItemTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     */
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }

  /**
   * ItemType findMany
   */
  export type ItemTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemTypes to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }

  /**
   * ItemType create
   */
  export type ItemTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemType.
     */
    data: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
  }

  /**
   * ItemType createMany
   */
  export type ItemTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemTypes.
     */
    data: ItemTypeCreateManyInput | ItemTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemType createManyAndReturn
   */
  export type ItemTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ItemTypes.
     */
    data: ItemTypeCreateManyInput | ItemTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemType update
   */
  export type ItemTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemType.
     */
    data: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
    /**
     * Choose, which ItemType to update.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType updateMany
   */
  export type ItemTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemTypes.
     */
    data: XOR<ItemTypeUpdateManyMutationInput, ItemTypeUncheckedUpdateManyInput>
    /**
     * Filter which ItemTypes to update
     */
    where?: ItemTypeWhereInput
    /**
     * Limit how many ItemTypes to update.
     */
    limit?: number
  }

  /**
   * ItemType updateManyAndReturn
   */
  export type ItemTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * The data used to update ItemTypes.
     */
    data: XOR<ItemTypeUpdateManyMutationInput, ItemTypeUncheckedUpdateManyInput>
    /**
     * Filter which ItemTypes to update
     */
    where?: ItemTypeWhereInput
    /**
     * Limit how many ItemTypes to update.
     */
    limit?: number
  }

  /**
   * ItemType upsert
   */
  export type ItemTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemType to update in case it exists.
     */
    where: ItemTypeWhereUniqueInput
    /**
     * In case the ItemType found by the `where` argument doesn't exist, create a new ItemType with this data.
     */
    create: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
    /**
     * In case the ItemType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
  }

  /**
   * ItemType delete
   */
  export type ItemTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter which ItemType to delete.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType deleteMany
   */
  export type ItemTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemTypes to delete
     */
    where?: ItemTypeWhereInput
    /**
     * Limit how many ItemTypes to delete.
     */
    limit?: number
  }

  /**
   * ItemType.loot
   */
  export type ItemType$lootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    where?: LootWhereInput
    orderBy?: LootOrderByWithRelationInput | LootOrderByWithRelationInput[]
    cursor?: LootWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LootScalarFieldEnum | LootScalarFieldEnum[]
  }

  /**
   * ItemType.lootQueue
   */
  export type ItemType$lootQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    where?: LootQueueWhereInput
    orderBy?: LootQueueOrderByWithRelationInput | LootQueueOrderByWithRelationInput[]
    cursor?: LootQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LootQueueScalarFieldEnum | LootQueueScalarFieldEnum[]
  }

  /**
   * ItemType without action
   */
  export type ItemTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
  }


  /**
   * Model Loot
   */

  export type AggregateLoot = {
    _count: LootCountAggregateOutputType | null
    _avg: LootAvgAggregateOutputType | null
    _sum: LootSumAggregateOutputType | null
    _min: LootMinAggregateOutputType | null
    _max: LootMaxAggregateOutputType | null
  }

  export type LootAvgAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    sold_to_user_id: number | null
  }

  export type LootSumAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    sold_to_user_id: number | null
  }

  export type LootMinAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    status: string | null
    acquired_at: Date | null
    sold_at: Date | null
    sold_to: string | null
    sold_to_user_id: number | null
    comment: string | null
    source: string | null
    created_at: Date | null
  }

  export type LootMaxAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    status: string | null
    acquired_at: Date | null
    sold_at: Date | null
    sold_to: string | null
    sold_to_user_id: number | null
    comment: string | null
    source: string | null
    created_at: Date | null
  }

  export type LootCountAggregateOutputType = {
    id: number
    itemTypeId: number
    status: number
    acquired_at: number
    sold_at: number
    sold_to: number
    sold_to_user_id: number
    comment: number
    source: number
    created_at: number
    _all: number
  }


  export type LootAvgAggregateInputType = {
    id?: true
    itemTypeId?: true
    sold_to_user_id?: true
  }

  export type LootSumAggregateInputType = {
    id?: true
    itemTypeId?: true
    sold_to_user_id?: true
  }

  export type LootMinAggregateInputType = {
    id?: true
    itemTypeId?: true
    status?: true
    acquired_at?: true
    sold_at?: true
    sold_to?: true
    sold_to_user_id?: true
    comment?: true
    source?: true
    created_at?: true
  }

  export type LootMaxAggregateInputType = {
    id?: true
    itemTypeId?: true
    status?: true
    acquired_at?: true
    sold_at?: true
    sold_to?: true
    sold_to_user_id?: true
    comment?: true
    source?: true
    created_at?: true
  }

  export type LootCountAggregateInputType = {
    id?: true
    itemTypeId?: true
    status?: true
    acquired_at?: true
    sold_at?: true
    sold_to?: true
    sold_to_user_id?: true
    comment?: true
    source?: true
    created_at?: true
    _all?: true
  }

  export type LootAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loot to aggregate.
     */
    where?: LootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loots to fetch.
     */
    orderBy?: LootOrderByWithRelationInput | LootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loots
    **/
    _count?: true | LootCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LootAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LootSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LootMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LootMaxAggregateInputType
  }

  export type GetLootAggregateType<T extends LootAggregateArgs> = {
        [P in keyof T & keyof AggregateLoot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoot[P]>
      : GetScalarType<T[P], AggregateLoot[P]>
  }




  export type LootGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LootWhereInput
    orderBy?: LootOrderByWithAggregationInput | LootOrderByWithAggregationInput[]
    by: LootScalarFieldEnum[] | LootScalarFieldEnum
    having?: LootScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LootCountAggregateInputType | true
    _avg?: LootAvgAggregateInputType
    _sum?: LootSumAggregateInputType
    _min?: LootMinAggregateInputType
    _max?: LootMaxAggregateInputType
  }

  export type LootGroupByOutputType = {
    id: number
    itemTypeId: number
    status: string
    acquired_at: Date
    sold_at: Date | null
    sold_to: string | null
    sold_to_user_id: number | null
    comment: string | null
    source: string | null
    created_at: Date
    _count: LootCountAggregateOutputType | null
    _avg: LootAvgAggregateOutputType | null
    _sum: LootSumAggregateOutputType | null
    _min: LootMinAggregateOutputType | null
    _max: LootMaxAggregateOutputType | null
  }

  type GetLootGroupByPayload<T extends LootGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LootGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LootGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LootGroupByOutputType[P]>
            : GetScalarType<T[P], LootGroupByOutputType[P]>
        }
      >
    >


  export type LootSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemTypeId?: boolean
    status?: boolean
    acquired_at?: boolean
    sold_at?: boolean
    sold_to?: boolean
    sold_to_user_id?: boolean
    comment?: boolean
    source?: boolean
    created_at?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    soldToUser?: boolean | Loot$soldToUserArgs<ExtArgs>
  }, ExtArgs["result"]["loot"]>

  export type LootSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemTypeId?: boolean
    status?: boolean
    acquired_at?: boolean
    sold_at?: boolean
    sold_to?: boolean
    sold_to_user_id?: boolean
    comment?: boolean
    source?: boolean
    created_at?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    soldToUser?: boolean | Loot$soldToUserArgs<ExtArgs>
  }, ExtArgs["result"]["loot"]>

  export type LootSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemTypeId?: boolean
    status?: boolean
    acquired_at?: boolean
    sold_at?: boolean
    sold_to?: boolean
    sold_to_user_id?: boolean
    comment?: boolean
    source?: boolean
    created_at?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    soldToUser?: boolean | Loot$soldToUserArgs<ExtArgs>
  }, ExtArgs["result"]["loot"]>

  export type LootSelectScalar = {
    id?: boolean
    itemTypeId?: boolean
    status?: boolean
    acquired_at?: boolean
    sold_at?: boolean
    sold_to?: boolean
    sold_to_user_id?: boolean
    comment?: boolean
    source?: boolean
    created_at?: boolean
  }

  export type LootOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemTypeId" | "status" | "acquired_at" | "sold_at" | "sold_to" | "sold_to_user_id" | "comment" | "source" | "created_at", ExtArgs["result"]["loot"]>
  export type LootInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    soldToUser?: boolean | Loot$soldToUserArgs<ExtArgs>
  }
  export type LootIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    soldToUser?: boolean | Loot$soldToUserArgs<ExtArgs>
  }
  export type LootIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    soldToUser?: boolean | Loot$soldToUserArgs<ExtArgs>
  }

  export type $LootPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Loot"
    objects: {
      itemType: Prisma.$ItemTypePayload<ExtArgs>
      soldToUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemTypeId: number
      status: string
      acquired_at: Date
      sold_at: Date | null
      sold_to: string | null
      sold_to_user_id: number | null
      comment: string | null
      source: string | null
      created_at: Date
    }, ExtArgs["result"]["loot"]>
    composites: {}
  }

  type LootGetPayload<S extends boolean | null | undefined | LootDefaultArgs> = $Result.GetResult<Prisma.$LootPayload, S>

  type LootCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LootFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LootCountAggregateInputType | true
    }

  export interface LootDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Loot'], meta: { name: 'Loot' } }
    /**
     * Find zero or one Loot that matches the filter.
     * @param {LootFindUniqueArgs} args - Arguments to find a Loot
     * @example
     * // Get one Loot
     * const loot = await prisma.loot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LootFindUniqueArgs>(args: SelectSubset<T, LootFindUniqueArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Loot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LootFindUniqueOrThrowArgs} args - Arguments to find a Loot
     * @example
     * // Get one Loot
     * const loot = await prisma.loot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LootFindUniqueOrThrowArgs>(args: SelectSubset<T, LootFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootFindFirstArgs} args - Arguments to find a Loot
     * @example
     * // Get one Loot
     * const loot = await prisma.loot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LootFindFirstArgs>(args?: SelectSubset<T, LootFindFirstArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootFindFirstOrThrowArgs} args - Arguments to find a Loot
     * @example
     * // Get one Loot
     * const loot = await prisma.loot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LootFindFirstOrThrowArgs>(args?: SelectSubset<T, LootFindFirstOrThrowArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Loots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loots
     * const loots = await prisma.loot.findMany()
     * 
     * // Get first 10 Loots
     * const loots = await prisma.loot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lootWithIdOnly = await prisma.loot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LootFindManyArgs>(args?: SelectSubset<T, LootFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Loot.
     * @param {LootCreateArgs} args - Arguments to create a Loot.
     * @example
     * // Create one Loot
     * const Loot = await prisma.loot.create({
     *   data: {
     *     // ... data to create a Loot
     *   }
     * })
     * 
     */
    create<T extends LootCreateArgs>(args: SelectSubset<T, LootCreateArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Loots.
     * @param {LootCreateManyArgs} args - Arguments to create many Loots.
     * @example
     * // Create many Loots
     * const loot = await prisma.loot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LootCreateManyArgs>(args?: SelectSubset<T, LootCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Loots and returns the data saved in the database.
     * @param {LootCreateManyAndReturnArgs} args - Arguments to create many Loots.
     * @example
     * // Create many Loots
     * const loot = await prisma.loot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Loots and only return the `id`
     * const lootWithIdOnly = await prisma.loot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LootCreateManyAndReturnArgs>(args?: SelectSubset<T, LootCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Loot.
     * @param {LootDeleteArgs} args - Arguments to delete one Loot.
     * @example
     * // Delete one Loot
     * const Loot = await prisma.loot.delete({
     *   where: {
     *     // ... filter to delete one Loot
     *   }
     * })
     * 
     */
    delete<T extends LootDeleteArgs>(args: SelectSubset<T, LootDeleteArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Loot.
     * @param {LootUpdateArgs} args - Arguments to update one Loot.
     * @example
     * // Update one Loot
     * const loot = await prisma.loot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LootUpdateArgs>(args: SelectSubset<T, LootUpdateArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Loots.
     * @param {LootDeleteManyArgs} args - Arguments to filter Loots to delete.
     * @example
     * // Delete a few Loots
     * const { count } = await prisma.loot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LootDeleteManyArgs>(args?: SelectSubset<T, LootDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loots
     * const loot = await prisma.loot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LootUpdateManyArgs>(args: SelectSubset<T, LootUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loots and returns the data updated in the database.
     * @param {LootUpdateManyAndReturnArgs} args - Arguments to update many Loots.
     * @example
     * // Update many Loots
     * const loot = await prisma.loot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Loots and only return the `id`
     * const lootWithIdOnly = await prisma.loot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LootUpdateManyAndReturnArgs>(args: SelectSubset<T, LootUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Loot.
     * @param {LootUpsertArgs} args - Arguments to update or create a Loot.
     * @example
     * // Update or create a Loot
     * const loot = await prisma.loot.upsert({
     *   create: {
     *     // ... data to create a Loot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loot we want to update
     *   }
     * })
     */
    upsert<T extends LootUpsertArgs>(args: SelectSubset<T, LootUpsertArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Loots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootCountArgs} args - Arguments to filter Loots to count.
     * @example
     * // Count the number of Loots
     * const count = await prisma.loot.count({
     *   where: {
     *     // ... the filter for the Loots we want to count
     *   }
     * })
    **/
    count<T extends LootCountArgs>(
      args?: Subset<T, LootCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LootCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LootAggregateArgs>(args: Subset<T, LootAggregateArgs>): Prisma.PrismaPromise<GetLootAggregateType<T>>

    /**
     * Group by Loot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LootGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LootGroupByArgs['orderBy'] }
        : { orderBy?: LootGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LootGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLootGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Loot model
   */
  readonly fields: LootFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Loot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LootClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemType<T extends ItemTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemTypeDefaultArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    soldToUser<T extends Loot$soldToUserArgs<ExtArgs> = {}>(args?: Subset<T, Loot$soldToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Loot model
   */
  interface LootFieldRefs {
    readonly id: FieldRef<"Loot", 'Int'>
    readonly itemTypeId: FieldRef<"Loot", 'Int'>
    readonly status: FieldRef<"Loot", 'String'>
    readonly acquired_at: FieldRef<"Loot", 'DateTime'>
    readonly sold_at: FieldRef<"Loot", 'DateTime'>
    readonly sold_to: FieldRef<"Loot", 'String'>
    readonly sold_to_user_id: FieldRef<"Loot", 'Int'>
    readonly comment: FieldRef<"Loot", 'String'>
    readonly source: FieldRef<"Loot", 'String'>
    readonly created_at: FieldRef<"Loot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Loot findUnique
   */
  export type LootFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * Filter, which Loot to fetch.
     */
    where: LootWhereUniqueInput
  }

  /**
   * Loot findUniqueOrThrow
   */
  export type LootFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * Filter, which Loot to fetch.
     */
    where: LootWhereUniqueInput
  }

  /**
   * Loot findFirst
   */
  export type LootFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * Filter, which Loot to fetch.
     */
    where?: LootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loots to fetch.
     */
    orderBy?: LootOrderByWithRelationInput | LootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loots.
     */
    cursor?: LootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loots.
     */
    distinct?: LootScalarFieldEnum | LootScalarFieldEnum[]
  }

  /**
   * Loot findFirstOrThrow
   */
  export type LootFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * Filter, which Loot to fetch.
     */
    where?: LootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loots to fetch.
     */
    orderBy?: LootOrderByWithRelationInput | LootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loots.
     */
    cursor?: LootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loots.
     */
    distinct?: LootScalarFieldEnum | LootScalarFieldEnum[]
  }

  /**
   * Loot findMany
   */
  export type LootFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * Filter, which Loots to fetch.
     */
    where?: LootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loots to fetch.
     */
    orderBy?: LootOrderByWithRelationInput | LootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loots.
     */
    cursor?: LootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loots.
     */
    skip?: number
    distinct?: LootScalarFieldEnum | LootScalarFieldEnum[]
  }

  /**
   * Loot create
   */
  export type LootCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * The data needed to create a Loot.
     */
    data: XOR<LootCreateInput, LootUncheckedCreateInput>
  }

  /**
   * Loot createMany
   */
  export type LootCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Loots.
     */
    data: LootCreateManyInput | LootCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Loot createManyAndReturn
   */
  export type LootCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * The data used to create many Loots.
     */
    data: LootCreateManyInput | LootCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Loot update
   */
  export type LootUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * The data needed to update a Loot.
     */
    data: XOR<LootUpdateInput, LootUncheckedUpdateInput>
    /**
     * Choose, which Loot to update.
     */
    where: LootWhereUniqueInput
  }

  /**
   * Loot updateMany
   */
  export type LootUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Loots.
     */
    data: XOR<LootUpdateManyMutationInput, LootUncheckedUpdateManyInput>
    /**
     * Filter which Loots to update
     */
    where?: LootWhereInput
    /**
     * Limit how many Loots to update.
     */
    limit?: number
  }

  /**
   * Loot updateManyAndReturn
   */
  export type LootUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * The data used to update Loots.
     */
    data: XOR<LootUpdateManyMutationInput, LootUncheckedUpdateManyInput>
    /**
     * Filter which Loots to update
     */
    where?: LootWhereInput
    /**
     * Limit how many Loots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Loot upsert
   */
  export type LootUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * The filter to search for the Loot to update in case it exists.
     */
    where: LootWhereUniqueInput
    /**
     * In case the Loot found by the `where` argument doesn't exist, create a new Loot with this data.
     */
    create: XOR<LootCreateInput, LootUncheckedCreateInput>
    /**
     * In case the Loot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LootUpdateInput, LootUncheckedUpdateInput>
  }

  /**
   * Loot delete
   */
  export type LootDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * Filter which Loot to delete.
     */
    where: LootWhereUniqueInput
  }

  /**
   * Loot deleteMany
   */
  export type LootDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loots to delete
     */
    where?: LootWhereInput
    /**
     * Limit how many Loots to delete.
     */
    limit?: number
  }

  /**
   * Loot.soldToUser
   */
  export type Loot$soldToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Loot without action
   */
  export type LootDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
  }


  /**
   * Model TasksUser
   */

  export type AggregateTasksUser = {
    _count: TasksUserCountAggregateOutputType | null
    _avg: TasksUserAvgAggregateOutputType | null
    _sum: TasksUserSumAggregateOutputType | null
    _min: TasksUserMinAggregateOutputType | null
    _max: TasksUserMaxAggregateOutputType | null
  }

  export type TasksUserAvgAggregateOutputType = {
    tasks_user_id: number | null
    user_id: number | null
  }

  export type TasksUserSumAggregateOutputType = {
    tasks_user_id: number | null
    user_id: number | null
  }

  export type TasksUserMinAggregateOutputType = {
    tasks_user_id: number | null
    user_id: number | null
  }

  export type TasksUserMaxAggregateOutputType = {
    tasks_user_id: number | null
    user_id: number | null
  }

  export type TasksUserCountAggregateOutputType = {
    tasks_user_id: number
    user_id: number
    _all: number
  }


  export type TasksUserAvgAggregateInputType = {
    tasks_user_id?: true
    user_id?: true
  }

  export type TasksUserSumAggregateInputType = {
    tasks_user_id?: true
    user_id?: true
  }

  export type TasksUserMinAggregateInputType = {
    tasks_user_id?: true
    user_id?: true
  }

  export type TasksUserMaxAggregateInputType = {
    tasks_user_id?: true
    user_id?: true
  }

  export type TasksUserCountAggregateInputType = {
    tasks_user_id?: true
    user_id?: true
    _all?: true
  }

  export type TasksUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TasksUser to aggregate.
     */
    where?: TasksUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TasksUsers to fetch.
     */
    orderBy?: TasksUserOrderByWithRelationInput | TasksUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TasksUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TasksUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TasksUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TasksUsers
    **/
    _count?: true | TasksUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TasksUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TasksUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TasksUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TasksUserMaxAggregateInputType
  }

  export type GetTasksUserAggregateType<T extends TasksUserAggregateArgs> = {
        [P in keyof T & keyof AggregateTasksUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTasksUser[P]>
      : GetScalarType<T[P], AggregateTasksUser[P]>
  }




  export type TasksUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksUserWhereInput
    orderBy?: TasksUserOrderByWithAggregationInput | TasksUserOrderByWithAggregationInput[]
    by: TasksUserScalarFieldEnum[] | TasksUserScalarFieldEnum
    having?: TasksUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TasksUserCountAggregateInputType | true
    _avg?: TasksUserAvgAggregateInputType
    _sum?: TasksUserSumAggregateInputType
    _min?: TasksUserMinAggregateInputType
    _max?: TasksUserMaxAggregateInputType
  }

  export type TasksUserGroupByOutputType = {
    tasks_user_id: number
    user_id: number
    _count: TasksUserCountAggregateOutputType | null
    _avg: TasksUserAvgAggregateOutputType | null
    _sum: TasksUserSumAggregateOutputType | null
    _min: TasksUserMinAggregateOutputType | null
    _max: TasksUserMaxAggregateOutputType | null
  }

  type GetTasksUserGroupByPayload<T extends TasksUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TasksUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TasksUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TasksUserGroupByOutputType[P]>
            : GetScalarType<T[P], TasksUserGroupByOutputType[P]>
        }
      >
    >


  export type TasksUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tasks_user_id?: boolean
    user_id?: boolean
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasksUser"]>

  export type TasksUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tasks_user_id?: boolean
    user_id?: boolean
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasksUser"]>

  export type TasksUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tasks_user_id?: boolean
    user_id?: boolean
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasksUser"]>

  export type TasksUserSelectScalar = {
    tasks_user_id?: boolean
    user_id?: boolean
  }

  export type TasksUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tasks_user_id" | "user_id", ExtArgs["result"]["tasksUser"]>
  export type TasksUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TasksUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TasksUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TasksUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TasksUser"
    objects: {
      task: Prisma.$TasksPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tasks_user_id: number
      user_id: number
    }, ExtArgs["result"]["tasksUser"]>
    composites: {}
  }

  type TasksUserGetPayload<S extends boolean | null | undefined | TasksUserDefaultArgs> = $Result.GetResult<Prisma.$TasksUserPayload, S>

  type TasksUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TasksUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TasksUserCountAggregateInputType | true
    }

  export interface TasksUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TasksUser'], meta: { name: 'TasksUser' } }
    /**
     * Find zero or one TasksUser that matches the filter.
     * @param {TasksUserFindUniqueArgs} args - Arguments to find a TasksUser
     * @example
     * // Get one TasksUser
     * const tasksUser = await prisma.tasksUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TasksUserFindUniqueArgs>(args: SelectSubset<T, TasksUserFindUniqueArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TasksUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TasksUserFindUniqueOrThrowArgs} args - Arguments to find a TasksUser
     * @example
     * // Get one TasksUser
     * const tasksUser = await prisma.tasksUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TasksUserFindUniqueOrThrowArgs>(args: SelectSubset<T, TasksUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TasksUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserFindFirstArgs} args - Arguments to find a TasksUser
     * @example
     * // Get one TasksUser
     * const tasksUser = await prisma.tasksUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TasksUserFindFirstArgs>(args?: SelectSubset<T, TasksUserFindFirstArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TasksUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserFindFirstOrThrowArgs} args - Arguments to find a TasksUser
     * @example
     * // Get one TasksUser
     * const tasksUser = await prisma.tasksUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TasksUserFindFirstOrThrowArgs>(args?: SelectSubset<T, TasksUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TasksUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TasksUsers
     * const tasksUsers = await prisma.tasksUser.findMany()
     * 
     * // Get first 10 TasksUsers
     * const tasksUsers = await prisma.tasksUser.findMany({ take: 10 })
     * 
     * // Only select the `tasks_user_id`
     * const tasksUserWithTasks_user_idOnly = await prisma.tasksUser.findMany({ select: { tasks_user_id: true } })
     * 
     */
    findMany<T extends TasksUserFindManyArgs>(args?: SelectSubset<T, TasksUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TasksUser.
     * @param {TasksUserCreateArgs} args - Arguments to create a TasksUser.
     * @example
     * // Create one TasksUser
     * const TasksUser = await prisma.tasksUser.create({
     *   data: {
     *     // ... data to create a TasksUser
     *   }
     * })
     * 
     */
    create<T extends TasksUserCreateArgs>(args: SelectSubset<T, TasksUserCreateArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TasksUsers.
     * @param {TasksUserCreateManyArgs} args - Arguments to create many TasksUsers.
     * @example
     * // Create many TasksUsers
     * const tasksUser = await prisma.tasksUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TasksUserCreateManyArgs>(args?: SelectSubset<T, TasksUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TasksUsers and returns the data saved in the database.
     * @param {TasksUserCreateManyAndReturnArgs} args - Arguments to create many TasksUsers.
     * @example
     * // Create many TasksUsers
     * const tasksUser = await prisma.tasksUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TasksUsers and only return the `tasks_user_id`
     * const tasksUserWithTasks_user_idOnly = await prisma.tasksUser.createManyAndReturn({
     *   select: { tasks_user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TasksUserCreateManyAndReturnArgs>(args?: SelectSubset<T, TasksUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TasksUser.
     * @param {TasksUserDeleteArgs} args - Arguments to delete one TasksUser.
     * @example
     * // Delete one TasksUser
     * const TasksUser = await prisma.tasksUser.delete({
     *   where: {
     *     // ... filter to delete one TasksUser
     *   }
     * })
     * 
     */
    delete<T extends TasksUserDeleteArgs>(args: SelectSubset<T, TasksUserDeleteArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TasksUser.
     * @param {TasksUserUpdateArgs} args - Arguments to update one TasksUser.
     * @example
     * // Update one TasksUser
     * const tasksUser = await prisma.tasksUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TasksUserUpdateArgs>(args: SelectSubset<T, TasksUserUpdateArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TasksUsers.
     * @param {TasksUserDeleteManyArgs} args - Arguments to filter TasksUsers to delete.
     * @example
     * // Delete a few TasksUsers
     * const { count } = await prisma.tasksUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TasksUserDeleteManyArgs>(args?: SelectSubset<T, TasksUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TasksUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TasksUsers
     * const tasksUser = await prisma.tasksUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TasksUserUpdateManyArgs>(args: SelectSubset<T, TasksUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TasksUsers and returns the data updated in the database.
     * @param {TasksUserUpdateManyAndReturnArgs} args - Arguments to update many TasksUsers.
     * @example
     * // Update many TasksUsers
     * const tasksUser = await prisma.tasksUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TasksUsers and only return the `tasks_user_id`
     * const tasksUserWithTasks_user_idOnly = await prisma.tasksUser.updateManyAndReturn({
     *   select: { tasks_user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TasksUserUpdateManyAndReturnArgs>(args: SelectSubset<T, TasksUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TasksUser.
     * @param {TasksUserUpsertArgs} args - Arguments to update or create a TasksUser.
     * @example
     * // Update or create a TasksUser
     * const tasksUser = await prisma.tasksUser.upsert({
     *   create: {
     *     // ... data to create a TasksUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TasksUser we want to update
     *   }
     * })
     */
    upsert<T extends TasksUserUpsertArgs>(args: SelectSubset<T, TasksUserUpsertArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TasksUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserCountArgs} args - Arguments to filter TasksUsers to count.
     * @example
     * // Count the number of TasksUsers
     * const count = await prisma.tasksUser.count({
     *   where: {
     *     // ... the filter for the TasksUsers we want to count
     *   }
     * })
    **/
    count<T extends TasksUserCountArgs>(
      args?: Subset<T, TasksUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TasksUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TasksUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TasksUserAggregateArgs>(args: Subset<T, TasksUserAggregateArgs>): Prisma.PrismaPromise<GetTasksUserAggregateType<T>>

    /**
     * Group by TasksUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TasksUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TasksUserGroupByArgs['orderBy'] }
        : { orderBy?: TasksUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TasksUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTasksUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TasksUser model
   */
  readonly fields: TasksUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TasksUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TasksUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TasksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TasksDefaultArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TasksUser model
   */
  interface TasksUserFieldRefs {
    readonly tasks_user_id: FieldRef<"TasksUser", 'Int'>
    readonly user_id: FieldRef<"TasksUser", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TasksUser findUnique
   */
  export type TasksUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * Filter, which TasksUser to fetch.
     */
    where: TasksUserWhereUniqueInput
  }

  /**
   * TasksUser findUniqueOrThrow
   */
  export type TasksUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * Filter, which TasksUser to fetch.
     */
    where: TasksUserWhereUniqueInput
  }

  /**
   * TasksUser findFirst
   */
  export type TasksUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * Filter, which TasksUser to fetch.
     */
    where?: TasksUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TasksUsers to fetch.
     */
    orderBy?: TasksUserOrderByWithRelationInput | TasksUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TasksUsers.
     */
    cursor?: TasksUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TasksUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TasksUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TasksUsers.
     */
    distinct?: TasksUserScalarFieldEnum | TasksUserScalarFieldEnum[]
  }

  /**
   * TasksUser findFirstOrThrow
   */
  export type TasksUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * Filter, which TasksUser to fetch.
     */
    where?: TasksUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TasksUsers to fetch.
     */
    orderBy?: TasksUserOrderByWithRelationInput | TasksUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TasksUsers.
     */
    cursor?: TasksUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TasksUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TasksUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TasksUsers.
     */
    distinct?: TasksUserScalarFieldEnum | TasksUserScalarFieldEnum[]
  }

  /**
   * TasksUser findMany
   */
  export type TasksUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * Filter, which TasksUsers to fetch.
     */
    where?: TasksUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TasksUsers to fetch.
     */
    orderBy?: TasksUserOrderByWithRelationInput | TasksUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TasksUsers.
     */
    cursor?: TasksUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TasksUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TasksUsers.
     */
    skip?: number
    distinct?: TasksUserScalarFieldEnum | TasksUserScalarFieldEnum[]
  }

  /**
   * TasksUser create
   */
  export type TasksUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * The data needed to create a TasksUser.
     */
    data: XOR<TasksUserCreateInput, TasksUserUncheckedCreateInput>
  }

  /**
   * TasksUser createMany
   */
  export type TasksUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TasksUsers.
     */
    data: TasksUserCreateManyInput | TasksUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TasksUser createManyAndReturn
   */
  export type TasksUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * The data used to create many TasksUsers.
     */
    data: TasksUserCreateManyInput | TasksUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TasksUser update
   */
  export type TasksUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * The data needed to update a TasksUser.
     */
    data: XOR<TasksUserUpdateInput, TasksUserUncheckedUpdateInput>
    /**
     * Choose, which TasksUser to update.
     */
    where: TasksUserWhereUniqueInput
  }

  /**
   * TasksUser updateMany
   */
  export type TasksUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TasksUsers.
     */
    data: XOR<TasksUserUpdateManyMutationInput, TasksUserUncheckedUpdateManyInput>
    /**
     * Filter which TasksUsers to update
     */
    where?: TasksUserWhereInput
    /**
     * Limit how many TasksUsers to update.
     */
    limit?: number
  }

  /**
   * TasksUser updateManyAndReturn
   */
  export type TasksUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * The data used to update TasksUsers.
     */
    data: XOR<TasksUserUpdateManyMutationInput, TasksUserUncheckedUpdateManyInput>
    /**
     * Filter which TasksUsers to update
     */
    where?: TasksUserWhereInput
    /**
     * Limit how many TasksUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TasksUser upsert
   */
  export type TasksUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * The filter to search for the TasksUser to update in case it exists.
     */
    where: TasksUserWhereUniqueInput
    /**
     * In case the TasksUser found by the `where` argument doesn't exist, create a new TasksUser with this data.
     */
    create: XOR<TasksUserCreateInput, TasksUserUncheckedCreateInput>
    /**
     * In case the TasksUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TasksUserUpdateInput, TasksUserUncheckedUpdateInput>
  }

  /**
   * TasksUser delete
   */
  export type TasksUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * Filter which TasksUser to delete.
     */
    where: TasksUserWhereUniqueInput
  }

  /**
   * TasksUser deleteMany
   */
  export type TasksUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TasksUsers to delete
     */
    where?: TasksUserWhereInput
    /**
     * Limit how many TasksUsers to delete.
     */
    limit?: number
  }

  /**
   * TasksUser without action
   */
  export type TasksUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
  }


  /**
   * Model LootQueue
   */

  export type AggregateLootQueue = {
    _count: LootQueueCountAggregateOutputType | null
    _avg: LootQueueAvgAggregateOutputType | null
    _sum: LootQueueSumAggregateOutputType | null
    _min: LootQueueMinAggregateOutputType | null
    _max: LootQueueMaxAggregateOutputType | null
  }

  export type LootQueueAvgAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    userId: number | null
    remaining: number | null
  }

  export type LootQueueSumAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    userId: number | null
    remaining: number | null
  }

  export type LootQueueMinAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    userId: number | null
    status: string | null
    synthTarget: string | null
    remaining: number | null
    created_at: Date | null
  }

  export type LootQueueMaxAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    userId: number | null
    status: string | null
    synthTarget: string | null
    remaining: number | null
    created_at: Date | null
  }

  export type LootQueueCountAggregateOutputType = {
    id: number
    itemTypeId: number
    userId: number
    status: number
    synthTarget: number
    remaining: number
    created_at: number
    _all: number
  }


  export type LootQueueAvgAggregateInputType = {
    id?: true
    itemTypeId?: true
    userId?: true
    remaining?: true
  }

  export type LootQueueSumAggregateInputType = {
    id?: true
    itemTypeId?: true
    userId?: true
    remaining?: true
  }

  export type LootQueueMinAggregateInputType = {
    id?: true
    itemTypeId?: true
    userId?: true
    status?: true
    synthTarget?: true
    remaining?: true
    created_at?: true
  }

  export type LootQueueMaxAggregateInputType = {
    id?: true
    itemTypeId?: true
    userId?: true
    status?: true
    synthTarget?: true
    remaining?: true
    created_at?: true
  }

  export type LootQueueCountAggregateInputType = {
    id?: true
    itemTypeId?: true
    userId?: true
    status?: true
    synthTarget?: true
    remaining?: true
    created_at?: true
    _all?: true
  }

  export type LootQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LootQueue to aggregate.
     */
    where?: LootQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LootQueues to fetch.
     */
    orderBy?: LootQueueOrderByWithRelationInput | LootQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LootQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LootQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LootQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LootQueues
    **/
    _count?: true | LootQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LootQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LootQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LootQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LootQueueMaxAggregateInputType
  }

  export type GetLootQueueAggregateType<T extends LootQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateLootQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLootQueue[P]>
      : GetScalarType<T[P], AggregateLootQueue[P]>
  }




  export type LootQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LootQueueWhereInput
    orderBy?: LootQueueOrderByWithAggregationInput | LootQueueOrderByWithAggregationInput[]
    by: LootQueueScalarFieldEnum[] | LootQueueScalarFieldEnum
    having?: LootQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LootQueueCountAggregateInputType | true
    _avg?: LootQueueAvgAggregateInputType
    _sum?: LootQueueSumAggregateInputType
    _min?: LootQueueMinAggregateInputType
    _max?: LootQueueMaxAggregateInputType
  }

  export type LootQueueGroupByOutputType = {
    id: number
    itemTypeId: number
    userId: number
    status: string
    synthTarget: string | null
    remaining: number | null
    created_at: Date
    _count: LootQueueCountAggregateOutputType | null
    _avg: LootQueueAvgAggregateOutputType | null
    _sum: LootQueueSumAggregateOutputType | null
    _min: LootQueueMinAggregateOutputType | null
    _max: LootQueueMaxAggregateOutputType | null
  }

  type GetLootQueueGroupByPayload<T extends LootQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LootQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LootQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LootQueueGroupByOutputType[P]>
            : GetScalarType<T[P], LootQueueGroupByOutputType[P]>
        }
      >
    >


  export type LootQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemTypeId?: boolean
    userId?: boolean
    status?: boolean
    synthTarget?: boolean
    remaining?: boolean
    created_at?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lootQueue"]>

  export type LootQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemTypeId?: boolean
    userId?: boolean
    status?: boolean
    synthTarget?: boolean
    remaining?: boolean
    created_at?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lootQueue"]>

  export type LootQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemTypeId?: boolean
    userId?: boolean
    status?: boolean
    synthTarget?: boolean
    remaining?: boolean
    created_at?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lootQueue"]>

  export type LootQueueSelectScalar = {
    id?: boolean
    itemTypeId?: boolean
    userId?: boolean
    status?: boolean
    synthTarget?: boolean
    remaining?: boolean
    created_at?: boolean
  }

  export type LootQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemTypeId" | "userId" | "status" | "synthTarget" | "remaining" | "created_at", ExtArgs["result"]["lootQueue"]>
  export type LootQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LootQueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LootQueueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LootQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LootQueue"
    objects: {
      itemType: Prisma.$ItemTypePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemTypeId: number
      userId: number
      status: string
      synthTarget: string | null
      remaining: number | null
      created_at: Date
    }, ExtArgs["result"]["lootQueue"]>
    composites: {}
  }

  type LootQueueGetPayload<S extends boolean | null | undefined | LootQueueDefaultArgs> = $Result.GetResult<Prisma.$LootQueuePayload, S>

  type LootQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LootQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LootQueueCountAggregateInputType | true
    }

  export interface LootQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LootQueue'], meta: { name: 'LootQueue' } }
    /**
     * Find zero or one LootQueue that matches the filter.
     * @param {LootQueueFindUniqueArgs} args - Arguments to find a LootQueue
     * @example
     * // Get one LootQueue
     * const lootQueue = await prisma.lootQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LootQueueFindUniqueArgs>(args: SelectSubset<T, LootQueueFindUniqueArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LootQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LootQueueFindUniqueOrThrowArgs} args - Arguments to find a LootQueue
     * @example
     * // Get one LootQueue
     * const lootQueue = await prisma.lootQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LootQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, LootQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LootQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueFindFirstArgs} args - Arguments to find a LootQueue
     * @example
     * // Get one LootQueue
     * const lootQueue = await prisma.lootQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LootQueueFindFirstArgs>(args?: SelectSubset<T, LootQueueFindFirstArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LootQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueFindFirstOrThrowArgs} args - Arguments to find a LootQueue
     * @example
     * // Get one LootQueue
     * const lootQueue = await prisma.lootQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LootQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, LootQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LootQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LootQueues
     * const lootQueues = await prisma.lootQueue.findMany()
     * 
     * // Get first 10 LootQueues
     * const lootQueues = await prisma.lootQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lootQueueWithIdOnly = await prisma.lootQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LootQueueFindManyArgs>(args?: SelectSubset<T, LootQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LootQueue.
     * @param {LootQueueCreateArgs} args - Arguments to create a LootQueue.
     * @example
     * // Create one LootQueue
     * const LootQueue = await prisma.lootQueue.create({
     *   data: {
     *     // ... data to create a LootQueue
     *   }
     * })
     * 
     */
    create<T extends LootQueueCreateArgs>(args: SelectSubset<T, LootQueueCreateArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LootQueues.
     * @param {LootQueueCreateManyArgs} args - Arguments to create many LootQueues.
     * @example
     * // Create many LootQueues
     * const lootQueue = await prisma.lootQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LootQueueCreateManyArgs>(args?: SelectSubset<T, LootQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LootQueues and returns the data saved in the database.
     * @param {LootQueueCreateManyAndReturnArgs} args - Arguments to create many LootQueues.
     * @example
     * // Create many LootQueues
     * const lootQueue = await prisma.lootQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LootQueues and only return the `id`
     * const lootQueueWithIdOnly = await prisma.lootQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LootQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, LootQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LootQueue.
     * @param {LootQueueDeleteArgs} args - Arguments to delete one LootQueue.
     * @example
     * // Delete one LootQueue
     * const LootQueue = await prisma.lootQueue.delete({
     *   where: {
     *     // ... filter to delete one LootQueue
     *   }
     * })
     * 
     */
    delete<T extends LootQueueDeleteArgs>(args: SelectSubset<T, LootQueueDeleteArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LootQueue.
     * @param {LootQueueUpdateArgs} args - Arguments to update one LootQueue.
     * @example
     * // Update one LootQueue
     * const lootQueue = await prisma.lootQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LootQueueUpdateArgs>(args: SelectSubset<T, LootQueueUpdateArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LootQueues.
     * @param {LootQueueDeleteManyArgs} args - Arguments to filter LootQueues to delete.
     * @example
     * // Delete a few LootQueues
     * const { count } = await prisma.lootQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LootQueueDeleteManyArgs>(args?: SelectSubset<T, LootQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LootQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LootQueues
     * const lootQueue = await prisma.lootQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LootQueueUpdateManyArgs>(args: SelectSubset<T, LootQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LootQueues and returns the data updated in the database.
     * @param {LootQueueUpdateManyAndReturnArgs} args - Arguments to update many LootQueues.
     * @example
     * // Update many LootQueues
     * const lootQueue = await prisma.lootQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LootQueues and only return the `id`
     * const lootQueueWithIdOnly = await prisma.lootQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LootQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, LootQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LootQueue.
     * @param {LootQueueUpsertArgs} args - Arguments to update or create a LootQueue.
     * @example
     * // Update or create a LootQueue
     * const lootQueue = await prisma.lootQueue.upsert({
     *   create: {
     *     // ... data to create a LootQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LootQueue we want to update
     *   }
     * })
     */
    upsert<T extends LootQueueUpsertArgs>(args: SelectSubset<T, LootQueueUpsertArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LootQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueCountArgs} args - Arguments to filter LootQueues to count.
     * @example
     * // Count the number of LootQueues
     * const count = await prisma.lootQueue.count({
     *   where: {
     *     // ... the filter for the LootQueues we want to count
     *   }
     * })
    **/
    count<T extends LootQueueCountArgs>(
      args?: Subset<T, LootQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LootQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LootQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LootQueueAggregateArgs>(args: Subset<T, LootQueueAggregateArgs>): Prisma.PrismaPromise<GetLootQueueAggregateType<T>>

    /**
     * Group by LootQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LootQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LootQueueGroupByArgs['orderBy'] }
        : { orderBy?: LootQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LootQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLootQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LootQueue model
   */
  readonly fields: LootQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LootQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LootQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemType<T extends ItemTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemTypeDefaultArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LootQueue model
   */
  interface LootQueueFieldRefs {
    readonly id: FieldRef<"LootQueue", 'Int'>
    readonly itemTypeId: FieldRef<"LootQueue", 'Int'>
    readonly userId: FieldRef<"LootQueue", 'Int'>
    readonly status: FieldRef<"LootQueue", 'String'>
    readonly synthTarget: FieldRef<"LootQueue", 'String'>
    readonly remaining: FieldRef<"LootQueue", 'Int'>
    readonly created_at: FieldRef<"LootQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LootQueue findUnique
   */
  export type LootQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * Filter, which LootQueue to fetch.
     */
    where: LootQueueWhereUniqueInput
  }

  /**
   * LootQueue findUniqueOrThrow
   */
  export type LootQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * Filter, which LootQueue to fetch.
     */
    where: LootQueueWhereUniqueInput
  }

  /**
   * LootQueue findFirst
   */
  export type LootQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * Filter, which LootQueue to fetch.
     */
    where?: LootQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LootQueues to fetch.
     */
    orderBy?: LootQueueOrderByWithRelationInput | LootQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LootQueues.
     */
    cursor?: LootQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LootQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LootQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LootQueues.
     */
    distinct?: LootQueueScalarFieldEnum | LootQueueScalarFieldEnum[]
  }

  /**
   * LootQueue findFirstOrThrow
   */
  export type LootQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * Filter, which LootQueue to fetch.
     */
    where?: LootQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LootQueues to fetch.
     */
    orderBy?: LootQueueOrderByWithRelationInput | LootQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LootQueues.
     */
    cursor?: LootQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LootQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LootQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LootQueues.
     */
    distinct?: LootQueueScalarFieldEnum | LootQueueScalarFieldEnum[]
  }

  /**
   * LootQueue findMany
   */
  export type LootQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * Filter, which LootQueues to fetch.
     */
    where?: LootQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LootQueues to fetch.
     */
    orderBy?: LootQueueOrderByWithRelationInput | LootQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LootQueues.
     */
    cursor?: LootQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LootQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LootQueues.
     */
    skip?: number
    distinct?: LootQueueScalarFieldEnum | LootQueueScalarFieldEnum[]
  }

  /**
   * LootQueue create
   */
  export type LootQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a LootQueue.
     */
    data: XOR<LootQueueCreateInput, LootQueueUncheckedCreateInput>
  }

  /**
   * LootQueue createMany
   */
  export type LootQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LootQueues.
     */
    data: LootQueueCreateManyInput | LootQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LootQueue createManyAndReturn
   */
  export type LootQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * The data used to create many LootQueues.
     */
    data: LootQueueCreateManyInput | LootQueueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LootQueue update
   */
  export type LootQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a LootQueue.
     */
    data: XOR<LootQueueUpdateInput, LootQueueUncheckedUpdateInput>
    /**
     * Choose, which LootQueue to update.
     */
    where: LootQueueWhereUniqueInput
  }

  /**
   * LootQueue updateMany
   */
  export type LootQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LootQueues.
     */
    data: XOR<LootQueueUpdateManyMutationInput, LootQueueUncheckedUpdateManyInput>
    /**
     * Filter which LootQueues to update
     */
    where?: LootQueueWhereInput
    /**
     * Limit how many LootQueues to update.
     */
    limit?: number
  }

  /**
   * LootQueue updateManyAndReturn
   */
  export type LootQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * The data used to update LootQueues.
     */
    data: XOR<LootQueueUpdateManyMutationInput, LootQueueUncheckedUpdateManyInput>
    /**
     * Filter which LootQueues to update
     */
    where?: LootQueueWhereInput
    /**
     * Limit how many LootQueues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LootQueue upsert
   */
  export type LootQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the LootQueue to update in case it exists.
     */
    where: LootQueueWhereUniqueInput
    /**
     * In case the LootQueue found by the `where` argument doesn't exist, create a new LootQueue with this data.
     */
    create: XOR<LootQueueCreateInput, LootQueueUncheckedCreateInput>
    /**
     * In case the LootQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LootQueueUpdateInput, LootQueueUncheckedUpdateInput>
  }

  /**
   * LootQueue delete
   */
  export type LootQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * Filter which LootQueue to delete.
     */
    where: LootQueueWhereUniqueInput
  }

  /**
   * LootQueue deleteMany
   */
  export type LootQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LootQueues to delete
     */
    where?: LootQueueWhereInput
    /**
     * Limit how many LootQueues to delete.
     */
    limit?: number
  }

  /**
   * LootQueue without action
   */
  export type LootQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    class: 'class',
    secondary_class: 'secondary_class',
    class_gear_score: 'class_gear_score',
    secondary_class_gear_score: 'secondary_class_gear_score',
    vk_name: 'vk_name',
    active: 'active',
    is_eligible_for_salary: 'is_eligible_for_salary',
    joined_at: 'joined_at',
    created_at: 'created_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserTagsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    tag: 'tag',
    created_at: 'created_at'
  };

  export type UserTagsScalarFieldEnum = (typeof UserTagsScalarFieldEnum)[keyof typeof UserTagsScalarFieldEnum]


  export const UserInventoryScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    type: 'type',
    name: 'name',
    quality: 'quality',
    created_at: 'created_at'
  };

  export type UserInventoryScalarFieldEnum = (typeof UserInventoryScalarFieldEnum)[keyof typeof UserInventoryScalarFieldEnum]


  export const TasksScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    completed_at: 'completed_at',
    created_at: 'created_at'
  };

  export type TasksScalarFieldEnum = (typeof TasksScalarFieldEnum)[keyof typeof TasksScalarFieldEnum]


  export const RaidScalarFieldEnum: {
    id: 'id',
    type: 'type',
    is_pvp: 'is_pvp',
    is_pvp_long: 'is_pvp_long',
    start_date: 'start_date',
    created_at: 'created_at',
    dkp_summary: 'dkp_summary'
  };

  export type RaidScalarFieldEnum = (typeof RaidScalarFieldEnum)[keyof typeof RaidScalarFieldEnum]


  export const BossScalarFieldEnum: {
    id: 'id',
    boss_name: 'boss_name',
    dkp_points: 'dkp_points',
    category: 'category'
  };

  export type BossScalarFieldEnum = (typeof BossScalarFieldEnum)[keyof typeof BossScalarFieldEnum]


  export const RaidBossScalarFieldEnum: {
    raid_id: 'raid_id',
    boss_id: 'boss_id'
  };

  export type RaidBossScalarFieldEnum = (typeof RaidBossScalarFieldEnum)[keyof typeof RaidBossScalarFieldEnum]


  export const RaidAttendanceScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    raid_id: 'raid_id',
    created_at: 'created_at'
  };

  export type RaidAttendanceScalarFieldEnum = (typeof RaidAttendanceScalarFieldEnum)[keyof typeof RaidAttendanceScalarFieldEnum]


  export const ItemTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price'
  };

  export type ItemTypeScalarFieldEnum = (typeof ItemTypeScalarFieldEnum)[keyof typeof ItemTypeScalarFieldEnum]


  export const LootScalarFieldEnum: {
    id: 'id',
    itemTypeId: 'itemTypeId',
    status: 'status',
    acquired_at: 'acquired_at',
    sold_at: 'sold_at',
    sold_to: 'sold_to',
    sold_to_user_id: 'sold_to_user_id',
    comment: 'comment',
    source: 'source',
    created_at: 'created_at'
  };

  export type LootScalarFieldEnum = (typeof LootScalarFieldEnum)[keyof typeof LootScalarFieldEnum]


  export const TasksUserScalarFieldEnum: {
    tasks_user_id: 'tasks_user_id',
    user_id: 'user_id'
  };

  export type TasksUserScalarFieldEnum = (typeof TasksUserScalarFieldEnum)[keyof typeof TasksUserScalarFieldEnum]


  export const LootQueueScalarFieldEnum: {
    id: 'id',
    itemTypeId: 'itemTypeId',
    userId: 'userId',
    status: 'status',
    synthTarget: 'synthTarget',
    remaining: 'remaining',
    created_at: 'created_at'
  };

  export type LootQueueScalarFieldEnum = (typeof LootQueueScalarFieldEnum)[keyof typeof LootQueueScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    class?: StringNullableFilter<"User"> | string | null
    secondary_class?: StringNullableFilter<"User"> | string | null
    class_gear_score?: IntNullableFilter<"User"> | number | null
    secondary_class_gear_score?: IntNullableFilter<"User"> | number | null
    vk_name?: StringNullableFilter<"User"> | string | null
    active?: BoolFilter<"User"> | boolean
    is_eligible_for_salary?: BoolFilter<"User"> | boolean
    joined_at?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    inventory?: UserInventoryListRelationFilter
    tasks?: TasksListRelationFilter
    raidAttendance?: RaidAttendanceListRelationFilter
    tasksAssigned?: TasksUserListRelationFilter
    tags?: UserTagsListRelationFilter
    soldLoot?: LootListRelationFilter
    lootQueue?: LootQueueListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    class?: SortOrderInput | SortOrder
    secondary_class?: SortOrderInput | SortOrder
    class_gear_score?: SortOrderInput | SortOrder
    secondary_class_gear_score?: SortOrderInput | SortOrder
    vk_name?: SortOrderInput | SortOrder
    active?: SortOrder
    is_eligible_for_salary?: SortOrder
    joined_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    inventory?: UserInventoryOrderByRelationAggregateInput
    tasks?: TasksOrderByRelationAggregateInput
    raidAttendance?: RaidAttendanceOrderByRelationAggregateInput
    tasksAssigned?: TasksUserOrderByRelationAggregateInput
    tags?: UserTagsOrderByRelationAggregateInput
    soldLoot?: LootOrderByRelationAggregateInput
    lootQueue?: LootQueueOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    class?: StringNullableFilter<"User"> | string | null
    secondary_class?: StringNullableFilter<"User"> | string | null
    class_gear_score?: IntNullableFilter<"User"> | number | null
    secondary_class_gear_score?: IntNullableFilter<"User"> | number | null
    vk_name?: StringNullableFilter<"User"> | string | null
    active?: BoolFilter<"User"> | boolean
    is_eligible_for_salary?: BoolFilter<"User"> | boolean
    joined_at?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    inventory?: UserInventoryListRelationFilter
    tasks?: TasksListRelationFilter
    raidAttendance?: RaidAttendanceListRelationFilter
    tasksAssigned?: TasksUserListRelationFilter
    tags?: UserTagsListRelationFilter
    soldLoot?: LootListRelationFilter
    lootQueue?: LootQueueListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    class?: SortOrderInput | SortOrder
    secondary_class?: SortOrderInput | SortOrder
    class_gear_score?: SortOrderInput | SortOrder
    secondary_class_gear_score?: SortOrderInput | SortOrder
    vk_name?: SortOrderInput | SortOrder
    active?: SortOrder
    is_eligible_for_salary?: SortOrder
    joined_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    class?: StringNullableWithAggregatesFilter<"User"> | string | null
    secondary_class?: StringNullableWithAggregatesFilter<"User"> | string | null
    class_gear_score?: IntNullableWithAggregatesFilter<"User"> | number | null
    secondary_class_gear_score?: IntNullableWithAggregatesFilter<"User"> | number | null
    vk_name?: StringNullableWithAggregatesFilter<"User"> | string | null
    active?: BoolWithAggregatesFilter<"User"> | boolean
    is_eligible_for_salary?: BoolWithAggregatesFilter<"User"> | boolean
    joined_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserTagsWhereInput = {
    AND?: UserTagsWhereInput | UserTagsWhereInput[]
    OR?: UserTagsWhereInput[]
    NOT?: UserTagsWhereInput | UserTagsWhereInput[]
    id?: IntFilter<"UserTags"> | number
    user_id?: IntFilter<"UserTags"> | number
    tag?: StringFilter<"UserTags"> | string
    created_at?: DateTimeFilter<"UserTags"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserTagsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    tag?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserTagsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserTagsWhereInput | UserTagsWhereInput[]
    OR?: UserTagsWhereInput[]
    NOT?: UserTagsWhereInput | UserTagsWhereInput[]
    user_id?: IntFilter<"UserTags"> | number
    tag?: StringFilter<"UserTags"> | string
    created_at?: DateTimeFilter<"UserTags"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserTagsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    tag?: SortOrder
    created_at?: SortOrder
    _count?: UserTagsCountOrderByAggregateInput
    _avg?: UserTagsAvgOrderByAggregateInput
    _max?: UserTagsMaxOrderByAggregateInput
    _min?: UserTagsMinOrderByAggregateInput
    _sum?: UserTagsSumOrderByAggregateInput
  }

  export type UserTagsScalarWhereWithAggregatesInput = {
    AND?: UserTagsScalarWhereWithAggregatesInput | UserTagsScalarWhereWithAggregatesInput[]
    OR?: UserTagsScalarWhereWithAggregatesInput[]
    NOT?: UserTagsScalarWhereWithAggregatesInput | UserTagsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserTags"> | number
    user_id?: IntWithAggregatesFilter<"UserTags"> | number
    tag?: StringWithAggregatesFilter<"UserTags"> | string
    created_at?: DateTimeWithAggregatesFilter<"UserTags"> | Date | string
  }

  export type UserInventoryWhereInput = {
    AND?: UserInventoryWhereInput | UserInventoryWhereInput[]
    OR?: UserInventoryWhereInput[]
    NOT?: UserInventoryWhereInput | UserInventoryWhereInput[]
    id?: IntFilter<"UserInventory"> | number
    user_id?: IntFilter<"UserInventory"> | number
    type?: StringNullableFilter<"UserInventory"> | string | null
    name?: StringNullableFilter<"UserInventory"> | string | null
    quality?: StringNullableFilter<"UserInventory"> | string | null
    created_at?: DateTimeFilter<"UserInventory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserInventoryOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    quality?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserInventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserInventoryWhereInput | UserInventoryWhereInput[]
    OR?: UserInventoryWhereInput[]
    NOT?: UserInventoryWhereInput | UserInventoryWhereInput[]
    user_id?: IntFilter<"UserInventory"> | number
    type?: StringNullableFilter<"UserInventory"> | string | null
    name?: StringNullableFilter<"UserInventory"> | string | null
    quality?: StringNullableFilter<"UserInventory"> | string | null
    created_at?: DateTimeFilter<"UserInventory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserInventoryOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    quality?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: UserInventoryCountOrderByAggregateInput
    _avg?: UserInventoryAvgOrderByAggregateInput
    _max?: UserInventoryMaxOrderByAggregateInput
    _min?: UserInventoryMinOrderByAggregateInput
    _sum?: UserInventorySumOrderByAggregateInput
  }

  export type UserInventoryScalarWhereWithAggregatesInput = {
    AND?: UserInventoryScalarWhereWithAggregatesInput | UserInventoryScalarWhereWithAggregatesInput[]
    OR?: UserInventoryScalarWhereWithAggregatesInput[]
    NOT?: UserInventoryScalarWhereWithAggregatesInput | UserInventoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserInventory"> | number
    user_id?: IntWithAggregatesFilter<"UserInventory"> | number
    type?: StringNullableWithAggregatesFilter<"UserInventory"> | string | null
    name?: StringNullableWithAggregatesFilter<"UserInventory"> | string | null
    quality?: StringNullableWithAggregatesFilter<"UserInventory"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"UserInventory"> | Date | string
  }

  export type TasksWhereInput = {
    AND?: TasksWhereInput | TasksWhereInput[]
    OR?: TasksWhereInput[]
    NOT?: TasksWhereInput | TasksWhereInput[]
    id?: IntFilter<"Tasks"> | number
    user_id?: IntFilter<"Tasks"> | number
    name?: StringNullableFilter<"Tasks"> | string | null
    completed_at?: DateTimeNullableFilter<"Tasks"> | Date | string | null
    created_at?: DateTimeFilter<"Tasks"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: TasksUserListRelationFilter
  }

  export type TasksOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
    assignedTo?: TasksUserOrderByRelationAggregateInput
  }

  export type TasksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TasksWhereInput | TasksWhereInput[]
    OR?: TasksWhereInput[]
    NOT?: TasksWhereInput | TasksWhereInput[]
    user_id?: IntFilter<"Tasks"> | number
    name?: StringNullableFilter<"Tasks"> | string | null
    completed_at?: DateTimeNullableFilter<"Tasks"> | Date | string | null
    created_at?: DateTimeFilter<"Tasks"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: TasksUserListRelationFilter
  }, "id">

  export type TasksOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: TasksCountOrderByAggregateInput
    _avg?: TasksAvgOrderByAggregateInput
    _max?: TasksMaxOrderByAggregateInput
    _min?: TasksMinOrderByAggregateInput
    _sum?: TasksSumOrderByAggregateInput
  }

  export type TasksScalarWhereWithAggregatesInput = {
    AND?: TasksScalarWhereWithAggregatesInput | TasksScalarWhereWithAggregatesInput[]
    OR?: TasksScalarWhereWithAggregatesInput[]
    NOT?: TasksScalarWhereWithAggregatesInput | TasksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tasks"> | number
    user_id?: IntWithAggregatesFilter<"Tasks"> | number
    name?: StringNullableWithAggregatesFilter<"Tasks"> | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"Tasks"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"Tasks"> | Date | string
  }

  export type RaidWhereInput = {
    AND?: RaidWhereInput | RaidWhereInput[]
    OR?: RaidWhereInput[]
    NOT?: RaidWhereInput | RaidWhereInput[]
    id?: IntFilter<"Raid"> | number
    type?: StringNullableFilter<"Raid"> | string | null
    is_pvp?: BoolFilter<"Raid"> | boolean
    is_pvp_long?: BoolFilter<"Raid"> | boolean
    start_date?: DateTimeNullableFilter<"Raid"> | Date | string | null
    created_at?: DateTimeFilter<"Raid"> | Date | string
    dkp_summary?: IntFilter<"Raid"> | number
    raidBosses?: RaidBossListRelationFilter
    attendance?: RaidAttendanceListRelationFilter
  }

  export type RaidOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    is_pvp?: SortOrder
    is_pvp_long?: SortOrder
    start_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    dkp_summary?: SortOrder
    raidBosses?: RaidBossOrderByRelationAggregateInput
    attendance?: RaidAttendanceOrderByRelationAggregateInput
  }

  export type RaidWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RaidWhereInput | RaidWhereInput[]
    OR?: RaidWhereInput[]
    NOT?: RaidWhereInput | RaidWhereInput[]
    type?: StringNullableFilter<"Raid"> | string | null
    is_pvp?: BoolFilter<"Raid"> | boolean
    is_pvp_long?: BoolFilter<"Raid"> | boolean
    start_date?: DateTimeNullableFilter<"Raid"> | Date | string | null
    created_at?: DateTimeFilter<"Raid"> | Date | string
    dkp_summary?: IntFilter<"Raid"> | number
    raidBosses?: RaidBossListRelationFilter
    attendance?: RaidAttendanceListRelationFilter
  }, "id">

  export type RaidOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    is_pvp?: SortOrder
    is_pvp_long?: SortOrder
    start_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    dkp_summary?: SortOrder
    _count?: RaidCountOrderByAggregateInput
    _avg?: RaidAvgOrderByAggregateInput
    _max?: RaidMaxOrderByAggregateInput
    _min?: RaidMinOrderByAggregateInput
    _sum?: RaidSumOrderByAggregateInput
  }

  export type RaidScalarWhereWithAggregatesInput = {
    AND?: RaidScalarWhereWithAggregatesInput | RaidScalarWhereWithAggregatesInput[]
    OR?: RaidScalarWhereWithAggregatesInput[]
    NOT?: RaidScalarWhereWithAggregatesInput | RaidScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Raid"> | number
    type?: StringNullableWithAggregatesFilter<"Raid"> | string | null
    is_pvp?: BoolWithAggregatesFilter<"Raid"> | boolean
    is_pvp_long?: BoolWithAggregatesFilter<"Raid"> | boolean
    start_date?: DateTimeNullableWithAggregatesFilter<"Raid"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"Raid"> | Date | string
    dkp_summary?: IntWithAggregatesFilter<"Raid"> | number
  }

  export type BossWhereInput = {
    AND?: BossWhereInput | BossWhereInput[]
    OR?: BossWhereInput[]
    NOT?: BossWhereInput | BossWhereInput[]
    id?: IntFilter<"Boss"> | number
    boss_name?: StringFilter<"Boss"> | string
    dkp_points?: IntFilter<"Boss"> | number
    category?: StringFilter<"Boss"> | string
    raidBosses?: RaidBossListRelationFilter
  }

  export type BossOrderByWithRelationInput = {
    id?: SortOrder
    boss_name?: SortOrder
    dkp_points?: SortOrder
    category?: SortOrder
    raidBosses?: RaidBossOrderByRelationAggregateInput
  }

  export type BossWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BossWhereInput | BossWhereInput[]
    OR?: BossWhereInput[]
    NOT?: BossWhereInput | BossWhereInput[]
    boss_name?: StringFilter<"Boss"> | string
    dkp_points?: IntFilter<"Boss"> | number
    category?: StringFilter<"Boss"> | string
    raidBosses?: RaidBossListRelationFilter
  }, "id">

  export type BossOrderByWithAggregationInput = {
    id?: SortOrder
    boss_name?: SortOrder
    dkp_points?: SortOrder
    category?: SortOrder
    _count?: BossCountOrderByAggregateInput
    _avg?: BossAvgOrderByAggregateInput
    _max?: BossMaxOrderByAggregateInput
    _min?: BossMinOrderByAggregateInput
    _sum?: BossSumOrderByAggregateInput
  }

  export type BossScalarWhereWithAggregatesInput = {
    AND?: BossScalarWhereWithAggregatesInput | BossScalarWhereWithAggregatesInput[]
    OR?: BossScalarWhereWithAggregatesInput[]
    NOT?: BossScalarWhereWithAggregatesInput | BossScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Boss"> | number
    boss_name?: StringWithAggregatesFilter<"Boss"> | string
    dkp_points?: IntWithAggregatesFilter<"Boss"> | number
    category?: StringWithAggregatesFilter<"Boss"> | string
  }

  export type RaidBossWhereInput = {
    AND?: RaidBossWhereInput | RaidBossWhereInput[]
    OR?: RaidBossWhereInput[]
    NOT?: RaidBossWhereInput | RaidBossWhereInput[]
    raid_id?: IntFilter<"RaidBoss"> | number
    boss_id?: IntFilter<"RaidBoss"> | number
    raid?: XOR<RaidScalarRelationFilter, RaidWhereInput>
    boss?: XOR<BossScalarRelationFilter, BossWhereInput>
  }

  export type RaidBossOrderByWithRelationInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
    raid?: RaidOrderByWithRelationInput
    boss?: BossOrderByWithRelationInput
  }

  export type RaidBossWhereUniqueInput = Prisma.AtLeast<{
    raid_id_boss_id?: RaidBossRaid_idBoss_idCompoundUniqueInput
    AND?: RaidBossWhereInput | RaidBossWhereInput[]
    OR?: RaidBossWhereInput[]
    NOT?: RaidBossWhereInput | RaidBossWhereInput[]
    raid_id?: IntFilter<"RaidBoss"> | number
    boss_id?: IntFilter<"RaidBoss"> | number
    raid?: XOR<RaidScalarRelationFilter, RaidWhereInput>
    boss?: XOR<BossScalarRelationFilter, BossWhereInput>
  }, "raid_id_boss_id">

  export type RaidBossOrderByWithAggregationInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
    _count?: RaidBossCountOrderByAggregateInput
    _avg?: RaidBossAvgOrderByAggregateInput
    _max?: RaidBossMaxOrderByAggregateInput
    _min?: RaidBossMinOrderByAggregateInput
    _sum?: RaidBossSumOrderByAggregateInput
  }

  export type RaidBossScalarWhereWithAggregatesInput = {
    AND?: RaidBossScalarWhereWithAggregatesInput | RaidBossScalarWhereWithAggregatesInput[]
    OR?: RaidBossScalarWhereWithAggregatesInput[]
    NOT?: RaidBossScalarWhereWithAggregatesInput | RaidBossScalarWhereWithAggregatesInput[]
    raid_id?: IntWithAggregatesFilter<"RaidBoss"> | number
    boss_id?: IntWithAggregatesFilter<"RaidBoss"> | number
  }

  export type RaidAttendanceWhereInput = {
    AND?: RaidAttendanceWhereInput | RaidAttendanceWhereInput[]
    OR?: RaidAttendanceWhereInput[]
    NOT?: RaidAttendanceWhereInput | RaidAttendanceWhereInput[]
    id?: IntFilter<"RaidAttendance"> | number
    user_id?: IntFilter<"RaidAttendance"> | number
    raid_id?: IntFilter<"RaidAttendance"> | number
    created_at?: DateTimeFilter<"RaidAttendance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    raid?: XOR<RaidScalarRelationFilter, RaidWhereInput>
  }

  export type RaidAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
    raid?: RaidOrderByWithRelationInput
  }

  export type RaidAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RaidAttendanceWhereInput | RaidAttendanceWhereInput[]
    OR?: RaidAttendanceWhereInput[]
    NOT?: RaidAttendanceWhereInput | RaidAttendanceWhereInput[]
    user_id?: IntFilter<"RaidAttendance"> | number
    raid_id?: IntFilter<"RaidAttendance"> | number
    created_at?: DateTimeFilter<"RaidAttendance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    raid?: XOR<RaidScalarRelationFilter, RaidWhereInput>
  }, "id">

  export type RaidAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
    created_at?: SortOrder
    _count?: RaidAttendanceCountOrderByAggregateInput
    _avg?: RaidAttendanceAvgOrderByAggregateInput
    _max?: RaidAttendanceMaxOrderByAggregateInput
    _min?: RaidAttendanceMinOrderByAggregateInput
    _sum?: RaidAttendanceSumOrderByAggregateInput
  }

  export type RaidAttendanceScalarWhereWithAggregatesInput = {
    AND?: RaidAttendanceScalarWhereWithAggregatesInput | RaidAttendanceScalarWhereWithAggregatesInput[]
    OR?: RaidAttendanceScalarWhereWithAggregatesInput[]
    NOT?: RaidAttendanceScalarWhereWithAggregatesInput | RaidAttendanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RaidAttendance"> | number
    user_id?: IntWithAggregatesFilter<"RaidAttendance"> | number
    raid_id?: IntWithAggregatesFilter<"RaidAttendance"> | number
    created_at?: DateTimeWithAggregatesFilter<"RaidAttendance"> | Date | string
  }

  export type ItemTypeWhereInput = {
    AND?: ItemTypeWhereInput | ItemTypeWhereInput[]
    OR?: ItemTypeWhereInput[]
    NOT?: ItemTypeWhereInput | ItemTypeWhereInput[]
    id?: IntFilter<"ItemType"> | number
    name?: StringFilter<"ItemType"> | string
    price?: FloatNullableFilter<"ItemType"> | number | null
    loot?: LootListRelationFilter
    lootQueue?: LootQueueListRelationFilter
  }

  export type ItemTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrderInput | SortOrder
    loot?: LootOrderByRelationAggregateInput
    lootQueue?: LootQueueOrderByRelationAggregateInput
  }

  export type ItemTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ItemTypeWhereInput | ItemTypeWhereInput[]
    OR?: ItemTypeWhereInput[]
    NOT?: ItemTypeWhereInput | ItemTypeWhereInput[]
    price?: FloatNullableFilter<"ItemType"> | number | null
    loot?: LootListRelationFilter
    lootQueue?: LootQueueListRelationFilter
  }, "id" | "name">

  export type ItemTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrderInput | SortOrder
    _count?: ItemTypeCountOrderByAggregateInput
    _avg?: ItemTypeAvgOrderByAggregateInput
    _max?: ItemTypeMaxOrderByAggregateInput
    _min?: ItemTypeMinOrderByAggregateInput
    _sum?: ItemTypeSumOrderByAggregateInput
  }

  export type ItemTypeScalarWhereWithAggregatesInput = {
    AND?: ItemTypeScalarWhereWithAggregatesInput | ItemTypeScalarWhereWithAggregatesInput[]
    OR?: ItemTypeScalarWhereWithAggregatesInput[]
    NOT?: ItemTypeScalarWhereWithAggregatesInput | ItemTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemType"> | number
    name?: StringWithAggregatesFilter<"ItemType"> | string
    price?: FloatNullableWithAggregatesFilter<"ItemType"> | number | null
  }

  export type LootWhereInput = {
    AND?: LootWhereInput | LootWhereInput[]
    OR?: LootWhereInput[]
    NOT?: LootWhereInput | LootWhereInput[]
    id?: IntFilter<"Loot"> | number
    itemTypeId?: IntFilter<"Loot"> | number
    status?: StringFilter<"Loot"> | string
    acquired_at?: DateTimeFilter<"Loot"> | Date | string
    sold_at?: DateTimeNullableFilter<"Loot"> | Date | string | null
    sold_to?: StringNullableFilter<"Loot"> | string | null
    sold_to_user_id?: IntNullableFilter<"Loot"> | number | null
    comment?: StringNullableFilter<"Loot"> | string | null
    source?: StringNullableFilter<"Loot"> | string | null
    created_at?: DateTimeFilter<"Loot"> | Date | string
    itemType?: XOR<ItemTypeScalarRelationFilter, ItemTypeWhereInput>
    soldToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LootOrderByWithRelationInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    status?: SortOrder
    acquired_at?: SortOrder
    sold_at?: SortOrderInput | SortOrder
    sold_to?: SortOrderInput | SortOrder
    sold_to_user_id?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    created_at?: SortOrder
    itemType?: ItemTypeOrderByWithRelationInput
    soldToUser?: UserOrderByWithRelationInput
  }

  export type LootWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LootWhereInput | LootWhereInput[]
    OR?: LootWhereInput[]
    NOT?: LootWhereInput | LootWhereInput[]
    itemTypeId?: IntFilter<"Loot"> | number
    status?: StringFilter<"Loot"> | string
    acquired_at?: DateTimeFilter<"Loot"> | Date | string
    sold_at?: DateTimeNullableFilter<"Loot"> | Date | string | null
    sold_to?: StringNullableFilter<"Loot"> | string | null
    sold_to_user_id?: IntNullableFilter<"Loot"> | number | null
    comment?: StringNullableFilter<"Loot"> | string | null
    source?: StringNullableFilter<"Loot"> | string | null
    created_at?: DateTimeFilter<"Loot"> | Date | string
    itemType?: XOR<ItemTypeScalarRelationFilter, ItemTypeWhereInput>
    soldToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LootOrderByWithAggregationInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    status?: SortOrder
    acquired_at?: SortOrder
    sold_at?: SortOrderInput | SortOrder
    sold_to?: SortOrderInput | SortOrder
    sold_to_user_id?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: LootCountOrderByAggregateInput
    _avg?: LootAvgOrderByAggregateInput
    _max?: LootMaxOrderByAggregateInput
    _min?: LootMinOrderByAggregateInput
    _sum?: LootSumOrderByAggregateInput
  }

  export type LootScalarWhereWithAggregatesInput = {
    AND?: LootScalarWhereWithAggregatesInput | LootScalarWhereWithAggregatesInput[]
    OR?: LootScalarWhereWithAggregatesInput[]
    NOT?: LootScalarWhereWithAggregatesInput | LootScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Loot"> | number
    itemTypeId?: IntWithAggregatesFilter<"Loot"> | number
    status?: StringWithAggregatesFilter<"Loot"> | string
    acquired_at?: DateTimeWithAggregatesFilter<"Loot"> | Date | string
    sold_at?: DateTimeNullableWithAggregatesFilter<"Loot"> | Date | string | null
    sold_to?: StringNullableWithAggregatesFilter<"Loot"> | string | null
    sold_to_user_id?: IntNullableWithAggregatesFilter<"Loot"> | number | null
    comment?: StringNullableWithAggregatesFilter<"Loot"> | string | null
    source?: StringNullableWithAggregatesFilter<"Loot"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Loot"> | Date | string
  }

  export type TasksUserWhereInput = {
    AND?: TasksUserWhereInput | TasksUserWhereInput[]
    OR?: TasksUserWhereInput[]
    NOT?: TasksUserWhereInput | TasksUserWhereInput[]
    tasks_user_id?: IntFilter<"TasksUser"> | number
    user_id?: IntFilter<"TasksUser"> | number
    task?: XOR<TasksScalarRelationFilter, TasksWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TasksUserOrderByWithRelationInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
    task?: TasksOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TasksUserWhereUniqueInput = Prisma.AtLeast<{
    tasks_user_id_user_id?: TasksUserTasks_user_idUser_idCompoundUniqueInput
    AND?: TasksUserWhereInput | TasksUserWhereInput[]
    OR?: TasksUserWhereInput[]
    NOT?: TasksUserWhereInput | TasksUserWhereInput[]
    tasks_user_id?: IntFilter<"TasksUser"> | number
    user_id?: IntFilter<"TasksUser"> | number
    task?: XOR<TasksScalarRelationFilter, TasksWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "tasks_user_id_user_id">

  export type TasksUserOrderByWithAggregationInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
    _count?: TasksUserCountOrderByAggregateInput
    _avg?: TasksUserAvgOrderByAggregateInput
    _max?: TasksUserMaxOrderByAggregateInput
    _min?: TasksUserMinOrderByAggregateInput
    _sum?: TasksUserSumOrderByAggregateInput
  }

  export type TasksUserScalarWhereWithAggregatesInput = {
    AND?: TasksUserScalarWhereWithAggregatesInput | TasksUserScalarWhereWithAggregatesInput[]
    OR?: TasksUserScalarWhereWithAggregatesInput[]
    NOT?: TasksUserScalarWhereWithAggregatesInput | TasksUserScalarWhereWithAggregatesInput[]
    tasks_user_id?: IntWithAggregatesFilter<"TasksUser"> | number
    user_id?: IntWithAggregatesFilter<"TasksUser"> | number
  }

  export type LootQueueWhereInput = {
    AND?: LootQueueWhereInput | LootQueueWhereInput[]
    OR?: LootQueueWhereInput[]
    NOT?: LootQueueWhereInput | LootQueueWhereInput[]
    id?: IntFilter<"LootQueue"> | number
    itemTypeId?: IntFilter<"LootQueue"> | number
    userId?: IntFilter<"LootQueue"> | number
    status?: StringFilter<"LootQueue"> | string
    synthTarget?: StringNullableFilter<"LootQueue"> | string | null
    remaining?: IntNullableFilter<"LootQueue"> | number | null
    created_at?: DateTimeFilter<"LootQueue"> | Date | string
    itemType?: XOR<ItemTypeScalarRelationFilter, ItemTypeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LootQueueOrderByWithRelationInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    synthTarget?: SortOrderInput | SortOrder
    remaining?: SortOrderInput | SortOrder
    created_at?: SortOrder
    itemType?: ItemTypeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LootQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LootQueueWhereInput | LootQueueWhereInput[]
    OR?: LootQueueWhereInput[]
    NOT?: LootQueueWhereInput | LootQueueWhereInput[]
    itemTypeId?: IntFilter<"LootQueue"> | number
    userId?: IntFilter<"LootQueue"> | number
    status?: StringFilter<"LootQueue"> | string
    synthTarget?: StringNullableFilter<"LootQueue"> | string | null
    remaining?: IntNullableFilter<"LootQueue"> | number | null
    created_at?: DateTimeFilter<"LootQueue"> | Date | string
    itemType?: XOR<ItemTypeScalarRelationFilter, ItemTypeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LootQueueOrderByWithAggregationInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    synthTarget?: SortOrderInput | SortOrder
    remaining?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: LootQueueCountOrderByAggregateInput
    _avg?: LootQueueAvgOrderByAggregateInput
    _max?: LootQueueMaxOrderByAggregateInput
    _min?: LootQueueMinOrderByAggregateInput
    _sum?: LootQueueSumOrderByAggregateInput
  }

  export type LootQueueScalarWhereWithAggregatesInput = {
    AND?: LootQueueScalarWhereWithAggregatesInput | LootQueueScalarWhereWithAggregatesInput[]
    OR?: LootQueueScalarWhereWithAggregatesInput[]
    NOT?: LootQueueScalarWhereWithAggregatesInput | LootQueueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LootQueue"> | number
    itemTypeId?: IntWithAggregatesFilter<"LootQueue"> | number
    userId?: IntWithAggregatesFilter<"LootQueue"> | number
    status?: StringWithAggregatesFilter<"LootQueue"> | string
    synthTarget?: StringNullableWithAggregatesFilter<"LootQueue"> | string | null
    remaining?: IntNullableWithAggregatesFilter<"LootQueue"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"LootQueue"> | Date | string
  }

  export type UserCreateInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsCreateInput = {
    tag: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutTagsInput
  }

  export type UserTagsUncheckedCreateInput = {
    id?: number
    user_id: number
    tag: string
    created_at?: Date | string
  }

  export type UserTagsUpdateInput = {
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagsNestedInput
  }

  export type UserTagsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsCreateManyInput = {
    id?: number
    user_id: number
    tag: string
    created_at?: Date | string
  }

  export type UserTagsUpdateManyMutationInput = {
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryCreateInput = {
    type?: string | null
    name?: string | null
    quality?: string | null
    created_at: Date | string
    user: UserCreateNestedOneWithoutInventoryInput
  }

  export type UserInventoryUncheckedCreateInput = {
    id?: number
    user_id: number
    type?: string | null
    name?: string | null
    quality?: string | null
    created_at: Date | string
  }

  export type UserInventoryUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type UserInventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryCreateManyInput = {
    id?: number
    user_id: number
    type?: string | null
    name?: string | null
    quality?: string | null
    created_at: Date | string
  }

  export type UserInventoryUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TasksCreateInput = {
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
    user: UserCreateNestedOneWithoutTasksInput
    assignedTo?: TasksUserCreateNestedManyWithoutTaskInput
  }

  export type TasksUncheckedCreateInput = {
    id?: number
    user_id: number
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
    assignedTo?: TasksUserUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TasksUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    assignedTo?: TasksUserUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: TasksUserUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TasksCreateManyInput = {
    id?: number
    user_id: number
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
  }

  export type TasksUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TasksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidCreateInput = {
    type?: string | null
    is_pvp?: boolean
    is_pvp_long?: boolean
    start_date?: Date | string | null
    created_at?: Date | string
    dkp_summary?: number
    raidBosses?: RaidBossCreateNestedManyWithoutRaidInput
    attendance?: RaidAttendanceCreateNestedManyWithoutRaidInput
  }

  export type RaidUncheckedCreateInput = {
    id?: number
    type?: string | null
    is_pvp?: boolean
    is_pvp_long?: boolean
    start_date?: Date | string | null
    created_at?: Date | string
    dkp_summary?: number
    raidBosses?: RaidBossUncheckedCreateNestedManyWithoutRaidInput
    attendance?: RaidAttendanceUncheckedCreateNestedManyWithoutRaidInput
  }

  export type RaidUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_pvp?: BoolFieldUpdateOperationsInput | boolean
    is_pvp_long?: BoolFieldUpdateOperationsInput | boolean
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dkp_summary?: IntFieldUpdateOperationsInput | number
    raidBosses?: RaidBossUpdateManyWithoutRaidNestedInput
    attendance?: RaidAttendanceUpdateManyWithoutRaidNestedInput
  }

  export type RaidUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_pvp?: BoolFieldUpdateOperationsInput | boolean
    is_pvp_long?: BoolFieldUpdateOperationsInput | boolean
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dkp_summary?: IntFieldUpdateOperationsInput | number
    raidBosses?: RaidBossUncheckedUpdateManyWithoutRaidNestedInput
    attendance?: RaidAttendanceUncheckedUpdateManyWithoutRaidNestedInput
  }

  export type RaidCreateManyInput = {
    id?: number
    type?: string | null
    is_pvp?: boolean
    is_pvp_long?: boolean
    start_date?: Date | string | null
    created_at?: Date | string
    dkp_summary?: number
  }

  export type RaidUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_pvp?: BoolFieldUpdateOperationsInput | boolean
    is_pvp_long?: BoolFieldUpdateOperationsInput | boolean
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dkp_summary?: IntFieldUpdateOperationsInput | number
  }

  export type RaidUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_pvp?: BoolFieldUpdateOperationsInput | boolean
    is_pvp_long?: BoolFieldUpdateOperationsInput | boolean
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dkp_summary?: IntFieldUpdateOperationsInput | number
  }

  export type BossCreateInput = {
    boss_name: string
    dkp_points: number
    category: string
    raidBosses?: RaidBossCreateNestedManyWithoutBossInput
  }

  export type BossUncheckedCreateInput = {
    id?: number
    boss_name: string
    dkp_points: number
    category: string
    raidBosses?: RaidBossUncheckedCreateNestedManyWithoutBossInput
  }

  export type BossUpdateInput = {
    boss_name?: StringFieldUpdateOperationsInput | string
    dkp_points?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    raidBosses?: RaidBossUpdateManyWithoutBossNestedInput
  }

  export type BossUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    boss_name?: StringFieldUpdateOperationsInput | string
    dkp_points?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    raidBosses?: RaidBossUncheckedUpdateManyWithoutBossNestedInput
  }

  export type BossCreateManyInput = {
    id?: number
    boss_name: string
    dkp_points: number
    category: string
  }

  export type BossUpdateManyMutationInput = {
    boss_name?: StringFieldUpdateOperationsInput | string
    dkp_points?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type BossUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    boss_name?: StringFieldUpdateOperationsInput | string
    dkp_points?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type RaidBossCreateInput = {
    raid: RaidCreateNestedOneWithoutRaidBossesInput
    boss: BossCreateNestedOneWithoutRaidBossesInput
  }

  export type RaidBossUncheckedCreateInput = {
    raid_id: number
    boss_id: number
  }

  export type RaidBossUpdateInput = {
    raid?: RaidUpdateOneRequiredWithoutRaidBossesNestedInput
    boss?: BossUpdateOneRequiredWithoutRaidBossesNestedInput
  }

  export type RaidBossUncheckedUpdateInput = {
    raid_id?: IntFieldUpdateOperationsInput | number
    boss_id?: IntFieldUpdateOperationsInput | number
  }

  export type RaidBossCreateManyInput = {
    raid_id: number
    boss_id: number
  }

  export type RaidBossUpdateManyMutationInput = {

  }

  export type RaidBossUncheckedUpdateManyInput = {
    raid_id?: IntFieldUpdateOperationsInput | number
    boss_id?: IntFieldUpdateOperationsInput | number
  }

  export type RaidAttendanceCreateInput = {
    created_at: Date | string
    user: UserCreateNestedOneWithoutRaidAttendanceInput
    raid: RaidCreateNestedOneWithoutAttendanceInput
  }

  export type RaidAttendanceUncheckedCreateInput = {
    id?: number
    user_id: number
    raid_id: number
    created_at: Date | string
  }

  export type RaidAttendanceUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRaidAttendanceNestedInput
    raid?: RaidUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type RaidAttendanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    raid_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidAttendanceCreateManyInput = {
    id?: number
    user_id: number
    raid_id: number
    created_at: Date | string
  }

  export type RaidAttendanceUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidAttendanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    raid_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTypeCreateInput = {
    name: string
    price?: number | null
    loot?: LootCreateNestedManyWithoutItemTypeInput
    lootQueue?: LootQueueCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeUncheckedCreateInput = {
    id?: number
    name: string
    price?: number | null
    loot?: LootUncheckedCreateNestedManyWithoutItemTypeInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    loot?: LootUpdateManyWithoutItemTypeNestedInput
    lootQueue?: LootQueueUpdateManyWithoutItemTypeNestedInput
  }

  export type ItemTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    loot?: LootUncheckedUpdateManyWithoutItemTypeNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutItemTypeNestedInput
  }

  export type ItemTypeCreateManyInput = {
    id?: number
    name: string
    price?: number | null
  }

  export type ItemTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ItemTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LootCreateInput = {
    status: string
    acquired_at: Date | string
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    source?: string | null
    created_at?: Date | string
    itemType: ItemTypeCreateNestedOneWithoutLootInput
    soldToUser?: UserCreateNestedOneWithoutSoldLootInput
  }

  export type LootUncheckedCreateInput = {
    id?: number
    itemTypeId: number
    status: string
    acquired_at: Date | string
    sold_at?: Date | string | null
    sold_to?: string | null
    sold_to_user_id?: number | null
    comment?: string | null
    source?: string | null
    created_at?: Date | string
  }

  export type LootUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    itemType?: ItemTypeUpdateOneRequiredWithoutLootNestedInput
    soldToUser?: UserUpdateOneWithoutSoldLootNestedInput
  }

  export type LootUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    sold_to_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LootCreateManyInput = {
    id?: number
    itemTypeId: number
    status: string
    acquired_at: Date | string
    sold_at?: Date | string | null
    sold_to?: string | null
    sold_to_user_id?: number | null
    comment?: string | null
    source?: string | null
    created_at?: Date | string
  }

  export type LootUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LootUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    sold_to_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TasksUserCreateInput = {
    task: TasksCreateNestedOneWithoutAssignedToInput
    user: UserCreateNestedOneWithoutTasksAssignedInput
  }

  export type TasksUserUncheckedCreateInput = {
    tasks_user_id: number
    user_id: number
  }

  export type TasksUserUpdateInput = {
    task?: TasksUpdateOneRequiredWithoutAssignedToNestedInput
    user?: UserUpdateOneRequiredWithoutTasksAssignedNestedInput
  }

  export type TasksUserUncheckedUpdateInput = {
    tasks_user_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type TasksUserCreateManyInput = {
    tasks_user_id: number
    user_id: number
  }

  export type TasksUserUpdateManyMutationInput = {

  }

  export type TasksUserUncheckedUpdateManyInput = {
    tasks_user_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type LootQueueCreateInput = {
    status?: string
    synthTarget?: string | null
    remaining?: number | null
    created_at?: Date | string
    itemType: ItemTypeCreateNestedOneWithoutLootQueueInput
    user: UserCreateNestedOneWithoutLootQueueInput
  }

  export type LootQueueUncheckedCreateInput = {
    id?: number
    itemTypeId: number
    userId: number
    status?: string
    synthTarget?: string | null
    remaining?: number | null
    created_at?: Date | string
  }

  export type LootQueueUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    synthTarget?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    itemType?: ItemTypeUpdateOneRequiredWithoutLootQueueNestedInput
    user?: UserUpdateOneRequiredWithoutLootQueueNestedInput
  }

  export type LootQueueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    synthTarget?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LootQueueCreateManyInput = {
    id?: number
    itemTypeId: number
    userId: number
    status?: string
    synthTarget?: string | null
    remaining?: number | null
    created_at?: Date | string
  }

  export type LootQueueUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    synthTarget?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LootQueueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    synthTarget?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserInventoryListRelationFilter = {
    every?: UserInventoryWhereInput
    some?: UserInventoryWhereInput
    none?: UserInventoryWhereInput
  }

  export type TasksListRelationFilter = {
    every?: TasksWhereInput
    some?: TasksWhereInput
    none?: TasksWhereInput
  }

  export type RaidAttendanceListRelationFilter = {
    every?: RaidAttendanceWhereInput
    some?: RaidAttendanceWhereInput
    none?: RaidAttendanceWhereInput
  }

  export type TasksUserListRelationFilter = {
    every?: TasksUserWhereInput
    some?: TasksUserWhereInput
    none?: TasksUserWhereInput
  }

  export type UserTagsListRelationFilter = {
    every?: UserTagsWhereInput
    some?: UserTagsWhereInput
    none?: UserTagsWhereInput
  }

  export type LootListRelationFilter = {
    every?: LootWhereInput
    some?: LootWhereInput
    none?: LootWhereInput
  }

  export type LootQueueListRelationFilter = {
    every?: LootQueueWhereInput
    some?: LootQueueWhereInput
    none?: LootQueueWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserInventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TasksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaidAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TasksUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LootOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LootQueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    class?: SortOrder
    secondary_class?: SortOrder
    class_gear_score?: SortOrder
    secondary_class_gear_score?: SortOrder
    vk_name?: SortOrder
    active?: SortOrder
    is_eligible_for_salary?: SortOrder
    joined_at?: SortOrder
    created_at?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    class_gear_score?: SortOrder
    secondary_class_gear_score?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    class?: SortOrder
    secondary_class?: SortOrder
    class_gear_score?: SortOrder
    secondary_class_gear_score?: SortOrder
    vk_name?: SortOrder
    active?: SortOrder
    is_eligible_for_salary?: SortOrder
    joined_at?: SortOrder
    created_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    class?: SortOrder
    secondary_class?: SortOrder
    class_gear_score?: SortOrder
    secondary_class_gear_score?: SortOrder
    vk_name?: SortOrder
    active?: SortOrder
    is_eligible_for_salary?: SortOrder
    joined_at?: SortOrder
    created_at?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    class_gear_score?: SortOrder
    secondary_class_gear_score?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserTagsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    tag?: SortOrder
    created_at?: SortOrder
  }

  export type UserTagsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type UserTagsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    tag?: SortOrder
    created_at?: SortOrder
  }

  export type UserTagsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    tag?: SortOrder
    created_at?: SortOrder
  }

  export type UserTagsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type UserInventoryCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    quality?: SortOrder
    created_at?: SortOrder
  }

  export type UserInventoryAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type UserInventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    quality?: SortOrder
    created_at?: SortOrder
  }

  export type UserInventoryMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    quality?: SortOrder
    created_at?: SortOrder
  }

  export type UserInventorySumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type TasksCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
  }

  export type TasksAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type TasksMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
  }

  export type TasksMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
  }

  export type TasksSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type RaidBossListRelationFilter = {
    every?: RaidBossWhereInput
    some?: RaidBossWhereInput
    none?: RaidBossWhereInput
  }

  export type RaidBossOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaidCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    is_pvp?: SortOrder
    is_pvp_long?: SortOrder
    start_date?: SortOrder
    created_at?: SortOrder
    dkp_summary?: SortOrder
  }

  export type RaidAvgOrderByAggregateInput = {
    id?: SortOrder
    dkp_summary?: SortOrder
  }

  export type RaidMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    is_pvp?: SortOrder
    is_pvp_long?: SortOrder
    start_date?: SortOrder
    created_at?: SortOrder
    dkp_summary?: SortOrder
  }

  export type RaidMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    is_pvp?: SortOrder
    is_pvp_long?: SortOrder
    start_date?: SortOrder
    created_at?: SortOrder
    dkp_summary?: SortOrder
  }

  export type RaidSumOrderByAggregateInput = {
    id?: SortOrder
    dkp_summary?: SortOrder
  }

  export type BossCountOrderByAggregateInput = {
    id?: SortOrder
    boss_name?: SortOrder
    dkp_points?: SortOrder
    category?: SortOrder
  }

  export type BossAvgOrderByAggregateInput = {
    id?: SortOrder
    dkp_points?: SortOrder
  }

  export type BossMaxOrderByAggregateInput = {
    id?: SortOrder
    boss_name?: SortOrder
    dkp_points?: SortOrder
    category?: SortOrder
  }

  export type BossMinOrderByAggregateInput = {
    id?: SortOrder
    boss_name?: SortOrder
    dkp_points?: SortOrder
    category?: SortOrder
  }

  export type BossSumOrderByAggregateInput = {
    id?: SortOrder
    dkp_points?: SortOrder
  }

  export type RaidScalarRelationFilter = {
    is?: RaidWhereInput
    isNot?: RaidWhereInput
  }

  export type BossScalarRelationFilter = {
    is?: BossWhereInput
    isNot?: BossWhereInput
  }

  export type RaidBossRaid_idBoss_idCompoundUniqueInput = {
    raid_id: number
    boss_id: number
  }

  export type RaidBossCountOrderByAggregateInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
  }

  export type RaidBossAvgOrderByAggregateInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
  }

  export type RaidBossMaxOrderByAggregateInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
  }

  export type RaidBossMinOrderByAggregateInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
  }

  export type RaidBossSumOrderByAggregateInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
  }

  export type RaidAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
    created_at?: SortOrder
  }

  export type RaidAttendanceAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
  }

  export type RaidAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
    created_at?: SortOrder
  }

  export type RaidAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
    created_at?: SortOrder
  }

  export type RaidAttendanceSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ItemTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ItemTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type ItemTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ItemTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ItemTypeSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ItemTypeScalarRelationFilter = {
    is?: ItemTypeWhereInput
    isNot?: ItemTypeWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LootCountOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    status?: SortOrder
    acquired_at?: SortOrder
    sold_at?: SortOrder
    sold_to?: SortOrder
    sold_to_user_id?: SortOrder
    comment?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type LootAvgOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    sold_to_user_id?: SortOrder
  }

  export type LootMaxOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    status?: SortOrder
    acquired_at?: SortOrder
    sold_at?: SortOrder
    sold_to?: SortOrder
    sold_to_user_id?: SortOrder
    comment?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type LootMinOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    status?: SortOrder
    acquired_at?: SortOrder
    sold_at?: SortOrder
    sold_to?: SortOrder
    sold_to_user_id?: SortOrder
    comment?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
  }

  export type LootSumOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    sold_to_user_id?: SortOrder
  }

  export type TasksScalarRelationFilter = {
    is?: TasksWhereInput
    isNot?: TasksWhereInput
  }

  export type TasksUserTasks_user_idUser_idCompoundUniqueInput = {
    tasks_user_id: number
    user_id: number
  }

  export type TasksUserCountOrderByAggregateInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
  }

  export type TasksUserAvgOrderByAggregateInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
  }

  export type TasksUserMaxOrderByAggregateInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
  }

  export type TasksUserMinOrderByAggregateInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
  }

  export type TasksUserSumOrderByAggregateInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
  }

  export type LootQueueCountOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    synthTarget?: SortOrder
    remaining?: SortOrder
    created_at?: SortOrder
  }

  export type LootQueueAvgOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    remaining?: SortOrder
  }

  export type LootQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    synthTarget?: SortOrder
    remaining?: SortOrder
    created_at?: SortOrder
  }

  export type LootQueueMinOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    synthTarget?: SortOrder
    remaining?: SortOrder
    created_at?: SortOrder
  }

  export type LootQueueSumOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    remaining?: SortOrder
  }

  export type UserInventoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInventoryCreateWithoutUserInput, UserInventoryUncheckedCreateWithoutUserInput> | UserInventoryCreateWithoutUserInput[] | UserInventoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryCreateOrConnectWithoutUserInput | UserInventoryCreateOrConnectWithoutUserInput[]
    createMany?: UserInventoryCreateManyUserInputEnvelope
    connect?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
  }

  export type TasksCreateNestedManyWithoutUserInput = {
    create?: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput> | TasksCreateWithoutUserInput[] | TasksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutUserInput | TasksCreateOrConnectWithoutUserInput[]
    createMany?: TasksCreateManyUserInputEnvelope
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
  }

  export type RaidAttendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<RaidAttendanceCreateWithoutUserInput, RaidAttendanceUncheckedCreateWithoutUserInput> | RaidAttendanceCreateWithoutUserInput[] | RaidAttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutUserInput | RaidAttendanceCreateOrConnectWithoutUserInput[]
    createMany?: RaidAttendanceCreateManyUserInputEnvelope
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
  }

  export type TasksUserCreateNestedManyWithoutUserInput = {
    create?: XOR<TasksUserCreateWithoutUserInput, TasksUserUncheckedCreateWithoutUserInput> | TasksUserCreateWithoutUserInput[] | TasksUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutUserInput | TasksUserCreateOrConnectWithoutUserInput[]
    createMany?: TasksUserCreateManyUserInputEnvelope
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
  }

  export type UserTagsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput> | UserTagsCreateWithoutUserInput[] | UserTagsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutUserInput | UserTagsCreateOrConnectWithoutUserInput[]
    createMany?: UserTagsCreateManyUserInputEnvelope
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
  }

  export type LootCreateNestedManyWithoutSoldToUserInput = {
    create?: XOR<LootCreateWithoutSoldToUserInput, LootUncheckedCreateWithoutSoldToUserInput> | LootCreateWithoutSoldToUserInput[] | LootUncheckedCreateWithoutSoldToUserInput[]
    connectOrCreate?: LootCreateOrConnectWithoutSoldToUserInput | LootCreateOrConnectWithoutSoldToUserInput[]
    createMany?: LootCreateManySoldToUserInputEnvelope
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
  }

  export type LootQueueCreateNestedManyWithoutUserInput = {
    create?: XOR<LootQueueCreateWithoutUserInput, LootQueueUncheckedCreateWithoutUserInput> | LootQueueCreateWithoutUserInput[] | LootQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutUserInput | LootQueueCreateOrConnectWithoutUserInput[]
    createMany?: LootQueueCreateManyUserInputEnvelope
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
  }

  export type UserInventoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInventoryCreateWithoutUserInput, UserInventoryUncheckedCreateWithoutUserInput> | UserInventoryCreateWithoutUserInput[] | UserInventoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryCreateOrConnectWithoutUserInput | UserInventoryCreateOrConnectWithoutUserInput[]
    createMany?: UserInventoryCreateManyUserInputEnvelope
    connect?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
  }

  export type TasksUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput> | TasksCreateWithoutUserInput[] | TasksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutUserInput | TasksCreateOrConnectWithoutUserInput[]
    createMany?: TasksCreateManyUserInputEnvelope
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
  }

  export type RaidAttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RaidAttendanceCreateWithoutUserInput, RaidAttendanceUncheckedCreateWithoutUserInput> | RaidAttendanceCreateWithoutUserInput[] | RaidAttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutUserInput | RaidAttendanceCreateOrConnectWithoutUserInput[]
    createMany?: RaidAttendanceCreateManyUserInputEnvelope
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
  }

  export type TasksUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TasksUserCreateWithoutUserInput, TasksUserUncheckedCreateWithoutUserInput> | TasksUserCreateWithoutUserInput[] | TasksUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutUserInput | TasksUserCreateOrConnectWithoutUserInput[]
    createMany?: TasksUserCreateManyUserInputEnvelope
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
  }

  export type UserTagsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput> | UserTagsCreateWithoutUserInput[] | UserTagsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutUserInput | UserTagsCreateOrConnectWithoutUserInput[]
    createMany?: UserTagsCreateManyUserInputEnvelope
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
  }

  export type LootUncheckedCreateNestedManyWithoutSoldToUserInput = {
    create?: XOR<LootCreateWithoutSoldToUserInput, LootUncheckedCreateWithoutSoldToUserInput> | LootCreateWithoutSoldToUserInput[] | LootUncheckedCreateWithoutSoldToUserInput[]
    connectOrCreate?: LootCreateOrConnectWithoutSoldToUserInput | LootCreateOrConnectWithoutSoldToUserInput[]
    createMany?: LootCreateManySoldToUserInputEnvelope
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
  }

  export type LootQueueUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LootQueueCreateWithoutUserInput, LootQueueUncheckedCreateWithoutUserInput> | LootQueueCreateWithoutUserInput[] | LootQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutUserInput | LootQueueCreateOrConnectWithoutUserInput[]
    createMany?: LootQueueCreateManyUserInputEnvelope
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserInventoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInventoryCreateWithoutUserInput, UserInventoryUncheckedCreateWithoutUserInput> | UserInventoryCreateWithoutUserInput[] | UserInventoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryCreateOrConnectWithoutUserInput | UserInventoryCreateOrConnectWithoutUserInput[]
    upsert?: UserInventoryUpsertWithWhereUniqueWithoutUserInput | UserInventoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInventoryCreateManyUserInputEnvelope
    set?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    disconnect?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    delete?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    connect?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    update?: UserInventoryUpdateWithWhereUniqueWithoutUserInput | UserInventoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInventoryUpdateManyWithWhereWithoutUserInput | UserInventoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInventoryScalarWhereInput | UserInventoryScalarWhereInput[]
  }

  export type TasksUpdateManyWithoutUserNestedInput = {
    create?: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput> | TasksCreateWithoutUserInput[] | TasksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutUserInput | TasksCreateOrConnectWithoutUserInput[]
    upsert?: TasksUpsertWithWhereUniqueWithoutUserInput | TasksUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TasksCreateManyUserInputEnvelope
    set?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    disconnect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    delete?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    update?: TasksUpdateWithWhereUniqueWithoutUserInput | TasksUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TasksUpdateManyWithWhereWithoutUserInput | TasksUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TasksScalarWhereInput | TasksScalarWhereInput[]
  }

  export type RaidAttendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<RaidAttendanceCreateWithoutUserInput, RaidAttendanceUncheckedCreateWithoutUserInput> | RaidAttendanceCreateWithoutUserInput[] | RaidAttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutUserInput | RaidAttendanceCreateOrConnectWithoutUserInput[]
    upsert?: RaidAttendanceUpsertWithWhereUniqueWithoutUserInput | RaidAttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RaidAttendanceCreateManyUserInputEnvelope
    set?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    disconnect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    delete?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    update?: RaidAttendanceUpdateWithWhereUniqueWithoutUserInput | RaidAttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RaidAttendanceUpdateManyWithWhereWithoutUserInput | RaidAttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RaidAttendanceScalarWhereInput | RaidAttendanceScalarWhereInput[]
  }

  export type TasksUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<TasksUserCreateWithoutUserInput, TasksUserUncheckedCreateWithoutUserInput> | TasksUserCreateWithoutUserInput[] | TasksUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutUserInput | TasksUserCreateOrConnectWithoutUserInput[]
    upsert?: TasksUserUpsertWithWhereUniqueWithoutUserInput | TasksUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TasksUserCreateManyUserInputEnvelope
    set?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    disconnect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    delete?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    update?: TasksUserUpdateWithWhereUniqueWithoutUserInput | TasksUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TasksUserUpdateManyWithWhereWithoutUserInput | TasksUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TasksUserScalarWhereInput | TasksUserScalarWhereInput[]
  }

  export type UserTagsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput> | UserTagsCreateWithoutUserInput[] | UserTagsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutUserInput | UserTagsCreateOrConnectWithoutUserInput[]
    upsert?: UserTagsUpsertWithWhereUniqueWithoutUserInput | UserTagsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTagsCreateManyUserInputEnvelope
    set?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    disconnect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    delete?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    update?: UserTagsUpdateWithWhereUniqueWithoutUserInput | UserTagsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTagsUpdateManyWithWhereWithoutUserInput | UserTagsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
  }

  export type LootUpdateManyWithoutSoldToUserNestedInput = {
    create?: XOR<LootCreateWithoutSoldToUserInput, LootUncheckedCreateWithoutSoldToUserInput> | LootCreateWithoutSoldToUserInput[] | LootUncheckedCreateWithoutSoldToUserInput[]
    connectOrCreate?: LootCreateOrConnectWithoutSoldToUserInput | LootCreateOrConnectWithoutSoldToUserInput[]
    upsert?: LootUpsertWithWhereUniqueWithoutSoldToUserInput | LootUpsertWithWhereUniqueWithoutSoldToUserInput[]
    createMany?: LootCreateManySoldToUserInputEnvelope
    set?: LootWhereUniqueInput | LootWhereUniqueInput[]
    disconnect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    delete?: LootWhereUniqueInput | LootWhereUniqueInput[]
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    update?: LootUpdateWithWhereUniqueWithoutSoldToUserInput | LootUpdateWithWhereUniqueWithoutSoldToUserInput[]
    updateMany?: LootUpdateManyWithWhereWithoutSoldToUserInput | LootUpdateManyWithWhereWithoutSoldToUserInput[]
    deleteMany?: LootScalarWhereInput | LootScalarWhereInput[]
  }

  export type LootQueueUpdateManyWithoutUserNestedInput = {
    create?: XOR<LootQueueCreateWithoutUserInput, LootQueueUncheckedCreateWithoutUserInput> | LootQueueCreateWithoutUserInput[] | LootQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutUserInput | LootQueueCreateOrConnectWithoutUserInput[]
    upsert?: LootQueueUpsertWithWhereUniqueWithoutUserInput | LootQueueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LootQueueCreateManyUserInputEnvelope
    set?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    disconnect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    delete?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    update?: LootQueueUpdateWithWhereUniqueWithoutUserInput | LootQueueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LootQueueUpdateManyWithWhereWithoutUserInput | LootQueueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LootQueueScalarWhereInput | LootQueueScalarWhereInput[]
  }

  export type UserInventoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInventoryCreateWithoutUserInput, UserInventoryUncheckedCreateWithoutUserInput> | UserInventoryCreateWithoutUserInput[] | UserInventoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryCreateOrConnectWithoutUserInput | UserInventoryCreateOrConnectWithoutUserInput[]
    upsert?: UserInventoryUpsertWithWhereUniqueWithoutUserInput | UserInventoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInventoryCreateManyUserInputEnvelope
    set?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    disconnect?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    delete?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    connect?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    update?: UserInventoryUpdateWithWhereUniqueWithoutUserInput | UserInventoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInventoryUpdateManyWithWhereWithoutUserInput | UserInventoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInventoryScalarWhereInput | UserInventoryScalarWhereInput[]
  }

  export type TasksUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput> | TasksCreateWithoutUserInput[] | TasksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutUserInput | TasksCreateOrConnectWithoutUserInput[]
    upsert?: TasksUpsertWithWhereUniqueWithoutUserInput | TasksUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TasksCreateManyUserInputEnvelope
    set?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    disconnect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    delete?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    update?: TasksUpdateWithWhereUniqueWithoutUserInput | TasksUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TasksUpdateManyWithWhereWithoutUserInput | TasksUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TasksScalarWhereInput | TasksScalarWhereInput[]
  }

  export type RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RaidAttendanceCreateWithoutUserInput, RaidAttendanceUncheckedCreateWithoutUserInput> | RaidAttendanceCreateWithoutUserInput[] | RaidAttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutUserInput | RaidAttendanceCreateOrConnectWithoutUserInput[]
    upsert?: RaidAttendanceUpsertWithWhereUniqueWithoutUserInput | RaidAttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RaidAttendanceCreateManyUserInputEnvelope
    set?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    disconnect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    delete?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    update?: RaidAttendanceUpdateWithWhereUniqueWithoutUserInput | RaidAttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RaidAttendanceUpdateManyWithWhereWithoutUserInput | RaidAttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RaidAttendanceScalarWhereInput | RaidAttendanceScalarWhereInput[]
  }

  export type TasksUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TasksUserCreateWithoutUserInput, TasksUserUncheckedCreateWithoutUserInput> | TasksUserCreateWithoutUserInput[] | TasksUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutUserInput | TasksUserCreateOrConnectWithoutUserInput[]
    upsert?: TasksUserUpsertWithWhereUniqueWithoutUserInput | TasksUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TasksUserCreateManyUserInputEnvelope
    set?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    disconnect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    delete?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    update?: TasksUserUpdateWithWhereUniqueWithoutUserInput | TasksUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TasksUserUpdateManyWithWhereWithoutUserInput | TasksUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TasksUserScalarWhereInput | TasksUserScalarWhereInput[]
  }

  export type UserTagsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput> | UserTagsCreateWithoutUserInput[] | UserTagsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutUserInput | UserTagsCreateOrConnectWithoutUserInput[]
    upsert?: UserTagsUpsertWithWhereUniqueWithoutUserInput | UserTagsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTagsCreateManyUserInputEnvelope
    set?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    disconnect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    delete?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    update?: UserTagsUpdateWithWhereUniqueWithoutUserInput | UserTagsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTagsUpdateManyWithWhereWithoutUserInput | UserTagsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
  }

  export type LootUncheckedUpdateManyWithoutSoldToUserNestedInput = {
    create?: XOR<LootCreateWithoutSoldToUserInput, LootUncheckedCreateWithoutSoldToUserInput> | LootCreateWithoutSoldToUserInput[] | LootUncheckedCreateWithoutSoldToUserInput[]
    connectOrCreate?: LootCreateOrConnectWithoutSoldToUserInput | LootCreateOrConnectWithoutSoldToUserInput[]
    upsert?: LootUpsertWithWhereUniqueWithoutSoldToUserInput | LootUpsertWithWhereUniqueWithoutSoldToUserInput[]
    createMany?: LootCreateManySoldToUserInputEnvelope
    set?: LootWhereUniqueInput | LootWhereUniqueInput[]
    disconnect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    delete?: LootWhereUniqueInput | LootWhereUniqueInput[]
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    update?: LootUpdateWithWhereUniqueWithoutSoldToUserInput | LootUpdateWithWhereUniqueWithoutSoldToUserInput[]
    updateMany?: LootUpdateManyWithWhereWithoutSoldToUserInput | LootUpdateManyWithWhereWithoutSoldToUserInput[]
    deleteMany?: LootScalarWhereInput | LootScalarWhereInput[]
  }

  export type LootQueueUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LootQueueCreateWithoutUserInput, LootQueueUncheckedCreateWithoutUserInput> | LootQueueCreateWithoutUserInput[] | LootQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutUserInput | LootQueueCreateOrConnectWithoutUserInput[]
    upsert?: LootQueueUpsertWithWhereUniqueWithoutUserInput | LootQueueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LootQueueCreateManyUserInputEnvelope
    set?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    disconnect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    delete?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    update?: LootQueueUpdateWithWhereUniqueWithoutUserInput | LootQueueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LootQueueUpdateManyWithWhereWithoutUserInput | LootQueueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LootQueueScalarWhereInput | LootQueueScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTagsInput = {
    create?: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagsInput
    upsert?: UserUpsertWithoutTagsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTagsInput, UserUpdateWithoutTagsInput>, UserUncheckedUpdateWithoutTagsInput>
  }

  export type UserCreateNestedOneWithoutInventoryInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    upsert?: UserUpsertWithoutInventoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryInput, UserUpdateWithoutInventoryInput>, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    connect?: UserWhereUniqueInput
  }

  export type TasksUserCreateNestedManyWithoutTaskInput = {
    create?: XOR<TasksUserCreateWithoutTaskInput, TasksUserUncheckedCreateWithoutTaskInput> | TasksUserCreateWithoutTaskInput[] | TasksUserUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutTaskInput | TasksUserCreateOrConnectWithoutTaskInput[]
    createMany?: TasksUserCreateManyTaskInputEnvelope
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
  }

  export type TasksUserUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TasksUserCreateWithoutTaskInput, TasksUserUncheckedCreateWithoutTaskInput> | TasksUserCreateWithoutTaskInput[] | TasksUserUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutTaskInput | TasksUserCreateOrConnectWithoutTaskInput[]
    createMany?: TasksUserCreateManyTaskInputEnvelope
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    upsert?: UserUpsertWithoutTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksInput, UserUpdateWithoutTasksInput>, UserUncheckedUpdateWithoutTasksInput>
  }

  export type TasksUserUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TasksUserCreateWithoutTaskInput, TasksUserUncheckedCreateWithoutTaskInput> | TasksUserCreateWithoutTaskInput[] | TasksUserUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutTaskInput | TasksUserCreateOrConnectWithoutTaskInput[]
    upsert?: TasksUserUpsertWithWhereUniqueWithoutTaskInput | TasksUserUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TasksUserCreateManyTaskInputEnvelope
    set?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    disconnect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    delete?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    update?: TasksUserUpdateWithWhereUniqueWithoutTaskInput | TasksUserUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TasksUserUpdateManyWithWhereWithoutTaskInput | TasksUserUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TasksUserScalarWhereInput | TasksUserScalarWhereInput[]
  }

  export type TasksUserUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TasksUserCreateWithoutTaskInput, TasksUserUncheckedCreateWithoutTaskInput> | TasksUserCreateWithoutTaskInput[] | TasksUserUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutTaskInput | TasksUserCreateOrConnectWithoutTaskInput[]
    upsert?: TasksUserUpsertWithWhereUniqueWithoutTaskInput | TasksUserUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TasksUserCreateManyTaskInputEnvelope
    set?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    disconnect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    delete?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    update?: TasksUserUpdateWithWhereUniqueWithoutTaskInput | TasksUserUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TasksUserUpdateManyWithWhereWithoutTaskInput | TasksUserUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TasksUserScalarWhereInput | TasksUserScalarWhereInput[]
  }

  export type RaidBossCreateNestedManyWithoutRaidInput = {
    create?: XOR<RaidBossCreateWithoutRaidInput, RaidBossUncheckedCreateWithoutRaidInput> | RaidBossCreateWithoutRaidInput[] | RaidBossUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutRaidInput | RaidBossCreateOrConnectWithoutRaidInput[]
    createMany?: RaidBossCreateManyRaidInputEnvelope
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
  }

  export type RaidAttendanceCreateNestedManyWithoutRaidInput = {
    create?: XOR<RaidAttendanceCreateWithoutRaidInput, RaidAttendanceUncheckedCreateWithoutRaidInput> | RaidAttendanceCreateWithoutRaidInput[] | RaidAttendanceUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutRaidInput | RaidAttendanceCreateOrConnectWithoutRaidInput[]
    createMany?: RaidAttendanceCreateManyRaidInputEnvelope
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
  }

  export type RaidBossUncheckedCreateNestedManyWithoutRaidInput = {
    create?: XOR<RaidBossCreateWithoutRaidInput, RaidBossUncheckedCreateWithoutRaidInput> | RaidBossCreateWithoutRaidInput[] | RaidBossUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutRaidInput | RaidBossCreateOrConnectWithoutRaidInput[]
    createMany?: RaidBossCreateManyRaidInputEnvelope
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
  }

  export type RaidAttendanceUncheckedCreateNestedManyWithoutRaidInput = {
    create?: XOR<RaidAttendanceCreateWithoutRaidInput, RaidAttendanceUncheckedCreateWithoutRaidInput> | RaidAttendanceCreateWithoutRaidInput[] | RaidAttendanceUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutRaidInput | RaidAttendanceCreateOrConnectWithoutRaidInput[]
    createMany?: RaidAttendanceCreateManyRaidInputEnvelope
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
  }

  export type RaidBossUpdateManyWithoutRaidNestedInput = {
    create?: XOR<RaidBossCreateWithoutRaidInput, RaidBossUncheckedCreateWithoutRaidInput> | RaidBossCreateWithoutRaidInput[] | RaidBossUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutRaidInput | RaidBossCreateOrConnectWithoutRaidInput[]
    upsert?: RaidBossUpsertWithWhereUniqueWithoutRaidInput | RaidBossUpsertWithWhereUniqueWithoutRaidInput[]
    createMany?: RaidBossCreateManyRaidInputEnvelope
    set?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    disconnect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    delete?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    update?: RaidBossUpdateWithWhereUniqueWithoutRaidInput | RaidBossUpdateWithWhereUniqueWithoutRaidInput[]
    updateMany?: RaidBossUpdateManyWithWhereWithoutRaidInput | RaidBossUpdateManyWithWhereWithoutRaidInput[]
    deleteMany?: RaidBossScalarWhereInput | RaidBossScalarWhereInput[]
  }

  export type RaidAttendanceUpdateManyWithoutRaidNestedInput = {
    create?: XOR<RaidAttendanceCreateWithoutRaidInput, RaidAttendanceUncheckedCreateWithoutRaidInput> | RaidAttendanceCreateWithoutRaidInput[] | RaidAttendanceUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutRaidInput | RaidAttendanceCreateOrConnectWithoutRaidInput[]
    upsert?: RaidAttendanceUpsertWithWhereUniqueWithoutRaidInput | RaidAttendanceUpsertWithWhereUniqueWithoutRaidInput[]
    createMany?: RaidAttendanceCreateManyRaidInputEnvelope
    set?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    disconnect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    delete?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    update?: RaidAttendanceUpdateWithWhereUniqueWithoutRaidInput | RaidAttendanceUpdateWithWhereUniqueWithoutRaidInput[]
    updateMany?: RaidAttendanceUpdateManyWithWhereWithoutRaidInput | RaidAttendanceUpdateManyWithWhereWithoutRaidInput[]
    deleteMany?: RaidAttendanceScalarWhereInput | RaidAttendanceScalarWhereInput[]
  }

  export type RaidBossUncheckedUpdateManyWithoutRaidNestedInput = {
    create?: XOR<RaidBossCreateWithoutRaidInput, RaidBossUncheckedCreateWithoutRaidInput> | RaidBossCreateWithoutRaidInput[] | RaidBossUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutRaidInput | RaidBossCreateOrConnectWithoutRaidInput[]
    upsert?: RaidBossUpsertWithWhereUniqueWithoutRaidInput | RaidBossUpsertWithWhereUniqueWithoutRaidInput[]
    createMany?: RaidBossCreateManyRaidInputEnvelope
    set?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    disconnect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    delete?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    update?: RaidBossUpdateWithWhereUniqueWithoutRaidInput | RaidBossUpdateWithWhereUniqueWithoutRaidInput[]
    updateMany?: RaidBossUpdateManyWithWhereWithoutRaidInput | RaidBossUpdateManyWithWhereWithoutRaidInput[]
    deleteMany?: RaidBossScalarWhereInput | RaidBossScalarWhereInput[]
  }

  export type RaidAttendanceUncheckedUpdateManyWithoutRaidNestedInput = {
    create?: XOR<RaidAttendanceCreateWithoutRaidInput, RaidAttendanceUncheckedCreateWithoutRaidInput> | RaidAttendanceCreateWithoutRaidInput[] | RaidAttendanceUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutRaidInput | RaidAttendanceCreateOrConnectWithoutRaidInput[]
    upsert?: RaidAttendanceUpsertWithWhereUniqueWithoutRaidInput | RaidAttendanceUpsertWithWhereUniqueWithoutRaidInput[]
    createMany?: RaidAttendanceCreateManyRaidInputEnvelope
    set?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    disconnect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    delete?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    update?: RaidAttendanceUpdateWithWhereUniqueWithoutRaidInput | RaidAttendanceUpdateWithWhereUniqueWithoutRaidInput[]
    updateMany?: RaidAttendanceUpdateManyWithWhereWithoutRaidInput | RaidAttendanceUpdateManyWithWhereWithoutRaidInput[]
    deleteMany?: RaidAttendanceScalarWhereInput | RaidAttendanceScalarWhereInput[]
  }

  export type RaidBossCreateNestedManyWithoutBossInput = {
    create?: XOR<RaidBossCreateWithoutBossInput, RaidBossUncheckedCreateWithoutBossInput> | RaidBossCreateWithoutBossInput[] | RaidBossUncheckedCreateWithoutBossInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutBossInput | RaidBossCreateOrConnectWithoutBossInput[]
    createMany?: RaidBossCreateManyBossInputEnvelope
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
  }

  export type RaidBossUncheckedCreateNestedManyWithoutBossInput = {
    create?: XOR<RaidBossCreateWithoutBossInput, RaidBossUncheckedCreateWithoutBossInput> | RaidBossCreateWithoutBossInput[] | RaidBossUncheckedCreateWithoutBossInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutBossInput | RaidBossCreateOrConnectWithoutBossInput[]
    createMany?: RaidBossCreateManyBossInputEnvelope
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
  }

  export type RaidBossUpdateManyWithoutBossNestedInput = {
    create?: XOR<RaidBossCreateWithoutBossInput, RaidBossUncheckedCreateWithoutBossInput> | RaidBossCreateWithoutBossInput[] | RaidBossUncheckedCreateWithoutBossInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutBossInput | RaidBossCreateOrConnectWithoutBossInput[]
    upsert?: RaidBossUpsertWithWhereUniqueWithoutBossInput | RaidBossUpsertWithWhereUniqueWithoutBossInput[]
    createMany?: RaidBossCreateManyBossInputEnvelope
    set?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    disconnect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    delete?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    update?: RaidBossUpdateWithWhereUniqueWithoutBossInput | RaidBossUpdateWithWhereUniqueWithoutBossInput[]
    updateMany?: RaidBossUpdateManyWithWhereWithoutBossInput | RaidBossUpdateManyWithWhereWithoutBossInput[]
    deleteMany?: RaidBossScalarWhereInput | RaidBossScalarWhereInput[]
  }

  export type RaidBossUncheckedUpdateManyWithoutBossNestedInput = {
    create?: XOR<RaidBossCreateWithoutBossInput, RaidBossUncheckedCreateWithoutBossInput> | RaidBossCreateWithoutBossInput[] | RaidBossUncheckedCreateWithoutBossInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutBossInput | RaidBossCreateOrConnectWithoutBossInput[]
    upsert?: RaidBossUpsertWithWhereUniqueWithoutBossInput | RaidBossUpsertWithWhereUniqueWithoutBossInput[]
    createMany?: RaidBossCreateManyBossInputEnvelope
    set?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    disconnect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    delete?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    update?: RaidBossUpdateWithWhereUniqueWithoutBossInput | RaidBossUpdateWithWhereUniqueWithoutBossInput[]
    updateMany?: RaidBossUpdateManyWithWhereWithoutBossInput | RaidBossUpdateManyWithWhereWithoutBossInput[]
    deleteMany?: RaidBossScalarWhereInput | RaidBossScalarWhereInput[]
  }

  export type RaidCreateNestedOneWithoutRaidBossesInput = {
    create?: XOR<RaidCreateWithoutRaidBossesInput, RaidUncheckedCreateWithoutRaidBossesInput>
    connectOrCreate?: RaidCreateOrConnectWithoutRaidBossesInput
    connect?: RaidWhereUniqueInput
  }

  export type BossCreateNestedOneWithoutRaidBossesInput = {
    create?: XOR<BossCreateWithoutRaidBossesInput, BossUncheckedCreateWithoutRaidBossesInput>
    connectOrCreate?: BossCreateOrConnectWithoutRaidBossesInput
    connect?: BossWhereUniqueInput
  }

  export type RaidUpdateOneRequiredWithoutRaidBossesNestedInput = {
    create?: XOR<RaidCreateWithoutRaidBossesInput, RaidUncheckedCreateWithoutRaidBossesInput>
    connectOrCreate?: RaidCreateOrConnectWithoutRaidBossesInput
    upsert?: RaidUpsertWithoutRaidBossesInput
    connect?: RaidWhereUniqueInput
    update?: XOR<XOR<RaidUpdateToOneWithWhereWithoutRaidBossesInput, RaidUpdateWithoutRaidBossesInput>, RaidUncheckedUpdateWithoutRaidBossesInput>
  }

  export type BossUpdateOneRequiredWithoutRaidBossesNestedInput = {
    create?: XOR<BossCreateWithoutRaidBossesInput, BossUncheckedCreateWithoutRaidBossesInput>
    connectOrCreate?: BossCreateOrConnectWithoutRaidBossesInput
    upsert?: BossUpsertWithoutRaidBossesInput
    connect?: BossWhereUniqueInput
    update?: XOR<XOR<BossUpdateToOneWithWhereWithoutRaidBossesInput, BossUpdateWithoutRaidBossesInput>, BossUncheckedUpdateWithoutRaidBossesInput>
  }

  export type UserCreateNestedOneWithoutRaidAttendanceInput = {
    create?: XOR<UserCreateWithoutRaidAttendanceInput, UserUncheckedCreateWithoutRaidAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutRaidAttendanceInput
    connect?: UserWhereUniqueInput
  }

  export type RaidCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<RaidCreateWithoutAttendanceInput, RaidUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: RaidCreateOrConnectWithoutAttendanceInput
    connect?: RaidWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRaidAttendanceNestedInput = {
    create?: XOR<UserCreateWithoutRaidAttendanceInput, UserUncheckedCreateWithoutRaidAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutRaidAttendanceInput
    upsert?: UserUpsertWithoutRaidAttendanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRaidAttendanceInput, UserUpdateWithoutRaidAttendanceInput>, UserUncheckedUpdateWithoutRaidAttendanceInput>
  }

  export type RaidUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<RaidCreateWithoutAttendanceInput, RaidUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: RaidCreateOrConnectWithoutAttendanceInput
    upsert?: RaidUpsertWithoutAttendanceInput
    connect?: RaidWhereUniqueInput
    update?: XOR<XOR<RaidUpdateToOneWithWhereWithoutAttendanceInput, RaidUpdateWithoutAttendanceInput>, RaidUncheckedUpdateWithoutAttendanceInput>
  }

  export type LootCreateNestedManyWithoutItemTypeInput = {
    create?: XOR<LootCreateWithoutItemTypeInput, LootUncheckedCreateWithoutItemTypeInput> | LootCreateWithoutItemTypeInput[] | LootUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootCreateOrConnectWithoutItemTypeInput | LootCreateOrConnectWithoutItemTypeInput[]
    createMany?: LootCreateManyItemTypeInputEnvelope
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
  }

  export type LootQueueCreateNestedManyWithoutItemTypeInput = {
    create?: XOR<LootQueueCreateWithoutItemTypeInput, LootQueueUncheckedCreateWithoutItemTypeInput> | LootQueueCreateWithoutItemTypeInput[] | LootQueueUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutItemTypeInput | LootQueueCreateOrConnectWithoutItemTypeInput[]
    createMany?: LootQueueCreateManyItemTypeInputEnvelope
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
  }

  export type LootUncheckedCreateNestedManyWithoutItemTypeInput = {
    create?: XOR<LootCreateWithoutItemTypeInput, LootUncheckedCreateWithoutItemTypeInput> | LootCreateWithoutItemTypeInput[] | LootUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootCreateOrConnectWithoutItemTypeInput | LootCreateOrConnectWithoutItemTypeInput[]
    createMany?: LootCreateManyItemTypeInputEnvelope
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
  }

  export type LootQueueUncheckedCreateNestedManyWithoutItemTypeInput = {
    create?: XOR<LootQueueCreateWithoutItemTypeInput, LootQueueUncheckedCreateWithoutItemTypeInput> | LootQueueCreateWithoutItemTypeInput[] | LootQueueUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutItemTypeInput | LootQueueCreateOrConnectWithoutItemTypeInput[]
    createMany?: LootQueueCreateManyItemTypeInputEnvelope
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LootUpdateManyWithoutItemTypeNestedInput = {
    create?: XOR<LootCreateWithoutItemTypeInput, LootUncheckedCreateWithoutItemTypeInput> | LootCreateWithoutItemTypeInput[] | LootUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootCreateOrConnectWithoutItemTypeInput | LootCreateOrConnectWithoutItemTypeInput[]
    upsert?: LootUpsertWithWhereUniqueWithoutItemTypeInput | LootUpsertWithWhereUniqueWithoutItemTypeInput[]
    createMany?: LootCreateManyItemTypeInputEnvelope
    set?: LootWhereUniqueInput | LootWhereUniqueInput[]
    disconnect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    delete?: LootWhereUniqueInput | LootWhereUniqueInput[]
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    update?: LootUpdateWithWhereUniqueWithoutItemTypeInput | LootUpdateWithWhereUniqueWithoutItemTypeInput[]
    updateMany?: LootUpdateManyWithWhereWithoutItemTypeInput | LootUpdateManyWithWhereWithoutItemTypeInput[]
    deleteMany?: LootScalarWhereInput | LootScalarWhereInput[]
  }

  export type LootQueueUpdateManyWithoutItemTypeNestedInput = {
    create?: XOR<LootQueueCreateWithoutItemTypeInput, LootQueueUncheckedCreateWithoutItemTypeInput> | LootQueueCreateWithoutItemTypeInput[] | LootQueueUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutItemTypeInput | LootQueueCreateOrConnectWithoutItemTypeInput[]
    upsert?: LootQueueUpsertWithWhereUniqueWithoutItemTypeInput | LootQueueUpsertWithWhereUniqueWithoutItemTypeInput[]
    createMany?: LootQueueCreateManyItemTypeInputEnvelope
    set?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    disconnect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    delete?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    update?: LootQueueUpdateWithWhereUniqueWithoutItemTypeInput | LootQueueUpdateWithWhereUniqueWithoutItemTypeInput[]
    updateMany?: LootQueueUpdateManyWithWhereWithoutItemTypeInput | LootQueueUpdateManyWithWhereWithoutItemTypeInput[]
    deleteMany?: LootQueueScalarWhereInput | LootQueueScalarWhereInput[]
  }

  export type LootUncheckedUpdateManyWithoutItemTypeNestedInput = {
    create?: XOR<LootCreateWithoutItemTypeInput, LootUncheckedCreateWithoutItemTypeInput> | LootCreateWithoutItemTypeInput[] | LootUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootCreateOrConnectWithoutItemTypeInput | LootCreateOrConnectWithoutItemTypeInput[]
    upsert?: LootUpsertWithWhereUniqueWithoutItemTypeInput | LootUpsertWithWhereUniqueWithoutItemTypeInput[]
    createMany?: LootCreateManyItemTypeInputEnvelope
    set?: LootWhereUniqueInput | LootWhereUniqueInput[]
    disconnect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    delete?: LootWhereUniqueInput | LootWhereUniqueInput[]
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    update?: LootUpdateWithWhereUniqueWithoutItemTypeInput | LootUpdateWithWhereUniqueWithoutItemTypeInput[]
    updateMany?: LootUpdateManyWithWhereWithoutItemTypeInput | LootUpdateManyWithWhereWithoutItemTypeInput[]
    deleteMany?: LootScalarWhereInput | LootScalarWhereInput[]
  }

  export type LootQueueUncheckedUpdateManyWithoutItemTypeNestedInput = {
    create?: XOR<LootQueueCreateWithoutItemTypeInput, LootQueueUncheckedCreateWithoutItemTypeInput> | LootQueueCreateWithoutItemTypeInput[] | LootQueueUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutItemTypeInput | LootQueueCreateOrConnectWithoutItemTypeInput[]
    upsert?: LootQueueUpsertWithWhereUniqueWithoutItemTypeInput | LootQueueUpsertWithWhereUniqueWithoutItemTypeInput[]
    createMany?: LootQueueCreateManyItemTypeInputEnvelope
    set?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    disconnect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    delete?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    update?: LootQueueUpdateWithWhereUniqueWithoutItemTypeInput | LootQueueUpdateWithWhereUniqueWithoutItemTypeInput[]
    updateMany?: LootQueueUpdateManyWithWhereWithoutItemTypeInput | LootQueueUpdateManyWithWhereWithoutItemTypeInput[]
    deleteMany?: LootQueueScalarWhereInput | LootQueueScalarWhereInput[]
  }

  export type ItemTypeCreateNestedOneWithoutLootInput = {
    create?: XOR<ItemTypeCreateWithoutLootInput, ItemTypeUncheckedCreateWithoutLootInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutLootInput
    connect?: ItemTypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSoldLootInput = {
    create?: XOR<UserCreateWithoutSoldLootInput, UserUncheckedCreateWithoutSoldLootInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoldLootInput
    connect?: UserWhereUniqueInput
  }

  export type ItemTypeUpdateOneRequiredWithoutLootNestedInput = {
    create?: XOR<ItemTypeCreateWithoutLootInput, ItemTypeUncheckedCreateWithoutLootInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutLootInput
    upsert?: ItemTypeUpsertWithoutLootInput
    connect?: ItemTypeWhereUniqueInput
    update?: XOR<XOR<ItemTypeUpdateToOneWithWhereWithoutLootInput, ItemTypeUpdateWithoutLootInput>, ItemTypeUncheckedUpdateWithoutLootInput>
  }

  export type UserUpdateOneWithoutSoldLootNestedInput = {
    create?: XOR<UserCreateWithoutSoldLootInput, UserUncheckedCreateWithoutSoldLootInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoldLootInput
    upsert?: UserUpsertWithoutSoldLootInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSoldLootInput, UserUpdateWithoutSoldLootInput>, UserUncheckedUpdateWithoutSoldLootInput>
  }

  export type TasksCreateNestedOneWithoutAssignedToInput = {
    create?: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput>
    connectOrCreate?: TasksCreateOrConnectWithoutAssignedToInput
    connect?: TasksWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksAssignedInput = {
    create?: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksAssignedInput
    connect?: UserWhereUniqueInput
  }

  export type TasksUpdateOneRequiredWithoutAssignedToNestedInput = {
    create?: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput>
    connectOrCreate?: TasksCreateOrConnectWithoutAssignedToInput
    upsert?: TasksUpsertWithoutAssignedToInput
    connect?: TasksWhereUniqueInput
    update?: XOR<XOR<TasksUpdateToOneWithWhereWithoutAssignedToInput, TasksUpdateWithoutAssignedToInput>, TasksUncheckedUpdateWithoutAssignedToInput>
  }

  export type UserUpdateOneRequiredWithoutTasksAssignedNestedInput = {
    create?: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksAssignedInput
    upsert?: UserUpsertWithoutTasksAssignedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksAssignedInput, UserUpdateWithoutTasksAssignedInput>, UserUncheckedUpdateWithoutTasksAssignedInput>
  }

  export type ItemTypeCreateNestedOneWithoutLootQueueInput = {
    create?: XOR<ItemTypeCreateWithoutLootQueueInput, ItemTypeUncheckedCreateWithoutLootQueueInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutLootQueueInput
    connect?: ItemTypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLootQueueInput = {
    create?: XOR<UserCreateWithoutLootQueueInput, UserUncheckedCreateWithoutLootQueueInput>
    connectOrCreate?: UserCreateOrConnectWithoutLootQueueInput
    connect?: UserWhereUniqueInput
  }

  export type ItemTypeUpdateOneRequiredWithoutLootQueueNestedInput = {
    create?: XOR<ItemTypeCreateWithoutLootQueueInput, ItemTypeUncheckedCreateWithoutLootQueueInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutLootQueueInput
    upsert?: ItemTypeUpsertWithoutLootQueueInput
    connect?: ItemTypeWhereUniqueInput
    update?: XOR<XOR<ItemTypeUpdateToOneWithWhereWithoutLootQueueInput, ItemTypeUpdateWithoutLootQueueInput>, ItemTypeUncheckedUpdateWithoutLootQueueInput>
  }

  export type UserUpdateOneRequiredWithoutLootQueueNestedInput = {
    create?: XOR<UserCreateWithoutLootQueueInput, UserUncheckedCreateWithoutLootQueueInput>
    connectOrCreate?: UserCreateOrConnectWithoutLootQueueInput
    upsert?: UserUpsertWithoutLootQueueInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLootQueueInput, UserUpdateWithoutLootQueueInput>, UserUncheckedUpdateWithoutLootQueueInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserInventoryCreateWithoutUserInput = {
    type?: string | null
    name?: string | null
    quality?: string | null
    created_at: Date | string
  }

  export type UserInventoryUncheckedCreateWithoutUserInput = {
    id?: number
    type?: string | null
    name?: string | null
    quality?: string | null
    created_at: Date | string
  }

  export type UserInventoryCreateOrConnectWithoutUserInput = {
    where: UserInventoryWhereUniqueInput
    create: XOR<UserInventoryCreateWithoutUserInput, UserInventoryUncheckedCreateWithoutUserInput>
  }

  export type UserInventoryCreateManyUserInputEnvelope = {
    data: UserInventoryCreateManyUserInput | UserInventoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TasksCreateWithoutUserInput = {
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
    assignedTo?: TasksUserCreateNestedManyWithoutTaskInput
  }

  export type TasksUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
    assignedTo?: TasksUserUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TasksCreateOrConnectWithoutUserInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput>
  }

  export type TasksCreateManyUserInputEnvelope = {
    data: TasksCreateManyUserInput | TasksCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RaidAttendanceCreateWithoutUserInput = {
    created_at: Date | string
    raid: RaidCreateNestedOneWithoutAttendanceInput
  }

  export type RaidAttendanceUncheckedCreateWithoutUserInput = {
    id?: number
    raid_id: number
    created_at: Date | string
  }

  export type RaidAttendanceCreateOrConnectWithoutUserInput = {
    where: RaidAttendanceWhereUniqueInput
    create: XOR<RaidAttendanceCreateWithoutUserInput, RaidAttendanceUncheckedCreateWithoutUserInput>
  }

  export type RaidAttendanceCreateManyUserInputEnvelope = {
    data: RaidAttendanceCreateManyUserInput | RaidAttendanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TasksUserCreateWithoutUserInput = {
    task: TasksCreateNestedOneWithoutAssignedToInput
  }

  export type TasksUserUncheckedCreateWithoutUserInput = {
    tasks_user_id: number
  }

  export type TasksUserCreateOrConnectWithoutUserInput = {
    where: TasksUserWhereUniqueInput
    create: XOR<TasksUserCreateWithoutUserInput, TasksUserUncheckedCreateWithoutUserInput>
  }

  export type TasksUserCreateManyUserInputEnvelope = {
    data: TasksUserCreateManyUserInput | TasksUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserTagsCreateWithoutUserInput = {
    tag: string
    created_at?: Date | string
  }

  export type UserTagsUncheckedCreateWithoutUserInput = {
    id?: number
    tag: string
    created_at?: Date | string
  }

  export type UserTagsCreateOrConnectWithoutUserInput = {
    where: UserTagsWhereUniqueInput
    create: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput>
  }

  export type UserTagsCreateManyUserInputEnvelope = {
    data: UserTagsCreateManyUserInput | UserTagsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LootCreateWithoutSoldToUserInput = {
    status: string
    acquired_at: Date | string
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    source?: string | null
    created_at?: Date | string
    itemType: ItemTypeCreateNestedOneWithoutLootInput
  }

  export type LootUncheckedCreateWithoutSoldToUserInput = {
    id?: number
    itemTypeId: number
    status: string
    acquired_at: Date | string
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    source?: string | null
    created_at?: Date | string
  }

  export type LootCreateOrConnectWithoutSoldToUserInput = {
    where: LootWhereUniqueInput
    create: XOR<LootCreateWithoutSoldToUserInput, LootUncheckedCreateWithoutSoldToUserInput>
  }

  export type LootCreateManySoldToUserInputEnvelope = {
    data: LootCreateManySoldToUserInput | LootCreateManySoldToUserInput[]
    skipDuplicates?: boolean
  }

  export type LootQueueCreateWithoutUserInput = {
    status?: string
    synthTarget?: string | null
    remaining?: number | null
    created_at?: Date | string
    itemType: ItemTypeCreateNestedOneWithoutLootQueueInput
  }

  export type LootQueueUncheckedCreateWithoutUserInput = {
    id?: number
    itemTypeId: number
    status?: string
    synthTarget?: string | null
    remaining?: number | null
    created_at?: Date | string
  }

  export type LootQueueCreateOrConnectWithoutUserInput = {
    where: LootQueueWhereUniqueInput
    create: XOR<LootQueueCreateWithoutUserInput, LootQueueUncheckedCreateWithoutUserInput>
  }

  export type LootQueueCreateManyUserInputEnvelope = {
    data: LootQueueCreateManyUserInput | LootQueueCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserInventoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserInventoryWhereUniqueInput
    update: XOR<UserInventoryUpdateWithoutUserInput, UserInventoryUncheckedUpdateWithoutUserInput>
    create: XOR<UserInventoryCreateWithoutUserInput, UserInventoryUncheckedCreateWithoutUserInput>
  }

  export type UserInventoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserInventoryWhereUniqueInput
    data: XOR<UserInventoryUpdateWithoutUserInput, UserInventoryUncheckedUpdateWithoutUserInput>
  }

  export type UserInventoryUpdateManyWithWhereWithoutUserInput = {
    where: UserInventoryScalarWhereInput
    data: XOR<UserInventoryUpdateManyMutationInput, UserInventoryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserInventoryScalarWhereInput = {
    AND?: UserInventoryScalarWhereInput | UserInventoryScalarWhereInput[]
    OR?: UserInventoryScalarWhereInput[]
    NOT?: UserInventoryScalarWhereInput | UserInventoryScalarWhereInput[]
    id?: IntFilter<"UserInventory"> | number
    user_id?: IntFilter<"UserInventory"> | number
    type?: StringNullableFilter<"UserInventory"> | string | null
    name?: StringNullableFilter<"UserInventory"> | string | null
    quality?: StringNullableFilter<"UserInventory"> | string | null
    created_at?: DateTimeFilter<"UserInventory"> | Date | string
  }

  export type TasksUpsertWithWhereUniqueWithoutUserInput = {
    where: TasksWhereUniqueInput
    update: XOR<TasksUpdateWithoutUserInput, TasksUncheckedUpdateWithoutUserInput>
    create: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput>
  }

  export type TasksUpdateWithWhereUniqueWithoutUserInput = {
    where: TasksWhereUniqueInput
    data: XOR<TasksUpdateWithoutUserInput, TasksUncheckedUpdateWithoutUserInput>
  }

  export type TasksUpdateManyWithWhereWithoutUserInput = {
    where: TasksScalarWhereInput
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyWithoutUserInput>
  }

  export type TasksScalarWhereInput = {
    AND?: TasksScalarWhereInput | TasksScalarWhereInput[]
    OR?: TasksScalarWhereInput[]
    NOT?: TasksScalarWhereInput | TasksScalarWhereInput[]
    id?: IntFilter<"Tasks"> | number
    user_id?: IntFilter<"Tasks"> | number
    name?: StringNullableFilter<"Tasks"> | string | null
    completed_at?: DateTimeNullableFilter<"Tasks"> | Date | string | null
    created_at?: DateTimeFilter<"Tasks"> | Date | string
  }

  export type RaidAttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: RaidAttendanceWhereUniqueInput
    update: XOR<RaidAttendanceUpdateWithoutUserInput, RaidAttendanceUncheckedUpdateWithoutUserInput>
    create: XOR<RaidAttendanceCreateWithoutUserInput, RaidAttendanceUncheckedCreateWithoutUserInput>
  }

  export type RaidAttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: RaidAttendanceWhereUniqueInput
    data: XOR<RaidAttendanceUpdateWithoutUserInput, RaidAttendanceUncheckedUpdateWithoutUserInput>
  }

  export type RaidAttendanceUpdateManyWithWhereWithoutUserInput = {
    where: RaidAttendanceScalarWhereInput
    data: XOR<RaidAttendanceUpdateManyMutationInput, RaidAttendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type RaidAttendanceScalarWhereInput = {
    AND?: RaidAttendanceScalarWhereInput | RaidAttendanceScalarWhereInput[]
    OR?: RaidAttendanceScalarWhereInput[]
    NOT?: RaidAttendanceScalarWhereInput | RaidAttendanceScalarWhereInput[]
    id?: IntFilter<"RaidAttendance"> | number
    user_id?: IntFilter<"RaidAttendance"> | number
    raid_id?: IntFilter<"RaidAttendance"> | number
    created_at?: DateTimeFilter<"RaidAttendance"> | Date | string
  }

  export type TasksUserUpsertWithWhereUniqueWithoutUserInput = {
    where: TasksUserWhereUniqueInput
    update: XOR<TasksUserUpdateWithoutUserInput, TasksUserUncheckedUpdateWithoutUserInput>
    create: XOR<TasksUserCreateWithoutUserInput, TasksUserUncheckedCreateWithoutUserInput>
  }

  export type TasksUserUpdateWithWhereUniqueWithoutUserInput = {
    where: TasksUserWhereUniqueInput
    data: XOR<TasksUserUpdateWithoutUserInput, TasksUserUncheckedUpdateWithoutUserInput>
  }

  export type TasksUserUpdateManyWithWhereWithoutUserInput = {
    where: TasksUserScalarWhereInput
    data: XOR<TasksUserUpdateManyMutationInput, TasksUserUncheckedUpdateManyWithoutUserInput>
  }

  export type TasksUserScalarWhereInput = {
    AND?: TasksUserScalarWhereInput | TasksUserScalarWhereInput[]
    OR?: TasksUserScalarWhereInput[]
    NOT?: TasksUserScalarWhereInput | TasksUserScalarWhereInput[]
    tasks_user_id?: IntFilter<"TasksUser"> | number
    user_id?: IntFilter<"TasksUser"> | number
  }

  export type UserTagsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTagsWhereUniqueInput
    update: XOR<UserTagsUpdateWithoutUserInput, UserTagsUncheckedUpdateWithoutUserInput>
    create: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput>
  }

  export type UserTagsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTagsWhereUniqueInput
    data: XOR<UserTagsUpdateWithoutUserInput, UserTagsUncheckedUpdateWithoutUserInput>
  }

  export type UserTagsUpdateManyWithWhereWithoutUserInput = {
    where: UserTagsScalarWhereInput
    data: XOR<UserTagsUpdateManyMutationInput, UserTagsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserTagsScalarWhereInput = {
    AND?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
    OR?: UserTagsScalarWhereInput[]
    NOT?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
    id?: IntFilter<"UserTags"> | number
    user_id?: IntFilter<"UserTags"> | number
    tag?: StringFilter<"UserTags"> | string
    created_at?: DateTimeFilter<"UserTags"> | Date | string
  }

  export type LootUpsertWithWhereUniqueWithoutSoldToUserInput = {
    where: LootWhereUniqueInput
    update: XOR<LootUpdateWithoutSoldToUserInput, LootUncheckedUpdateWithoutSoldToUserInput>
    create: XOR<LootCreateWithoutSoldToUserInput, LootUncheckedCreateWithoutSoldToUserInput>
  }

  export type LootUpdateWithWhereUniqueWithoutSoldToUserInput = {
    where: LootWhereUniqueInput
    data: XOR<LootUpdateWithoutSoldToUserInput, LootUncheckedUpdateWithoutSoldToUserInput>
  }

  export type LootUpdateManyWithWhereWithoutSoldToUserInput = {
    where: LootScalarWhereInput
    data: XOR<LootUpdateManyMutationInput, LootUncheckedUpdateManyWithoutSoldToUserInput>
  }

  export type LootScalarWhereInput = {
    AND?: LootScalarWhereInput | LootScalarWhereInput[]
    OR?: LootScalarWhereInput[]
    NOT?: LootScalarWhereInput | LootScalarWhereInput[]
    id?: IntFilter<"Loot"> | number
    itemTypeId?: IntFilter<"Loot"> | number
    status?: StringFilter<"Loot"> | string
    acquired_at?: DateTimeFilter<"Loot"> | Date | string
    sold_at?: DateTimeNullableFilter<"Loot"> | Date | string | null
    sold_to?: StringNullableFilter<"Loot"> | string | null
    sold_to_user_id?: IntNullableFilter<"Loot"> | number | null
    comment?: StringNullableFilter<"Loot"> | string | null
    source?: StringNullableFilter<"Loot"> | string | null
    created_at?: DateTimeFilter<"Loot"> | Date | string
  }

  export type LootQueueUpsertWithWhereUniqueWithoutUserInput = {
    where: LootQueueWhereUniqueInput
    update: XOR<LootQueueUpdateWithoutUserInput, LootQueueUncheckedUpdateWithoutUserInput>
    create: XOR<LootQueueCreateWithoutUserInput, LootQueueUncheckedCreateWithoutUserInput>
  }

  export type LootQueueUpdateWithWhereUniqueWithoutUserInput = {
    where: LootQueueWhereUniqueInput
    data: XOR<LootQueueUpdateWithoutUserInput, LootQueueUncheckedUpdateWithoutUserInput>
  }

  export type LootQueueUpdateManyWithWhereWithoutUserInput = {
    where: LootQueueScalarWhereInput
    data: XOR<LootQueueUpdateManyMutationInput, LootQueueUncheckedUpdateManyWithoutUserInput>
  }

  export type LootQueueScalarWhereInput = {
    AND?: LootQueueScalarWhereInput | LootQueueScalarWhereInput[]
    OR?: LootQueueScalarWhereInput[]
    NOT?: LootQueueScalarWhereInput | LootQueueScalarWhereInput[]
    id?: IntFilter<"LootQueue"> | number
    itemTypeId?: IntFilter<"LootQueue"> | number
    userId?: IntFilter<"LootQueue"> | number
    status?: StringFilter<"LootQueue"> | string
    synthTarget?: StringNullableFilter<"LootQueue"> | string | null
    remaining?: IntNullableFilter<"LootQueue"> | number | null
    created_at?: DateTimeFilter<"LootQueue"> | Date | string
  }

  export type UserCreateWithoutTagsInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTagsInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTagsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
  }

  export type UserUpsertWithoutTagsInput = {
    update: XOR<UserUpdateWithoutTagsInput, UserUncheckedUpdateWithoutTagsInput>
    create: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTagsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTagsInput, UserUncheckedUpdateWithoutTagsInput>
  }

  export type UserUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInventoryInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    tasks?: TasksCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoryInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
  }

  export type UserUpsertWithoutInventoryInput = {
    update: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type UserUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TasksUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTasksInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type TasksUserCreateWithoutTaskInput = {
    user: UserCreateNestedOneWithoutTasksAssignedInput
  }

  export type TasksUserUncheckedCreateWithoutTaskInput = {
    user_id: number
  }

  export type TasksUserCreateOrConnectWithoutTaskInput = {
    where: TasksUserWhereUniqueInput
    create: XOR<TasksUserCreateWithoutTaskInput, TasksUserUncheckedCreateWithoutTaskInput>
  }

  export type TasksUserCreateManyTaskInputEnvelope = {
    data: TasksUserCreateManyTaskInput | TasksUserCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTasksInput = {
    update: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TasksUserUpsertWithWhereUniqueWithoutTaskInput = {
    where: TasksUserWhereUniqueInput
    update: XOR<TasksUserUpdateWithoutTaskInput, TasksUserUncheckedUpdateWithoutTaskInput>
    create: XOR<TasksUserCreateWithoutTaskInput, TasksUserUncheckedCreateWithoutTaskInput>
  }

  export type TasksUserUpdateWithWhereUniqueWithoutTaskInput = {
    where: TasksUserWhereUniqueInput
    data: XOR<TasksUserUpdateWithoutTaskInput, TasksUserUncheckedUpdateWithoutTaskInput>
  }

  export type TasksUserUpdateManyWithWhereWithoutTaskInput = {
    where: TasksUserScalarWhereInput
    data: XOR<TasksUserUpdateManyMutationInput, TasksUserUncheckedUpdateManyWithoutTaskInput>
  }

  export type RaidBossCreateWithoutRaidInput = {
    boss: BossCreateNestedOneWithoutRaidBossesInput
  }

  export type RaidBossUncheckedCreateWithoutRaidInput = {
    boss_id: number
  }

  export type RaidBossCreateOrConnectWithoutRaidInput = {
    where: RaidBossWhereUniqueInput
    create: XOR<RaidBossCreateWithoutRaidInput, RaidBossUncheckedCreateWithoutRaidInput>
  }

  export type RaidBossCreateManyRaidInputEnvelope = {
    data: RaidBossCreateManyRaidInput | RaidBossCreateManyRaidInput[]
    skipDuplicates?: boolean
  }

  export type RaidAttendanceCreateWithoutRaidInput = {
    created_at: Date | string
    user: UserCreateNestedOneWithoutRaidAttendanceInput
  }

  export type RaidAttendanceUncheckedCreateWithoutRaidInput = {
    id?: number
    user_id: number
    created_at: Date | string
  }

  export type RaidAttendanceCreateOrConnectWithoutRaidInput = {
    where: RaidAttendanceWhereUniqueInput
    create: XOR<RaidAttendanceCreateWithoutRaidInput, RaidAttendanceUncheckedCreateWithoutRaidInput>
  }

  export type RaidAttendanceCreateManyRaidInputEnvelope = {
    data: RaidAttendanceCreateManyRaidInput | RaidAttendanceCreateManyRaidInput[]
    skipDuplicates?: boolean
  }

  export type RaidBossUpsertWithWhereUniqueWithoutRaidInput = {
    where: RaidBossWhereUniqueInput
    update: XOR<RaidBossUpdateWithoutRaidInput, RaidBossUncheckedUpdateWithoutRaidInput>
    create: XOR<RaidBossCreateWithoutRaidInput, RaidBossUncheckedCreateWithoutRaidInput>
  }

  export type RaidBossUpdateWithWhereUniqueWithoutRaidInput = {
    where: RaidBossWhereUniqueInput
    data: XOR<RaidBossUpdateWithoutRaidInput, RaidBossUncheckedUpdateWithoutRaidInput>
  }

  export type RaidBossUpdateManyWithWhereWithoutRaidInput = {
    where: RaidBossScalarWhereInput
    data: XOR<RaidBossUpdateManyMutationInput, RaidBossUncheckedUpdateManyWithoutRaidInput>
  }

  export type RaidBossScalarWhereInput = {
    AND?: RaidBossScalarWhereInput | RaidBossScalarWhereInput[]
    OR?: RaidBossScalarWhereInput[]
    NOT?: RaidBossScalarWhereInput | RaidBossScalarWhereInput[]
    raid_id?: IntFilter<"RaidBoss"> | number
    boss_id?: IntFilter<"RaidBoss"> | number
  }

  export type RaidAttendanceUpsertWithWhereUniqueWithoutRaidInput = {
    where: RaidAttendanceWhereUniqueInput
    update: XOR<RaidAttendanceUpdateWithoutRaidInput, RaidAttendanceUncheckedUpdateWithoutRaidInput>
    create: XOR<RaidAttendanceCreateWithoutRaidInput, RaidAttendanceUncheckedCreateWithoutRaidInput>
  }

  export type RaidAttendanceUpdateWithWhereUniqueWithoutRaidInput = {
    where: RaidAttendanceWhereUniqueInput
    data: XOR<RaidAttendanceUpdateWithoutRaidInput, RaidAttendanceUncheckedUpdateWithoutRaidInput>
  }

  export type RaidAttendanceUpdateManyWithWhereWithoutRaidInput = {
    where: RaidAttendanceScalarWhereInput
    data: XOR<RaidAttendanceUpdateManyMutationInput, RaidAttendanceUncheckedUpdateManyWithoutRaidInput>
  }

  export type RaidBossCreateWithoutBossInput = {
    raid: RaidCreateNestedOneWithoutRaidBossesInput
  }

  export type RaidBossUncheckedCreateWithoutBossInput = {
    raid_id: number
  }

  export type RaidBossCreateOrConnectWithoutBossInput = {
    where: RaidBossWhereUniqueInput
    create: XOR<RaidBossCreateWithoutBossInput, RaidBossUncheckedCreateWithoutBossInput>
  }

  export type RaidBossCreateManyBossInputEnvelope = {
    data: RaidBossCreateManyBossInput | RaidBossCreateManyBossInput[]
    skipDuplicates?: boolean
  }

  export type RaidBossUpsertWithWhereUniqueWithoutBossInput = {
    where: RaidBossWhereUniqueInput
    update: XOR<RaidBossUpdateWithoutBossInput, RaidBossUncheckedUpdateWithoutBossInput>
    create: XOR<RaidBossCreateWithoutBossInput, RaidBossUncheckedCreateWithoutBossInput>
  }

  export type RaidBossUpdateWithWhereUniqueWithoutBossInput = {
    where: RaidBossWhereUniqueInput
    data: XOR<RaidBossUpdateWithoutBossInput, RaidBossUncheckedUpdateWithoutBossInput>
  }

  export type RaidBossUpdateManyWithWhereWithoutBossInput = {
    where: RaidBossScalarWhereInput
    data: XOR<RaidBossUpdateManyMutationInput, RaidBossUncheckedUpdateManyWithoutBossInput>
  }

  export type RaidCreateWithoutRaidBossesInput = {
    type?: string | null
    is_pvp?: boolean
    is_pvp_long?: boolean
    start_date?: Date | string | null
    created_at?: Date | string
    dkp_summary?: number
    attendance?: RaidAttendanceCreateNestedManyWithoutRaidInput
  }

  export type RaidUncheckedCreateWithoutRaidBossesInput = {
    id?: number
    type?: string | null
    is_pvp?: boolean
    is_pvp_long?: boolean
    start_date?: Date | string | null
    created_at?: Date | string
    dkp_summary?: number
    attendance?: RaidAttendanceUncheckedCreateNestedManyWithoutRaidInput
  }

  export type RaidCreateOrConnectWithoutRaidBossesInput = {
    where: RaidWhereUniqueInput
    create: XOR<RaidCreateWithoutRaidBossesInput, RaidUncheckedCreateWithoutRaidBossesInput>
  }

  export type BossCreateWithoutRaidBossesInput = {
    boss_name: string
    dkp_points: number
    category: string
  }

  export type BossUncheckedCreateWithoutRaidBossesInput = {
    id?: number
    boss_name: string
    dkp_points: number
    category: string
  }

  export type BossCreateOrConnectWithoutRaidBossesInput = {
    where: BossWhereUniqueInput
    create: XOR<BossCreateWithoutRaidBossesInput, BossUncheckedCreateWithoutRaidBossesInput>
  }

  export type RaidUpsertWithoutRaidBossesInput = {
    update: XOR<RaidUpdateWithoutRaidBossesInput, RaidUncheckedUpdateWithoutRaidBossesInput>
    create: XOR<RaidCreateWithoutRaidBossesInput, RaidUncheckedCreateWithoutRaidBossesInput>
    where?: RaidWhereInput
  }

  export type RaidUpdateToOneWithWhereWithoutRaidBossesInput = {
    where?: RaidWhereInput
    data: XOR<RaidUpdateWithoutRaidBossesInput, RaidUncheckedUpdateWithoutRaidBossesInput>
  }

  export type RaidUpdateWithoutRaidBossesInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_pvp?: BoolFieldUpdateOperationsInput | boolean
    is_pvp_long?: BoolFieldUpdateOperationsInput | boolean
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dkp_summary?: IntFieldUpdateOperationsInput | number
    attendance?: RaidAttendanceUpdateManyWithoutRaidNestedInput
  }

  export type RaidUncheckedUpdateWithoutRaidBossesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_pvp?: BoolFieldUpdateOperationsInput | boolean
    is_pvp_long?: BoolFieldUpdateOperationsInput | boolean
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dkp_summary?: IntFieldUpdateOperationsInput | number
    attendance?: RaidAttendanceUncheckedUpdateManyWithoutRaidNestedInput
  }

  export type BossUpsertWithoutRaidBossesInput = {
    update: XOR<BossUpdateWithoutRaidBossesInput, BossUncheckedUpdateWithoutRaidBossesInput>
    create: XOR<BossCreateWithoutRaidBossesInput, BossUncheckedCreateWithoutRaidBossesInput>
    where?: BossWhereInput
  }

  export type BossUpdateToOneWithWhereWithoutRaidBossesInput = {
    where?: BossWhereInput
    data: XOR<BossUpdateWithoutRaidBossesInput, BossUncheckedUpdateWithoutRaidBossesInput>
  }

  export type BossUpdateWithoutRaidBossesInput = {
    boss_name?: StringFieldUpdateOperationsInput | string
    dkp_points?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type BossUncheckedUpdateWithoutRaidBossesInput = {
    id?: IntFieldUpdateOperationsInput | number
    boss_name?: StringFieldUpdateOperationsInput | string
    dkp_points?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutRaidAttendanceInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRaidAttendanceInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRaidAttendanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRaidAttendanceInput, UserUncheckedCreateWithoutRaidAttendanceInput>
  }

  export type RaidCreateWithoutAttendanceInput = {
    type?: string | null
    is_pvp?: boolean
    is_pvp_long?: boolean
    start_date?: Date | string | null
    created_at?: Date | string
    dkp_summary?: number
    raidBosses?: RaidBossCreateNestedManyWithoutRaidInput
  }

  export type RaidUncheckedCreateWithoutAttendanceInput = {
    id?: number
    type?: string | null
    is_pvp?: boolean
    is_pvp_long?: boolean
    start_date?: Date | string | null
    created_at?: Date | string
    dkp_summary?: number
    raidBosses?: RaidBossUncheckedCreateNestedManyWithoutRaidInput
  }

  export type RaidCreateOrConnectWithoutAttendanceInput = {
    where: RaidWhereUniqueInput
    create: XOR<RaidCreateWithoutAttendanceInput, RaidUncheckedCreateWithoutAttendanceInput>
  }

  export type UserUpsertWithoutRaidAttendanceInput = {
    update: XOR<UserUpdateWithoutRaidAttendanceInput, UserUncheckedUpdateWithoutRaidAttendanceInput>
    create: XOR<UserCreateWithoutRaidAttendanceInput, UserUncheckedCreateWithoutRaidAttendanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRaidAttendanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRaidAttendanceInput, UserUncheckedUpdateWithoutRaidAttendanceInput>
  }

  export type UserUpdateWithoutRaidAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRaidAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RaidUpsertWithoutAttendanceInput = {
    update: XOR<RaidUpdateWithoutAttendanceInput, RaidUncheckedUpdateWithoutAttendanceInput>
    create: XOR<RaidCreateWithoutAttendanceInput, RaidUncheckedCreateWithoutAttendanceInput>
    where?: RaidWhereInput
  }

  export type RaidUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: RaidWhereInput
    data: XOR<RaidUpdateWithoutAttendanceInput, RaidUncheckedUpdateWithoutAttendanceInput>
  }

  export type RaidUpdateWithoutAttendanceInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_pvp?: BoolFieldUpdateOperationsInput | boolean
    is_pvp_long?: BoolFieldUpdateOperationsInput | boolean
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dkp_summary?: IntFieldUpdateOperationsInput | number
    raidBosses?: RaidBossUpdateManyWithoutRaidNestedInput
  }

  export type RaidUncheckedUpdateWithoutAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    is_pvp?: BoolFieldUpdateOperationsInput | boolean
    is_pvp_long?: BoolFieldUpdateOperationsInput | boolean
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dkp_summary?: IntFieldUpdateOperationsInput | number
    raidBosses?: RaidBossUncheckedUpdateManyWithoutRaidNestedInput
  }

  export type LootCreateWithoutItemTypeInput = {
    status: string
    acquired_at: Date | string
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    source?: string | null
    created_at?: Date | string
    soldToUser?: UserCreateNestedOneWithoutSoldLootInput
  }

  export type LootUncheckedCreateWithoutItemTypeInput = {
    id?: number
    status: string
    acquired_at: Date | string
    sold_at?: Date | string | null
    sold_to?: string | null
    sold_to_user_id?: number | null
    comment?: string | null
    source?: string | null
    created_at?: Date | string
  }

  export type LootCreateOrConnectWithoutItemTypeInput = {
    where: LootWhereUniqueInput
    create: XOR<LootCreateWithoutItemTypeInput, LootUncheckedCreateWithoutItemTypeInput>
  }

  export type LootCreateManyItemTypeInputEnvelope = {
    data: LootCreateManyItemTypeInput | LootCreateManyItemTypeInput[]
    skipDuplicates?: boolean
  }

  export type LootQueueCreateWithoutItemTypeInput = {
    status?: string
    synthTarget?: string | null
    remaining?: number | null
    created_at?: Date | string
    user: UserCreateNestedOneWithoutLootQueueInput
  }

  export type LootQueueUncheckedCreateWithoutItemTypeInput = {
    id?: number
    userId: number
    status?: string
    synthTarget?: string | null
    remaining?: number | null
    created_at?: Date | string
  }

  export type LootQueueCreateOrConnectWithoutItemTypeInput = {
    where: LootQueueWhereUniqueInput
    create: XOR<LootQueueCreateWithoutItemTypeInput, LootQueueUncheckedCreateWithoutItemTypeInput>
  }

  export type LootQueueCreateManyItemTypeInputEnvelope = {
    data: LootQueueCreateManyItemTypeInput | LootQueueCreateManyItemTypeInput[]
    skipDuplicates?: boolean
  }

  export type LootUpsertWithWhereUniqueWithoutItemTypeInput = {
    where: LootWhereUniqueInput
    update: XOR<LootUpdateWithoutItemTypeInput, LootUncheckedUpdateWithoutItemTypeInput>
    create: XOR<LootCreateWithoutItemTypeInput, LootUncheckedCreateWithoutItemTypeInput>
  }

  export type LootUpdateWithWhereUniqueWithoutItemTypeInput = {
    where: LootWhereUniqueInput
    data: XOR<LootUpdateWithoutItemTypeInput, LootUncheckedUpdateWithoutItemTypeInput>
  }

  export type LootUpdateManyWithWhereWithoutItemTypeInput = {
    where: LootScalarWhereInput
    data: XOR<LootUpdateManyMutationInput, LootUncheckedUpdateManyWithoutItemTypeInput>
  }

  export type LootQueueUpsertWithWhereUniqueWithoutItemTypeInput = {
    where: LootQueueWhereUniqueInput
    update: XOR<LootQueueUpdateWithoutItemTypeInput, LootQueueUncheckedUpdateWithoutItemTypeInput>
    create: XOR<LootQueueCreateWithoutItemTypeInput, LootQueueUncheckedCreateWithoutItemTypeInput>
  }

  export type LootQueueUpdateWithWhereUniqueWithoutItemTypeInput = {
    where: LootQueueWhereUniqueInput
    data: XOR<LootQueueUpdateWithoutItemTypeInput, LootQueueUncheckedUpdateWithoutItemTypeInput>
  }

  export type LootQueueUpdateManyWithWhereWithoutItemTypeInput = {
    where: LootQueueScalarWhereInput
    data: XOR<LootQueueUpdateManyMutationInput, LootQueueUncheckedUpdateManyWithoutItemTypeInput>
  }

  export type ItemTypeCreateWithoutLootInput = {
    name: string
    price?: number | null
    lootQueue?: LootQueueCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeUncheckedCreateWithoutLootInput = {
    id?: number
    name: string
    price?: number | null
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeCreateOrConnectWithoutLootInput = {
    where: ItemTypeWhereUniqueInput
    create: XOR<ItemTypeCreateWithoutLootInput, ItemTypeUncheckedCreateWithoutLootInput>
  }

  export type UserCreateWithoutSoldLootInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSoldLootInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSoldLootInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSoldLootInput, UserUncheckedCreateWithoutSoldLootInput>
  }

  export type ItemTypeUpsertWithoutLootInput = {
    update: XOR<ItemTypeUpdateWithoutLootInput, ItemTypeUncheckedUpdateWithoutLootInput>
    create: XOR<ItemTypeCreateWithoutLootInput, ItemTypeUncheckedCreateWithoutLootInput>
    where?: ItemTypeWhereInput
  }

  export type ItemTypeUpdateToOneWithWhereWithoutLootInput = {
    where?: ItemTypeWhereInput
    data: XOR<ItemTypeUpdateWithoutLootInput, ItemTypeUncheckedUpdateWithoutLootInput>
  }

  export type ItemTypeUpdateWithoutLootInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    lootQueue?: LootQueueUpdateManyWithoutItemTypeNestedInput
  }

  export type ItemTypeUncheckedUpdateWithoutLootInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    lootQueue?: LootQueueUncheckedUpdateManyWithoutItemTypeNestedInput
  }

  export type UserUpsertWithoutSoldLootInput = {
    update: XOR<UserUpdateWithoutSoldLootInput, UserUncheckedUpdateWithoutSoldLootInput>
    create: XOR<UserCreateWithoutSoldLootInput, UserUncheckedCreateWithoutSoldLootInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSoldLootInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSoldLootInput, UserUncheckedUpdateWithoutSoldLootInput>
  }

  export type UserUpdateWithoutSoldLootInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSoldLootInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TasksCreateWithoutAssignedToInput = {
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
    user: UserCreateNestedOneWithoutTasksInput
  }

  export type TasksUncheckedCreateWithoutAssignedToInput = {
    id?: number
    user_id: number
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
  }

  export type TasksCreateOrConnectWithoutAssignedToInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput>
  }

  export type UserCreateWithoutTasksAssignedInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksAssignedInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksAssignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
  }

  export type TasksUpsertWithoutAssignedToInput = {
    update: XOR<TasksUpdateWithoutAssignedToInput, TasksUncheckedUpdateWithoutAssignedToInput>
    create: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput>
    where?: TasksWhereInput
  }

  export type TasksUpdateToOneWithWhereWithoutAssignedToInput = {
    where?: TasksWhereInput
    data: XOR<TasksUpdateWithoutAssignedToInput, TasksUncheckedUpdateWithoutAssignedToInput>
  }

  export type TasksUpdateWithoutAssignedToInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TasksUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTasksAssignedInput = {
    update: XOR<UserUpdateWithoutTasksAssignedInput, UserUncheckedUpdateWithoutTasksAssignedInput>
    create: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksAssignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksAssignedInput, UserUncheckedUpdateWithoutTasksAssignedInput>
  }

  export type UserUpdateWithoutTasksAssignedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksAssignedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ItemTypeCreateWithoutLootQueueInput = {
    name: string
    price?: number | null
    loot?: LootCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeUncheckedCreateWithoutLootQueueInput = {
    id?: number
    name: string
    price?: number | null
    loot?: LootUncheckedCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeCreateOrConnectWithoutLootQueueInput = {
    where: ItemTypeWhereUniqueInput
    create: XOR<ItemTypeCreateWithoutLootQueueInput, ItemTypeUncheckedCreateWithoutLootQueueInput>
  }

  export type UserCreateWithoutLootQueueInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
  }

  export type UserUncheckedCreateWithoutLootQueueInput = {
    id: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
  }

  export type UserCreateOrConnectWithoutLootQueueInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLootQueueInput, UserUncheckedCreateWithoutLootQueueInput>
  }

  export type ItemTypeUpsertWithoutLootQueueInput = {
    update: XOR<ItemTypeUpdateWithoutLootQueueInput, ItemTypeUncheckedUpdateWithoutLootQueueInput>
    create: XOR<ItemTypeCreateWithoutLootQueueInput, ItemTypeUncheckedCreateWithoutLootQueueInput>
    where?: ItemTypeWhereInput
  }

  export type ItemTypeUpdateToOneWithWhereWithoutLootQueueInput = {
    where?: ItemTypeWhereInput
    data: XOR<ItemTypeUpdateWithoutLootQueueInput, ItemTypeUncheckedUpdateWithoutLootQueueInput>
  }

  export type ItemTypeUpdateWithoutLootQueueInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    loot?: LootUpdateManyWithoutItemTypeNestedInput
  }

  export type ItemTypeUncheckedUpdateWithoutLootQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    loot?: LootUncheckedUpdateManyWithoutItemTypeNestedInput
  }

  export type UserUpsertWithoutLootQueueInput = {
    update: XOR<UserUpdateWithoutLootQueueInput, UserUncheckedUpdateWithoutLootQueueInput>
    create: XOR<UserCreateWithoutLootQueueInput, UserUncheckedCreateWithoutLootQueueInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLootQueueInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLootQueueInput, UserUncheckedUpdateWithoutLootQueueInput>
  }

  export type UserUpdateWithoutLootQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLootQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
  }

  export type UserInventoryCreateManyUserInput = {
    id?: number
    type?: string | null
    name?: string | null
    quality?: string | null
    created_at: Date | string
  }

  export type TasksCreateManyUserInput = {
    id?: number
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
  }

  export type RaidAttendanceCreateManyUserInput = {
    id?: number
    raid_id: number
    created_at: Date | string
  }

  export type TasksUserCreateManyUserInput = {
    tasks_user_id: number
  }

  export type UserTagsCreateManyUserInput = {
    id?: number
    tag: string
    created_at?: Date | string
  }

  export type LootCreateManySoldToUserInput = {
    id?: number
    itemTypeId: number
    status: string
    acquired_at: Date | string
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    source?: string | null
    created_at?: Date | string
  }

  export type LootQueueCreateManyUserInput = {
    id?: number
    itemTypeId: number
    status?: string
    synthTarget?: string | null
    remaining?: number | null
    created_at?: Date | string
  }

  export type UserInventoryUpdateWithoutUserInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TasksUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: TasksUserUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: TasksUserUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidAttendanceUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    raid?: RaidUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type RaidAttendanceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    raid_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidAttendanceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    raid_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TasksUserUpdateWithoutUserInput = {
    task?: TasksUpdateOneRequiredWithoutAssignedToNestedInput
  }

  export type TasksUserUncheckedUpdateWithoutUserInput = {
    tasks_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type TasksUserUncheckedUpdateManyWithoutUserInput = {
    tasks_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type UserTagsUpdateWithoutUserInput = {
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LootUpdateWithoutSoldToUserInput = {
    status?: StringFieldUpdateOperationsInput | string
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    itemType?: ItemTypeUpdateOneRequiredWithoutLootNestedInput
  }

  export type LootUncheckedUpdateWithoutSoldToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LootUncheckedUpdateManyWithoutSoldToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LootQueueUpdateWithoutUserInput = {
    status?: StringFieldUpdateOperationsInput | string
    synthTarget?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    itemType?: ItemTypeUpdateOneRequiredWithoutLootQueueNestedInput
  }

  export type LootQueueUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    synthTarget?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LootQueueUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    synthTarget?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TasksUserCreateManyTaskInput = {
    user_id: number
  }

  export type TasksUserUpdateWithoutTaskInput = {
    user?: UserUpdateOneRequiredWithoutTasksAssignedNestedInput
  }

  export type TasksUserUncheckedUpdateWithoutTaskInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type TasksUserUncheckedUpdateManyWithoutTaskInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type RaidBossCreateManyRaidInput = {
    boss_id: number
  }

  export type RaidAttendanceCreateManyRaidInput = {
    id?: number
    user_id: number
    created_at: Date | string
  }

  export type RaidBossUpdateWithoutRaidInput = {
    boss?: BossUpdateOneRequiredWithoutRaidBossesNestedInput
  }

  export type RaidBossUncheckedUpdateWithoutRaidInput = {
    boss_id?: IntFieldUpdateOperationsInput | number
  }

  export type RaidBossUncheckedUpdateManyWithoutRaidInput = {
    boss_id?: IntFieldUpdateOperationsInput | number
  }

  export type RaidAttendanceUpdateWithoutRaidInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRaidAttendanceNestedInput
  }

  export type RaidAttendanceUncheckedUpdateWithoutRaidInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidAttendanceUncheckedUpdateManyWithoutRaidInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidBossCreateManyBossInput = {
    raid_id: number
  }

  export type RaidBossUpdateWithoutBossInput = {
    raid?: RaidUpdateOneRequiredWithoutRaidBossesNestedInput
  }

  export type RaidBossUncheckedUpdateWithoutBossInput = {
    raid_id?: IntFieldUpdateOperationsInput | number
  }

  export type RaidBossUncheckedUpdateManyWithoutBossInput = {
    raid_id?: IntFieldUpdateOperationsInput | number
  }

  export type LootCreateManyItemTypeInput = {
    id?: number
    status: string
    acquired_at: Date | string
    sold_at?: Date | string | null
    sold_to?: string | null
    sold_to_user_id?: number | null
    comment?: string | null
    source?: string | null
    created_at?: Date | string
  }

  export type LootQueueCreateManyItemTypeInput = {
    id?: number
    userId: number
    status?: string
    synthTarget?: string | null
    remaining?: number | null
    created_at?: Date | string
  }

  export type LootUpdateWithoutItemTypeInput = {
    status?: StringFieldUpdateOperationsInput | string
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    soldToUser?: UserUpdateOneWithoutSoldLootNestedInput
  }

  export type LootUncheckedUpdateWithoutItemTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    sold_to_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LootUncheckedUpdateManyWithoutItemTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    acquired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    sold_to_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LootQueueUpdateWithoutItemTypeInput = {
    status?: StringFieldUpdateOperationsInput | string
    synthTarget?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLootQueueNestedInput
  }

  export type LootQueueUncheckedUpdateWithoutItemTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    synthTarget?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LootQueueUncheckedUpdateManyWithoutItemTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    synthTarget?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}