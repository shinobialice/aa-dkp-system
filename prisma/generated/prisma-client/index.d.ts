
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserTags
 * 
 */
export type UserTags = $Result.DefaultSelection<Prisma.$UserTagsPayload>
/**
 * Model UserInventory
 * 
 */
export type UserInventory = $Result.DefaultSelection<Prisma.$UserInventoryPayload>
/**
 * Model Tasks
 * 
 */
export type Tasks = $Result.DefaultSelection<Prisma.$TasksPayload>
/**
 * Model Raid
 * 
 */
export type Raid = $Result.DefaultSelection<Prisma.$RaidPayload>
/**
 * Model Boss
 * 
 */
export type Boss = $Result.DefaultSelection<Prisma.$BossPayload>
/**
 * Model RaidBoss
 * 
 */
export type RaidBoss = $Result.DefaultSelection<Prisma.$RaidBossPayload>
/**
 * Model RaidAttendance
 * 
 */
export type RaidAttendance = $Result.DefaultSelection<Prisma.$RaidAttendancePayload>
/**
 * Model ItemType
 * 
 */
export type ItemType = $Result.DefaultSelection<Prisma.$ItemTypePayload>
/**
 * Model Loot
 * 
 */
export type Loot = $Result.DefaultSelection<Prisma.$LootPayload>
/**
 * Model TasksUser
 * 
 */
export type TasksUser = $Result.DefaultSelection<Prisma.$TasksUserPayload>
/**
 * Model LootQueue
 * 
 */
export type LootQueue = $Result.DefaultSelection<Prisma.$LootQueuePayload>
/**
 * Model GivenAwayLoot
 * 
 */
export type GivenAwayLoot = $Result.DefaultSelection<Prisma.$GivenAwayLootPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model GuildFunds
 * 
 */
export type GuildFunds = $Result.DefaultSelection<Prisma.$GuildFundsPayload>
/**
 * Model Salary
 * 
 */
export type Salary = $Result.DefaultSelection<Prisma.$SalaryPayload>
/**
 * Model UserSalaryBonus
 * 
 */
export type UserSalaryBonus = $Result.DefaultSelection<Prisma.$UserSalaryBonusPayload>
/**
 * Model LinkToken
 * 
 */
export type LinkToken = $Result.DefaultSelection<Prisma.$LinkTokenPayload>
/**
 * Model News
 * 
 */
export type News = $Result.DefaultSelection<Prisma.$NewsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTags`: Exposes CRUD operations for the **UserTags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTags
    * const userTags = await prisma.userTags.findMany()
    * ```
    */
  get userTags(): Prisma.UserTagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userInventory`: Exposes CRUD operations for the **UserInventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInventories
    * const userInventories = await prisma.userInventory.findMany()
    * ```
    */
  get userInventory(): Prisma.UserInventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tasks`: Exposes CRUD operations for the **Tasks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.tasks.findMany()
    * ```
    */
  get tasks(): Prisma.TasksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raid`: Exposes CRUD operations for the **Raid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Raids
    * const raids = await prisma.raid.findMany()
    * ```
    */
  get raid(): Prisma.RaidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boss`: Exposes CRUD operations for the **Boss** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bosses
    * const bosses = await prisma.boss.findMany()
    * ```
    */
  get boss(): Prisma.BossDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raidBoss`: Exposes CRUD operations for the **RaidBoss** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaidBosses
    * const raidBosses = await prisma.raidBoss.findMany()
    * ```
    */
  get raidBoss(): Prisma.RaidBossDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.raidAttendance`: Exposes CRUD operations for the **RaidAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RaidAttendances
    * const raidAttendances = await prisma.raidAttendance.findMany()
    * ```
    */
  get raidAttendance(): Prisma.RaidAttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemType`: Exposes CRUD operations for the **ItemType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemTypes
    * const itemTypes = await prisma.itemType.findMany()
    * ```
    */
  get itemType(): Prisma.ItemTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loot`: Exposes CRUD operations for the **Loot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loots
    * const loots = await prisma.loot.findMany()
    * ```
    */
  get loot(): Prisma.LootDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tasksUser`: Exposes CRUD operations for the **TasksUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TasksUsers
    * const tasksUsers = await prisma.tasksUser.findMany()
    * ```
    */
  get tasksUser(): Prisma.TasksUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lootQueue`: Exposes CRUD operations for the **LootQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LootQueues
    * const lootQueues = await prisma.lootQueue.findMany()
    * ```
    */
  get lootQueue(): Prisma.LootQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.givenAwayLoot`: Exposes CRUD operations for the **GivenAwayLoot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GivenAwayLoots
    * const givenAwayLoots = await prisma.givenAwayLoot.findMany()
    * ```
    */
  get givenAwayLoot(): Prisma.GivenAwayLootDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guildFunds`: Exposes CRUD operations for the **GuildFunds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildFunds
    * const guildFunds = await prisma.guildFunds.findMany()
    * ```
    */
  get guildFunds(): Prisma.GuildFundsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salary`: Exposes CRUD operations for the **Salary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salaries
    * const salaries = await prisma.salary.findMany()
    * ```
    */
  get salary(): Prisma.SalaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSalaryBonus`: Exposes CRUD operations for the **UserSalaryBonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSalaryBonuses
    * const userSalaryBonuses = await prisma.userSalaryBonus.findMany()
    * ```
    */
  get userSalaryBonus(): Prisma.UserSalaryBonusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.linkToken`: Exposes CRUD operations for the **LinkToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LinkTokens
    * const linkTokens = await prisma.linkToken.findMany()
    * ```
    */
  get linkToken(): Prisma.LinkTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.news`: Exposes CRUD operations for the **News** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.NewsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserTags: 'UserTags',
    UserInventory: 'UserInventory',
    Tasks: 'Tasks',
    Raid: 'Raid',
    Boss: 'Boss',
    RaidBoss: 'RaidBoss',
    RaidAttendance: 'RaidAttendance',
    ItemType: 'ItemType',
    Loot: 'Loot',
    TasksUser: 'TasksUser',
    LootQueue: 'LootQueue',
    GivenAwayLoot: 'GivenAwayLoot',
    Expense: 'Expense',
    GuildFunds: 'GuildFunds',
    Salary: 'Salary',
    UserSalaryBonus: 'UserSalaryBonus',
    LinkToken: 'LinkToken',
    News: 'News'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userTags" | "userInventory" | "tasks" | "raid" | "boss" | "raidBoss" | "raidAttendance" | "itemType" | "loot" | "tasksUser" | "lootQueue" | "givenAwayLoot" | "expense" | "guildFunds" | "salary" | "userSalaryBonus" | "linkToken" | "news"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserTags: {
        payload: Prisma.$UserTagsPayload<ExtArgs>
        fields: Prisma.UserTagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          findFirst: {
            args: Prisma.UserTagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          findMany: {
            args: Prisma.UserTagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>[]
          }
          create: {
            args: Prisma.UserTagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          createMany: {
            args: Prisma.UserTagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>[]
          }
          delete: {
            args: Prisma.UserTagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          update: {
            args: Prisma.UserTagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          deleteMany: {
            args: Prisma.UserTagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>[]
          }
          upsert: {
            args: Prisma.UserTagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagsPayload>
          }
          aggregate: {
            args: Prisma.UserTagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTags>
          }
          groupBy: {
            args: Prisma.UserTagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTagsCountArgs<ExtArgs>
            result: $Utils.Optional<UserTagsCountAggregateOutputType> | number
          }
        }
      }
      UserInventory: {
        payload: Prisma.$UserInventoryPayload<ExtArgs>
        fields: Prisma.UserInventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>
          }
          findFirst: {
            args: Prisma.UserInventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>
          }
          findMany: {
            args: Prisma.UserInventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>[]
          }
          create: {
            args: Prisma.UserInventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>
          }
          createMany: {
            args: Prisma.UserInventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>[]
          }
          delete: {
            args: Prisma.UserInventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>
          }
          update: {
            args: Prisma.UserInventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>
          }
          deleteMany: {
            args: Prisma.UserInventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserInventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>[]
          }
          upsert: {
            args: Prisma.UserInventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInventoryPayload>
          }
          aggregate: {
            args: Prisma.UserInventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInventory>
          }
          groupBy: {
            args: Prisma.UserInventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInventoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserInventoryCountAggregateOutputType> | number
          }
        }
      }
      Tasks: {
        payload: Prisma.$TasksPayload<ExtArgs>
        fields: Prisma.TasksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TasksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TasksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          findFirst: {
            args: Prisma.TasksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TasksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          findMany: {
            args: Prisma.TasksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>[]
          }
          create: {
            args: Prisma.TasksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          createMany: {
            args: Prisma.TasksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TasksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>[]
          }
          delete: {
            args: Prisma.TasksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          update: {
            args: Prisma.TasksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          deleteMany: {
            args: Prisma.TasksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TasksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TasksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>[]
          }
          upsert: {
            args: Prisma.TasksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksPayload>
          }
          aggregate: {
            args: Prisma.TasksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTasks>
          }
          groupBy: {
            args: Prisma.TasksGroupByArgs<ExtArgs>
            result: $Utils.Optional<TasksGroupByOutputType>[]
          }
          count: {
            args: Prisma.TasksCountArgs<ExtArgs>
            result: $Utils.Optional<TasksCountAggregateOutputType> | number
          }
        }
      }
      Raid: {
        payload: Prisma.$RaidPayload<ExtArgs>
        fields: Prisma.RaidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          findFirst: {
            args: Prisma.RaidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          findMany: {
            args: Prisma.RaidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>[]
          }
          create: {
            args: Prisma.RaidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          createMany: {
            args: Prisma.RaidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>[]
          }
          delete: {
            args: Prisma.RaidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          update: {
            args: Prisma.RaidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          deleteMany: {
            args: Prisma.RaidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>[]
          }
          upsert: {
            args: Prisma.RaidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidPayload>
          }
          aggregate: {
            args: Prisma.RaidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaid>
          }
          groupBy: {
            args: Prisma.RaidGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaidGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaidCountArgs<ExtArgs>
            result: $Utils.Optional<RaidCountAggregateOutputType> | number
          }
        }
      }
      Boss: {
        payload: Prisma.$BossPayload<ExtArgs>
        fields: Prisma.BossFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BossFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BossFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>
          }
          findFirst: {
            args: Prisma.BossFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BossFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>
          }
          findMany: {
            args: Prisma.BossFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>[]
          }
          create: {
            args: Prisma.BossCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>
          }
          createMany: {
            args: Prisma.BossCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BossCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>[]
          }
          delete: {
            args: Prisma.BossDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>
          }
          update: {
            args: Prisma.BossUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>
          }
          deleteMany: {
            args: Prisma.BossDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BossUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BossUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>[]
          }
          upsert: {
            args: Prisma.BossUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BossPayload>
          }
          aggregate: {
            args: Prisma.BossAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoss>
          }
          groupBy: {
            args: Prisma.BossGroupByArgs<ExtArgs>
            result: $Utils.Optional<BossGroupByOutputType>[]
          }
          count: {
            args: Prisma.BossCountArgs<ExtArgs>
            result: $Utils.Optional<BossCountAggregateOutputType> | number
          }
        }
      }
      RaidBoss: {
        payload: Prisma.$RaidBossPayload<ExtArgs>
        fields: Prisma.RaidBossFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaidBossFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaidBossFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>
          }
          findFirst: {
            args: Prisma.RaidBossFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaidBossFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>
          }
          findMany: {
            args: Prisma.RaidBossFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>[]
          }
          create: {
            args: Prisma.RaidBossCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>
          }
          createMany: {
            args: Prisma.RaidBossCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaidBossCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>[]
          }
          delete: {
            args: Prisma.RaidBossDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>
          }
          update: {
            args: Prisma.RaidBossUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>
          }
          deleteMany: {
            args: Prisma.RaidBossDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaidBossUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaidBossUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>[]
          }
          upsert: {
            args: Prisma.RaidBossUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidBossPayload>
          }
          aggregate: {
            args: Prisma.RaidBossAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaidBoss>
          }
          groupBy: {
            args: Prisma.RaidBossGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaidBossGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaidBossCountArgs<ExtArgs>
            result: $Utils.Optional<RaidBossCountAggregateOutputType> | number
          }
        }
      }
      RaidAttendance: {
        payload: Prisma.$RaidAttendancePayload<ExtArgs>
        fields: Prisma.RaidAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaidAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaidAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>
          }
          findFirst: {
            args: Prisma.RaidAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaidAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>
          }
          findMany: {
            args: Prisma.RaidAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>[]
          }
          create: {
            args: Prisma.RaidAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>
          }
          createMany: {
            args: Prisma.RaidAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaidAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>[]
          }
          delete: {
            args: Prisma.RaidAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>
          }
          update: {
            args: Prisma.RaidAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>
          }
          deleteMany: {
            args: Prisma.RaidAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaidAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RaidAttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>[]
          }
          upsert: {
            args: Prisma.RaidAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RaidAttendancePayload>
          }
          aggregate: {
            args: Prisma.RaidAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaidAttendance>
          }
          groupBy: {
            args: Prisma.RaidAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaidAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaidAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<RaidAttendanceCountAggregateOutputType> | number
          }
        }
      }
      ItemType: {
        payload: Prisma.$ItemTypePayload<ExtArgs>
        fields: Prisma.ItemTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          findFirst: {
            args: Prisma.ItemTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          findMany: {
            args: Prisma.ItemTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>[]
          }
          create: {
            args: Prisma.ItemTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          createMany: {
            args: Prisma.ItemTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>[]
          }
          delete: {
            args: Prisma.ItemTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          update: {
            args: Prisma.ItemTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          deleteMany: {
            args: Prisma.ItemTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>[]
          }
          upsert: {
            args: Prisma.ItemTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          aggregate: {
            args: Prisma.ItemTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemType>
          }
          groupBy: {
            args: Prisma.ItemTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ItemTypeCountAggregateOutputType> | number
          }
        }
      }
      Loot: {
        payload: Prisma.$LootPayload<ExtArgs>
        fields: Prisma.LootFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LootFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LootFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>
          }
          findFirst: {
            args: Prisma.LootFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LootFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>
          }
          findMany: {
            args: Prisma.LootFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>[]
          }
          create: {
            args: Prisma.LootCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>
          }
          createMany: {
            args: Prisma.LootCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LootCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>[]
          }
          delete: {
            args: Prisma.LootDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>
          }
          update: {
            args: Prisma.LootUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>
          }
          deleteMany: {
            args: Prisma.LootDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LootUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LootUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>[]
          }
          upsert: {
            args: Prisma.LootUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootPayload>
          }
          aggregate: {
            args: Prisma.LootAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoot>
          }
          groupBy: {
            args: Prisma.LootGroupByArgs<ExtArgs>
            result: $Utils.Optional<LootGroupByOutputType>[]
          }
          count: {
            args: Prisma.LootCountArgs<ExtArgs>
            result: $Utils.Optional<LootCountAggregateOutputType> | number
          }
        }
      }
      TasksUser: {
        payload: Prisma.$TasksUserPayload<ExtArgs>
        fields: Prisma.TasksUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TasksUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TasksUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>
          }
          findFirst: {
            args: Prisma.TasksUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TasksUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>
          }
          findMany: {
            args: Prisma.TasksUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>[]
          }
          create: {
            args: Prisma.TasksUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>
          }
          createMany: {
            args: Prisma.TasksUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TasksUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>[]
          }
          delete: {
            args: Prisma.TasksUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>
          }
          update: {
            args: Prisma.TasksUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>
          }
          deleteMany: {
            args: Prisma.TasksUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TasksUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TasksUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>[]
          }
          upsert: {
            args: Prisma.TasksUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TasksUserPayload>
          }
          aggregate: {
            args: Prisma.TasksUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTasksUser>
          }
          groupBy: {
            args: Prisma.TasksUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<TasksUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.TasksUserCountArgs<ExtArgs>
            result: $Utils.Optional<TasksUserCountAggregateOutputType> | number
          }
        }
      }
      LootQueue: {
        payload: Prisma.$LootQueuePayload<ExtArgs>
        fields: Prisma.LootQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LootQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LootQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>
          }
          findFirst: {
            args: Prisma.LootQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LootQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>
          }
          findMany: {
            args: Prisma.LootQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>[]
          }
          create: {
            args: Prisma.LootQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>
          }
          createMany: {
            args: Prisma.LootQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LootQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>[]
          }
          delete: {
            args: Prisma.LootQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>
          }
          update: {
            args: Prisma.LootQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>
          }
          deleteMany: {
            args: Prisma.LootQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LootQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LootQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>[]
          }
          upsert: {
            args: Prisma.LootQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LootQueuePayload>
          }
          aggregate: {
            args: Prisma.LootQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLootQueue>
          }
          groupBy: {
            args: Prisma.LootQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<LootQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.LootQueueCountArgs<ExtArgs>
            result: $Utils.Optional<LootQueueCountAggregateOutputType> | number
          }
        }
      }
      GivenAwayLoot: {
        payload: Prisma.$GivenAwayLootPayload<ExtArgs>
        fields: Prisma.GivenAwayLootFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GivenAwayLootFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenAwayLootPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GivenAwayLootFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenAwayLootPayload>
          }
          findFirst: {
            args: Prisma.GivenAwayLootFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenAwayLootPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GivenAwayLootFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenAwayLootPayload>
          }
          findMany: {
            args: Prisma.GivenAwayLootFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenAwayLootPayload>[]
          }
          create: {
            args: Prisma.GivenAwayLootCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenAwayLootPayload>
          }
          createMany: {
            args: Prisma.GivenAwayLootCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GivenAwayLootCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenAwayLootPayload>[]
          }
          delete: {
            args: Prisma.GivenAwayLootDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenAwayLootPayload>
          }
          update: {
            args: Prisma.GivenAwayLootUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenAwayLootPayload>
          }
          deleteMany: {
            args: Prisma.GivenAwayLootDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GivenAwayLootUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GivenAwayLootUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenAwayLootPayload>[]
          }
          upsert: {
            args: Prisma.GivenAwayLootUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenAwayLootPayload>
          }
          aggregate: {
            args: Prisma.GivenAwayLootAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGivenAwayLoot>
          }
          groupBy: {
            args: Prisma.GivenAwayLootGroupByArgs<ExtArgs>
            result: $Utils.Optional<GivenAwayLootGroupByOutputType>[]
          }
          count: {
            args: Prisma.GivenAwayLootCountArgs<ExtArgs>
            result: $Utils.Optional<GivenAwayLootCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      GuildFunds: {
        payload: Prisma.$GuildFundsPayload<ExtArgs>
        fields: Prisma.GuildFundsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildFundsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFundsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildFundsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFundsPayload>
          }
          findFirst: {
            args: Prisma.GuildFundsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFundsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildFundsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFundsPayload>
          }
          findMany: {
            args: Prisma.GuildFundsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFundsPayload>[]
          }
          create: {
            args: Prisma.GuildFundsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFundsPayload>
          }
          createMany: {
            args: Prisma.GuildFundsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuildFundsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFundsPayload>[]
          }
          delete: {
            args: Prisma.GuildFundsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFundsPayload>
          }
          update: {
            args: Prisma.GuildFundsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFundsPayload>
          }
          deleteMany: {
            args: Prisma.GuildFundsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuildFundsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuildFundsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFundsPayload>[]
          }
          upsert: {
            args: Prisma.GuildFundsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuildFundsPayload>
          }
          aggregate: {
            args: Prisma.GuildFundsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuildFunds>
          }
          groupBy: {
            args: Prisma.GuildFundsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuildFundsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildFundsCountArgs<ExtArgs>
            result: $Utils.Optional<GuildFundsCountAggregateOutputType> | number
          }
        }
      }
      Salary: {
        payload: Prisma.$SalaryPayload<ExtArgs>
        fields: Prisma.SalaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          findFirst: {
            args: Prisma.SalaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          findMany: {
            args: Prisma.SalaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>[]
          }
          create: {
            args: Prisma.SalaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          createMany: {
            args: Prisma.SalaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>[]
          }
          delete: {
            args: Prisma.SalaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          update: {
            args: Prisma.SalaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          deleteMany: {
            args: Prisma.SalaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>[]
          }
          upsert: {
            args: Prisma.SalaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          aggregate: {
            args: Prisma.SalaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalary>
          }
          groupBy: {
            args: Prisma.SalaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryCountAggregateOutputType> | number
          }
        }
      }
      UserSalaryBonus: {
        payload: Prisma.$UserSalaryBonusPayload<ExtArgs>
        fields: Prisma.UserSalaryBonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSalaryBonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSalaryBonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSalaryBonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSalaryBonusPayload>
          }
          findFirst: {
            args: Prisma.UserSalaryBonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSalaryBonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSalaryBonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSalaryBonusPayload>
          }
          findMany: {
            args: Prisma.UserSalaryBonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSalaryBonusPayload>[]
          }
          create: {
            args: Prisma.UserSalaryBonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSalaryBonusPayload>
          }
          createMany: {
            args: Prisma.UserSalaryBonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSalaryBonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSalaryBonusPayload>[]
          }
          delete: {
            args: Prisma.UserSalaryBonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSalaryBonusPayload>
          }
          update: {
            args: Prisma.UserSalaryBonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSalaryBonusPayload>
          }
          deleteMany: {
            args: Prisma.UserSalaryBonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSalaryBonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSalaryBonusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSalaryBonusPayload>[]
          }
          upsert: {
            args: Prisma.UserSalaryBonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSalaryBonusPayload>
          }
          aggregate: {
            args: Prisma.UserSalaryBonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSalaryBonus>
          }
          groupBy: {
            args: Prisma.UserSalaryBonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSalaryBonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSalaryBonusCountArgs<ExtArgs>
            result: $Utils.Optional<UserSalaryBonusCountAggregateOutputType> | number
          }
        }
      }
      LinkToken: {
        payload: Prisma.$LinkTokenPayload<ExtArgs>
        fields: Prisma.LinkTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinkTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinkTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkTokenPayload>
          }
          findFirst: {
            args: Prisma.LinkTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinkTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkTokenPayload>
          }
          findMany: {
            args: Prisma.LinkTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkTokenPayload>[]
          }
          create: {
            args: Prisma.LinkTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkTokenPayload>
          }
          createMany: {
            args: Prisma.LinkTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LinkTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkTokenPayload>[]
          }
          delete: {
            args: Prisma.LinkTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkTokenPayload>
          }
          update: {
            args: Prisma.LinkTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkTokenPayload>
          }
          deleteMany: {
            args: Prisma.LinkTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LinkTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LinkTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkTokenPayload>[]
          }
          upsert: {
            args: Prisma.LinkTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkTokenPayload>
          }
          aggregate: {
            args: Prisma.LinkTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLinkToken>
          }
          groupBy: {
            args: Prisma.LinkTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinkTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinkTokenCountArgs<ExtArgs>
            result: $Utils.Optional<LinkTokenCountAggregateOutputType> | number
          }
        }
      }
      News: {
        payload: Prisma.$NewsPayload<ExtArgs>
        fields: Prisma.NewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findFirst: {
            args: Prisma.NewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          findMany: {
            args: Prisma.NewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          create: {
            args: Prisma.NewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          createMany: {
            args: Prisma.NewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          delete: {
            args: Prisma.NewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          update: {
            args: Prisma.NewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          deleteMany: {
            args: Prisma.NewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>[]
          }
          upsert: {
            args: Prisma.NewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsPayload>
          }
          aggregate: {
            args: Prisma.NewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNews>
          }
          groupBy: {
            args: Prisma.NewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsCountArgs<ExtArgs>
            result: $Utils.Optional<NewsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userTags?: UserTagsOmit
    userInventory?: UserInventoryOmit
    tasks?: TasksOmit
    raid?: RaidOmit
    boss?: BossOmit
    raidBoss?: RaidBossOmit
    raidAttendance?: RaidAttendanceOmit
    itemType?: ItemTypeOmit
    loot?: LootOmit
    tasksUser?: TasksUserOmit
    lootQueue?: LootQueueOmit
    givenAwayLoot?: GivenAwayLootOmit
    expense?: ExpenseOmit
    guildFunds?: GuildFundsOmit
    salary?: SalaryOmit
    userSalaryBonus?: UserSalaryBonusOmit
    linkToken?: LinkTokenOmit
    news?: NewsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    salaries: number
    givenAwayLoot: number
    soldLoot: number
    lootQueue: number
    raidAttendance: number
    tasks: number
    tasksAssigned: number
    inventory: number
    salaryBonuses: number
    tags: number
    linkTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salaries?: boolean | UserCountOutputTypeCountSalariesArgs
    givenAwayLoot?: boolean | UserCountOutputTypeCountGivenAwayLootArgs
    soldLoot?: boolean | UserCountOutputTypeCountSoldLootArgs
    lootQueue?: boolean | UserCountOutputTypeCountLootQueueArgs
    raidAttendance?: boolean | UserCountOutputTypeCountRaidAttendanceArgs
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    tasksAssigned?: boolean | UserCountOutputTypeCountTasksAssignedArgs
    inventory?: boolean | UserCountOutputTypeCountInventoryArgs
    salaryBonuses?: boolean | UserCountOutputTypeCountSalaryBonusesArgs
    tags?: boolean | UserCountOutputTypeCountTagsArgs
    linkTokens?: boolean | UserCountOutputTypeCountLinkTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGivenAwayLootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GivenAwayLootWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSoldLootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LootWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLootQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LootQueueWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRaidAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidAttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInventoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalaryBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSalaryBonusWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLinkTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkTokenWhereInput
  }


  /**
   * Count Type TasksCountOutputType
   */

  export type TasksCountOutputType = {
    assignedTo: number
  }

  export type TasksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | TasksCountOutputTypeCountAssignedToArgs
  }

  // Custom InputTypes
  /**
   * TasksCountOutputType without action
   */
  export type TasksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksCountOutputType
     */
    select?: TasksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TasksCountOutputType without action
   */
  export type TasksCountOutputTypeCountAssignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksUserWhereInput
  }


  /**
   * Count Type RaidCountOutputType
   */

  export type RaidCountOutputType = {
    attendance: number
    raidBosses: number
  }

  export type RaidCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | RaidCountOutputTypeCountAttendanceArgs
    raidBosses?: boolean | RaidCountOutputTypeCountRaidBossesArgs
  }

  // Custom InputTypes
  /**
   * RaidCountOutputType without action
   */
  export type RaidCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidCountOutputType
     */
    select?: RaidCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaidCountOutputType without action
   */
  export type RaidCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidAttendanceWhereInput
  }

  /**
   * RaidCountOutputType without action
   */
  export type RaidCountOutputTypeCountRaidBossesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidBossWhereInput
  }


  /**
   * Count Type BossCountOutputType
   */

  export type BossCountOutputType = {
    raidBosses: number
  }

  export type BossCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raidBosses?: boolean | BossCountOutputTypeCountRaidBossesArgs
  }

  // Custom InputTypes
  /**
   * BossCountOutputType without action
   */
  export type BossCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BossCountOutputType
     */
    select?: BossCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BossCountOutputType without action
   */
  export type BossCountOutputTypeCountRaidBossesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidBossWhereInput
  }


  /**
   * Count Type ItemTypeCountOutputType
   */

  export type ItemTypeCountOutputType = {
    loot: number
    lootQueue: number
  }

  export type ItemTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loot?: boolean | ItemTypeCountOutputTypeCountLootArgs
    lootQueue?: boolean | ItemTypeCountOutputTypeCountLootQueueArgs
  }

  // Custom InputTypes
  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTypeCountOutputType
     */
    select?: ItemTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeCountLootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LootWhereInput
  }

  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeCountLootQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LootQueueWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    class_gear_score: number | null
    secondary_class_gear_score: number | null
    salaryBonus: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    class_gear_score: number | null
    secondary_class_gear_score: number | null
    salaryBonus: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    class: string | null
    secondary_class: string | null
    class_gear_score: number | null
    secondary_class_gear_score: number | null
    vk_name: string | null
    active: boolean | null
    is_eligible_for_salary: boolean | null
    joined_at: Date | null
    created_at: Date | null
    salaryBonus: number | null
    googleId: string | null
    vkId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    class: string | null
    secondary_class: string | null
    class_gear_score: number | null
    secondary_class_gear_score: number | null
    vk_name: string | null
    active: boolean | null
    is_eligible_for_salary: boolean | null
    joined_at: Date | null
    created_at: Date | null
    salaryBonus: number | null
    googleId: string | null
    vkId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    class: number
    secondary_class: number
    class_gear_score: number
    secondary_class_gear_score: number
    vk_name: number
    active: number
    is_eligible_for_salary: number
    joined_at: number
    created_at: number
    salaryBonus: number
    googleId: number
    vkId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    class_gear_score?: true
    secondary_class_gear_score?: true
    salaryBonus?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    class_gear_score?: true
    secondary_class_gear_score?: true
    salaryBonus?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    class?: true
    secondary_class?: true
    class_gear_score?: true
    secondary_class_gear_score?: true
    vk_name?: true
    active?: true
    is_eligible_for_salary?: true
    joined_at?: true
    created_at?: true
    salaryBonus?: true
    googleId?: true
    vkId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    class?: true
    secondary_class?: true
    class_gear_score?: true
    secondary_class_gear_score?: true
    vk_name?: true
    active?: true
    is_eligible_for_salary?: true
    joined_at?: true
    created_at?: true
    salaryBonus?: true
    googleId?: true
    vkId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    class?: true
    secondary_class?: true
    class_gear_score?: true
    secondary_class_gear_score?: true
    vk_name?: true
    active?: true
    is_eligible_for_salary?: true
    joined_at?: true
    created_at?: true
    salaryBonus?: true
    googleId?: true
    vkId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    class: string | null
    secondary_class: string | null
    class_gear_score: number | null
    secondary_class_gear_score: number | null
    vk_name: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at: Date | null
    created_at: Date
    salaryBonus: number | null
    googleId: string | null
    vkId: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    class?: boolean
    secondary_class?: boolean
    class_gear_score?: boolean
    secondary_class_gear_score?: boolean
    vk_name?: boolean
    active?: boolean
    is_eligible_for_salary?: boolean
    joined_at?: boolean
    created_at?: boolean
    salaryBonus?: boolean
    googleId?: boolean
    vkId?: boolean
    salaries?: boolean | User$salariesArgs<ExtArgs>
    givenAwayLoot?: boolean | User$givenAwayLootArgs<ExtArgs>
    soldLoot?: boolean | User$soldLootArgs<ExtArgs>
    lootQueue?: boolean | User$lootQueueArgs<ExtArgs>
    raidAttendance?: boolean | User$raidAttendanceArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    tasksAssigned?: boolean | User$tasksAssignedArgs<ExtArgs>
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    salaryBonuses?: boolean | User$salaryBonusesArgs<ExtArgs>
    tags?: boolean | User$tagsArgs<ExtArgs>
    linkTokens?: boolean | User$linkTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    class?: boolean
    secondary_class?: boolean
    class_gear_score?: boolean
    secondary_class_gear_score?: boolean
    vk_name?: boolean
    active?: boolean
    is_eligible_for_salary?: boolean
    joined_at?: boolean
    created_at?: boolean
    salaryBonus?: boolean
    googleId?: boolean
    vkId?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    class?: boolean
    secondary_class?: boolean
    class_gear_score?: boolean
    secondary_class_gear_score?: boolean
    vk_name?: boolean
    active?: boolean
    is_eligible_for_salary?: boolean
    joined_at?: boolean
    created_at?: boolean
    salaryBonus?: boolean
    googleId?: boolean
    vkId?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    class?: boolean
    secondary_class?: boolean
    class_gear_score?: boolean
    secondary_class_gear_score?: boolean
    vk_name?: boolean
    active?: boolean
    is_eligible_for_salary?: boolean
    joined_at?: boolean
    created_at?: boolean
    salaryBonus?: boolean
    googleId?: boolean
    vkId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "class" | "secondary_class" | "class_gear_score" | "secondary_class_gear_score" | "vk_name" | "active" | "is_eligible_for_salary" | "joined_at" | "created_at" | "salaryBonus" | "googleId" | "vkId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salaries?: boolean | User$salariesArgs<ExtArgs>
    givenAwayLoot?: boolean | User$givenAwayLootArgs<ExtArgs>
    soldLoot?: boolean | User$soldLootArgs<ExtArgs>
    lootQueue?: boolean | User$lootQueueArgs<ExtArgs>
    raidAttendance?: boolean | User$raidAttendanceArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    tasksAssigned?: boolean | User$tasksAssignedArgs<ExtArgs>
    inventory?: boolean | User$inventoryArgs<ExtArgs>
    salaryBonuses?: boolean | User$salaryBonusesArgs<ExtArgs>
    tags?: boolean | User$tagsArgs<ExtArgs>
    linkTokens?: boolean | User$linkTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      salaries: Prisma.$SalaryPayload<ExtArgs>[]
      givenAwayLoot: Prisma.$GivenAwayLootPayload<ExtArgs>[]
      soldLoot: Prisma.$LootPayload<ExtArgs>[]
      lootQueue: Prisma.$LootQueuePayload<ExtArgs>[]
      raidAttendance: Prisma.$RaidAttendancePayload<ExtArgs>[]
      tasks: Prisma.$TasksPayload<ExtArgs>[]
      tasksAssigned: Prisma.$TasksUserPayload<ExtArgs>[]
      inventory: Prisma.$UserInventoryPayload<ExtArgs>[]
      salaryBonuses: Prisma.$UserSalaryBonusPayload<ExtArgs>[]
      tags: Prisma.$UserTagsPayload<ExtArgs>[]
      linkTokens: Prisma.$LinkTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      class: string | null
      secondary_class: string | null
      class_gear_score: number | null
      secondary_class_gear_score: number | null
      vk_name: string | null
      active: boolean
      is_eligible_for_salary: boolean
      joined_at: Date | null
      created_at: Date
      salaryBonus: number | null
      googleId: string | null
      vkId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salaries<T extends User$salariesArgs<ExtArgs> = {}>(args?: Subset<T, User$salariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    givenAwayLoot<T extends User$givenAwayLootArgs<ExtArgs> = {}>(args?: Subset<T, User$givenAwayLootArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GivenAwayLootPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soldLoot<T extends User$soldLootArgs<ExtArgs> = {}>(args?: Subset<T, User$soldLootArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lootQueue<T extends User$lootQueueArgs<ExtArgs> = {}>(args?: Subset<T, User$lootQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raidAttendance<T extends User$raidAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, User$raidAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends User$tasksArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasksAssigned<T extends User$tasksAssignedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory<T extends User$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salaryBonuses<T extends User$salaryBonusesArgs<ExtArgs> = {}>(args?: Subset<T, User$salaryBonusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSalaryBonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends User$tagsArgs<ExtArgs> = {}>(args?: Subset<T, User$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    linkTokens<T extends User$linkTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$linkTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly class: FieldRef<"User", 'String'>
    readonly secondary_class: FieldRef<"User", 'String'>
    readonly class_gear_score: FieldRef<"User", 'Int'>
    readonly secondary_class_gear_score: FieldRef<"User", 'Int'>
    readonly vk_name: FieldRef<"User", 'String'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly is_eligible_for_salary: FieldRef<"User", 'Boolean'>
    readonly joined_at: FieldRef<"User", 'DateTime'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly salaryBonus: FieldRef<"User", 'Int'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly vkId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.salaries
   */
  export type User$salariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    where?: SalaryWhereInput
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    cursor?: SalaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * User.givenAwayLoot
   */
  export type User$givenAwayLootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootInclude<ExtArgs> | null
    where?: GivenAwayLootWhereInput
    orderBy?: GivenAwayLootOrderByWithRelationInput | GivenAwayLootOrderByWithRelationInput[]
    cursor?: GivenAwayLootWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GivenAwayLootScalarFieldEnum | GivenAwayLootScalarFieldEnum[]
  }

  /**
   * User.soldLoot
   */
  export type User$soldLootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    where?: LootWhereInput
    orderBy?: LootOrderByWithRelationInput | LootOrderByWithRelationInput[]
    cursor?: LootWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LootScalarFieldEnum | LootScalarFieldEnum[]
  }

  /**
   * User.lootQueue
   */
  export type User$lootQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    where?: LootQueueWhereInput
    orderBy?: LootQueueOrderByWithRelationInput | LootQueueOrderByWithRelationInput[]
    cursor?: LootQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LootQueueScalarFieldEnum | LootQueueScalarFieldEnum[]
  }

  /**
   * User.raidAttendance
   */
  export type User$raidAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    where?: RaidAttendanceWhereInput
    orderBy?: RaidAttendanceOrderByWithRelationInput | RaidAttendanceOrderByWithRelationInput[]
    cursor?: RaidAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaidAttendanceScalarFieldEnum | RaidAttendanceScalarFieldEnum[]
  }

  /**
   * User.tasks
   */
  export type User$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    where?: TasksWhereInput
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    cursor?: TasksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * User.tasksAssigned
   */
  export type User$tasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    where?: TasksUserWhereInput
    orderBy?: TasksUserOrderByWithRelationInput | TasksUserOrderByWithRelationInput[]
    cursor?: TasksUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TasksUserScalarFieldEnum | TasksUserScalarFieldEnum[]
  }

  /**
   * User.inventory
   */
  export type User$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    where?: UserInventoryWhereInput
    orderBy?: UserInventoryOrderByWithRelationInput | UserInventoryOrderByWithRelationInput[]
    cursor?: UserInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInventoryScalarFieldEnum | UserInventoryScalarFieldEnum[]
  }

  /**
   * User.salaryBonuses
   */
  export type User$salaryBonusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusInclude<ExtArgs> | null
    where?: UserSalaryBonusWhereInput
    orderBy?: UserSalaryBonusOrderByWithRelationInput | UserSalaryBonusOrderByWithRelationInput[]
    cursor?: UserSalaryBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSalaryBonusScalarFieldEnum | UserSalaryBonusScalarFieldEnum[]
  }

  /**
   * User.tags
   */
  export type User$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    where?: UserTagsWhereInput
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    cursor?: UserTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * User.linkTokens
   */
  export type User$linkTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenInclude<ExtArgs> | null
    where?: LinkTokenWhereInput
    orderBy?: LinkTokenOrderByWithRelationInput | LinkTokenOrderByWithRelationInput[]
    cursor?: LinkTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkTokenScalarFieldEnum | LinkTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserTags
   */

  export type AggregateUserTags = {
    _count: UserTagsCountAggregateOutputType | null
    _avg: UserTagsAvgAggregateOutputType | null
    _sum: UserTagsSumAggregateOutputType | null
    _min: UserTagsMinAggregateOutputType | null
    _max: UserTagsMaxAggregateOutputType | null
  }

  export type UserTagsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type UserTagsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type UserTagsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    tag: string | null
    created_at: Date | null
  }

  export type UserTagsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    tag: string | null
    created_at: Date | null
  }

  export type UserTagsCountAggregateOutputType = {
    id: number
    user_id: number
    tag: number
    created_at: number
    _all: number
  }


  export type UserTagsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserTagsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserTagsMinAggregateInputType = {
    id?: true
    user_id?: true
    tag?: true
    created_at?: true
  }

  export type UserTagsMaxAggregateInputType = {
    id?: true
    user_id?: true
    tag?: true
    created_at?: true
  }

  export type UserTagsCountAggregateInputType = {
    id?: true
    user_id?: true
    tag?: true
    created_at?: true
    _all?: true
  }

  export type UserTagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTags to aggregate.
     */
    where?: UserTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTags
    **/
    _count?: true | UserTagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTagsMaxAggregateInputType
  }

  export type GetUserTagsAggregateType<T extends UserTagsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTags[P]>
      : GetScalarType<T[P], AggregateUserTags[P]>
  }




  export type UserTagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagsWhereInput
    orderBy?: UserTagsOrderByWithAggregationInput | UserTagsOrderByWithAggregationInput[]
    by: UserTagsScalarFieldEnum[] | UserTagsScalarFieldEnum
    having?: UserTagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTagsCountAggregateInputType | true
    _avg?: UserTagsAvgAggregateInputType
    _sum?: UserTagsSumAggregateInputType
    _min?: UserTagsMinAggregateInputType
    _max?: UserTagsMaxAggregateInputType
  }

  export type UserTagsGroupByOutputType = {
    id: number
    user_id: number
    tag: string
    created_at: Date
    _count: UserTagsCountAggregateOutputType | null
    _avg: UserTagsAvgAggregateOutputType | null
    _sum: UserTagsSumAggregateOutputType | null
    _min: UserTagsMinAggregateOutputType | null
    _max: UserTagsMaxAggregateOutputType | null
  }

  type GetUserTagsGroupByPayload<T extends UserTagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTagsGroupByOutputType[P]>
            : GetScalarType<T[P], UserTagsGroupByOutputType[P]>
        }
      >
    >


  export type UserTagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    tag?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTags"]>

  export type UserTagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    tag?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTags"]>

  export type UserTagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    tag?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTags"]>

  export type UserTagsSelectScalar = {
    id?: boolean
    user_id?: boolean
    tag?: boolean
    created_at?: boolean
  }

  export type UserTagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "tag" | "created_at", ExtArgs["result"]["userTags"]>
  export type UserTagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserTagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserTagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserTagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTags"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      tag: string
      created_at: Date
    }, ExtArgs["result"]["userTags"]>
    composites: {}
  }

  type UserTagsGetPayload<S extends boolean | null | undefined | UserTagsDefaultArgs> = $Result.GetResult<Prisma.$UserTagsPayload, S>

  type UserTagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTagsCountAggregateInputType | true
    }

  export interface UserTagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTags'], meta: { name: 'UserTags' } }
    /**
     * Find zero or one UserTags that matches the filter.
     * @param {UserTagsFindUniqueArgs} args - Arguments to find a UserTags
     * @example
     * // Get one UserTags
     * const userTags = await prisma.userTags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTagsFindUniqueArgs>(args: SelectSubset<T, UserTagsFindUniqueArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTagsFindUniqueOrThrowArgs} args - Arguments to find a UserTags
     * @example
     * // Get one UserTags
     * const userTags = await prisma.userTags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTagsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsFindFirstArgs} args - Arguments to find a UserTags
     * @example
     * // Get one UserTags
     * const userTags = await prisma.userTags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTagsFindFirstArgs>(args?: SelectSubset<T, UserTagsFindFirstArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsFindFirstOrThrowArgs} args - Arguments to find a UserTags
     * @example
     * // Get one UserTags
     * const userTags = await prisma.userTags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTagsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTags
     * const userTags = await prisma.userTags.findMany()
     * 
     * // Get first 10 UserTags
     * const userTags = await prisma.userTags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTagsWithIdOnly = await prisma.userTags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTagsFindManyArgs>(args?: SelectSubset<T, UserTagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTags.
     * @param {UserTagsCreateArgs} args - Arguments to create a UserTags.
     * @example
     * // Create one UserTags
     * const UserTags = await prisma.userTags.create({
     *   data: {
     *     // ... data to create a UserTags
     *   }
     * })
     * 
     */
    create<T extends UserTagsCreateArgs>(args: SelectSubset<T, UserTagsCreateArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTags.
     * @param {UserTagsCreateManyArgs} args - Arguments to create many UserTags.
     * @example
     * // Create many UserTags
     * const userTags = await prisma.userTags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTagsCreateManyArgs>(args?: SelectSubset<T, UserTagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTags and returns the data saved in the database.
     * @param {UserTagsCreateManyAndReturnArgs} args - Arguments to create many UserTags.
     * @example
     * // Create many UserTags
     * const userTags = await prisma.userTags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTags and only return the `id`
     * const userTagsWithIdOnly = await prisma.userTags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTagsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTags.
     * @param {UserTagsDeleteArgs} args - Arguments to delete one UserTags.
     * @example
     * // Delete one UserTags
     * const UserTags = await prisma.userTags.delete({
     *   where: {
     *     // ... filter to delete one UserTags
     *   }
     * })
     * 
     */
    delete<T extends UserTagsDeleteArgs>(args: SelectSubset<T, UserTagsDeleteArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTags.
     * @param {UserTagsUpdateArgs} args - Arguments to update one UserTags.
     * @example
     * // Update one UserTags
     * const userTags = await prisma.userTags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTagsUpdateArgs>(args: SelectSubset<T, UserTagsUpdateArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTags.
     * @param {UserTagsDeleteManyArgs} args - Arguments to filter UserTags to delete.
     * @example
     * // Delete a few UserTags
     * const { count } = await prisma.userTags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTagsDeleteManyArgs>(args?: SelectSubset<T, UserTagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTags
     * const userTags = await prisma.userTags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTagsUpdateManyArgs>(args: SelectSubset<T, UserTagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTags and returns the data updated in the database.
     * @param {UserTagsUpdateManyAndReturnArgs} args - Arguments to update many UserTags.
     * @example
     * // Update many UserTags
     * const userTags = await prisma.userTags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTags and only return the `id`
     * const userTagsWithIdOnly = await prisma.userTags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTagsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTags.
     * @param {UserTagsUpsertArgs} args - Arguments to update or create a UserTags.
     * @example
     * // Update or create a UserTags
     * const userTags = await prisma.userTags.upsert({
     *   create: {
     *     // ... data to create a UserTags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTags we want to update
     *   }
     * })
     */
    upsert<T extends UserTagsUpsertArgs>(args: SelectSubset<T, UserTagsUpsertArgs<ExtArgs>>): Prisma__UserTagsClient<$Result.GetResult<Prisma.$UserTagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsCountArgs} args - Arguments to filter UserTags to count.
     * @example
     * // Count the number of UserTags
     * const count = await prisma.userTags.count({
     *   where: {
     *     // ... the filter for the UserTags we want to count
     *   }
     * })
    **/
    count<T extends UserTagsCountArgs>(
      args?: Subset<T, UserTagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTagsAggregateArgs>(args: Subset<T, UserTagsAggregateArgs>): Prisma.PrismaPromise<GetUserTagsAggregateType<T>>

    /**
     * Group by UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTagsGroupByArgs['orderBy'] }
        : { orderBy?: UserTagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTags model
   */
  readonly fields: UserTagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTags model
   */
  interface UserTagsFieldRefs {
    readonly id: FieldRef<"UserTags", 'Int'>
    readonly user_id: FieldRef<"UserTags", 'Int'>
    readonly tag: FieldRef<"UserTags", 'String'>
    readonly created_at: FieldRef<"UserTags", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTags findUnique
   */
  export type UserTagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where: UserTagsWhereUniqueInput
  }

  /**
   * UserTags findUniqueOrThrow
   */
  export type UserTagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where: UserTagsWhereUniqueInput
  }

  /**
   * UserTags findFirst
   */
  export type UserTagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where?: UserTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     */
    cursor?: UserTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     */
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * UserTags findFirstOrThrow
   */
  export type UserTagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where?: UserTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     */
    cursor?: UserTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     */
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * UserTags findMany
   */
  export type UserTagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where?: UserTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagsOrderByWithRelationInput | UserTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTags.
     */
    cursor?: UserTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    distinct?: UserTagsScalarFieldEnum | UserTagsScalarFieldEnum[]
  }

  /**
   * UserTags create
   */
  export type UserTagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTags.
     */
    data: XOR<UserTagsCreateInput, UserTagsUncheckedCreateInput>
  }

  /**
   * UserTags createMany
   */
  export type UserTagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTags.
     */
    data: UserTagsCreateManyInput | UserTagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTags createManyAndReturn
   */
  export type UserTagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * The data used to create many UserTags.
     */
    data: UserTagsCreateManyInput | UserTagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTags update
   */
  export type UserTagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTags.
     */
    data: XOR<UserTagsUpdateInput, UserTagsUncheckedUpdateInput>
    /**
     * Choose, which UserTags to update.
     */
    where: UserTagsWhereUniqueInput
  }

  /**
   * UserTags updateMany
   */
  export type UserTagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTags.
     */
    data: XOR<UserTagsUpdateManyMutationInput, UserTagsUncheckedUpdateManyInput>
    /**
     * Filter which UserTags to update
     */
    where?: UserTagsWhereInput
    /**
     * Limit how many UserTags to update.
     */
    limit?: number
  }

  /**
   * UserTags updateManyAndReturn
   */
  export type UserTagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * The data used to update UserTags.
     */
    data: XOR<UserTagsUpdateManyMutationInput, UserTagsUncheckedUpdateManyInput>
    /**
     * Filter which UserTags to update
     */
    where?: UserTagsWhereInput
    /**
     * Limit how many UserTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTags upsert
   */
  export type UserTagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTags to update in case it exists.
     */
    where: UserTagsWhereUniqueInput
    /**
     * In case the UserTags found by the `where` argument doesn't exist, create a new UserTags with this data.
     */
    create: XOR<UserTagsCreateInput, UserTagsUncheckedCreateInput>
    /**
     * In case the UserTags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTagsUpdateInput, UserTagsUncheckedUpdateInput>
  }

  /**
   * UserTags delete
   */
  export type UserTagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
    /**
     * Filter which UserTags to delete.
     */
    where: UserTagsWhereUniqueInput
  }

  /**
   * UserTags deleteMany
   */
  export type UserTagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTags to delete
     */
    where?: UserTagsWhereInput
    /**
     * Limit how many UserTags to delete.
     */
    limit?: number
  }

  /**
   * UserTags without action
   */
  export type UserTagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTags
     */
    select?: UserTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTags
     */
    omit?: UserTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagsInclude<ExtArgs> | null
  }


  /**
   * Model UserInventory
   */

  export type AggregateUserInventory = {
    _count: UserInventoryCountAggregateOutputType | null
    _avg: UserInventoryAvgAggregateOutputType | null
    _sum: UserInventorySumAggregateOutputType | null
    _min: UserInventoryMinAggregateOutputType | null
    _max: UserInventoryMaxAggregateOutputType | null
  }

  export type UserInventoryAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    quantity: number | null
  }

  export type UserInventorySumAggregateOutputType = {
    id: number | null
    user_id: number | null
    quantity: number | null
  }

  export type UserInventoryMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    type: string | null
    name: string | null
    quality: string | null
    created_at: Date | null
    quantity: number | null
  }

  export type UserInventoryMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    type: string | null
    name: string | null
    quality: string | null
    created_at: Date | null
    quantity: number | null
  }

  export type UserInventoryCountAggregateOutputType = {
    id: number
    user_id: number
    type: number
    name: number
    quality: number
    created_at: number
    quantity: number
    _all: number
  }


  export type UserInventoryAvgAggregateInputType = {
    id?: true
    user_id?: true
    quantity?: true
  }

  export type UserInventorySumAggregateInputType = {
    id?: true
    user_id?: true
    quantity?: true
  }

  export type UserInventoryMinAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    name?: true
    quality?: true
    created_at?: true
    quantity?: true
  }

  export type UserInventoryMaxAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    name?: true
    quality?: true
    created_at?: true
    quantity?: true
  }

  export type UserInventoryCountAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    name?: true
    quality?: true
    created_at?: true
    quantity?: true
    _all?: true
  }

  export type UserInventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInventory to aggregate.
     */
    where?: UserInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventories to fetch.
     */
    orderBy?: UserInventoryOrderByWithRelationInput | UserInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInventories
    **/
    _count?: true | UserInventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserInventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserInventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInventoryMaxAggregateInputType
  }

  export type GetUserInventoryAggregateType<T extends UserInventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInventory[P]>
      : GetScalarType<T[P], AggregateUserInventory[P]>
  }




  export type UserInventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInventoryWhereInput
    orderBy?: UserInventoryOrderByWithAggregationInput | UserInventoryOrderByWithAggregationInput[]
    by: UserInventoryScalarFieldEnum[] | UserInventoryScalarFieldEnum
    having?: UserInventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInventoryCountAggregateInputType | true
    _avg?: UserInventoryAvgAggregateInputType
    _sum?: UserInventorySumAggregateInputType
    _min?: UserInventoryMinAggregateInputType
    _max?: UserInventoryMaxAggregateInputType
  }

  export type UserInventoryGroupByOutputType = {
    id: number
    user_id: number
    type: string | null
    name: string | null
    quality: string | null
    created_at: Date
    quantity: number | null
    _count: UserInventoryCountAggregateOutputType | null
    _avg: UserInventoryAvgAggregateOutputType | null
    _sum: UserInventorySumAggregateOutputType | null
    _min: UserInventoryMinAggregateOutputType | null
    _max: UserInventoryMaxAggregateOutputType | null
  }

  type GetUserInventoryGroupByPayload<T extends UserInventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInventoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserInventoryGroupByOutputType[P]>
        }
      >
    >


  export type UserInventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    name?: boolean
    quality?: boolean
    created_at?: boolean
    quantity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInventory"]>

  export type UserInventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    name?: boolean
    quality?: boolean
    created_at?: boolean
    quantity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInventory"]>

  export type UserInventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    name?: boolean
    quality?: boolean
    created_at?: boolean
    quantity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInventory"]>

  export type UserInventorySelectScalar = {
    id?: boolean
    user_id?: boolean
    type?: boolean
    name?: boolean
    quality?: boolean
    created_at?: boolean
    quantity?: boolean
  }

  export type UserInventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "type" | "name" | "quality" | "created_at" | "quantity", ExtArgs["result"]["userInventory"]>
  export type UserInventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserInventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserInventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserInventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInventory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      type: string | null
      name: string | null
      quality: string | null
      created_at: Date
      quantity: number | null
    }, ExtArgs["result"]["userInventory"]>
    composites: {}
  }

  type UserInventoryGetPayload<S extends boolean | null | undefined | UserInventoryDefaultArgs> = $Result.GetResult<Prisma.$UserInventoryPayload, S>

  type UserInventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserInventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserInventoryCountAggregateInputType | true
    }

  export interface UserInventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInventory'], meta: { name: 'UserInventory' } }
    /**
     * Find zero or one UserInventory that matches the filter.
     * @param {UserInventoryFindUniqueArgs} args - Arguments to find a UserInventory
     * @example
     * // Get one UserInventory
     * const userInventory = await prisma.userInventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInventoryFindUniqueArgs>(args: SelectSubset<T, UserInventoryFindUniqueArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserInventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserInventoryFindUniqueOrThrowArgs} args - Arguments to find a UserInventory
     * @example
     * // Get one UserInventory
     * const userInventory = await prisma.userInventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryFindFirstArgs} args - Arguments to find a UserInventory
     * @example
     * // Get one UserInventory
     * const userInventory = await prisma.userInventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInventoryFindFirstArgs>(args?: SelectSubset<T, UserInventoryFindFirstArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryFindFirstOrThrowArgs} args - Arguments to find a UserInventory
     * @example
     * // Get one UserInventory
     * const userInventory = await prisma.userInventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserInventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInventories
     * const userInventories = await prisma.userInventory.findMany()
     * 
     * // Get first 10 UserInventories
     * const userInventories = await prisma.userInventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInventoryWithIdOnly = await prisma.userInventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInventoryFindManyArgs>(args?: SelectSubset<T, UserInventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserInventory.
     * @param {UserInventoryCreateArgs} args - Arguments to create a UserInventory.
     * @example
     * // Create one UserInventory
     * const UserInventory = await prisma.userInventory.create({
     *   data: {
     *     // ... data to create a UserInventory
     *   }
     * })
     * 
     */
    create<T extends UserInventoryCreateArgs>(args: SelectSubset<T, UserInventoryCreateArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserInventories.
     * @param {UserInventoryCreateManyArgs} args - Arguments to create many UserInventories.
     * @example
     * // Create many UserInventories
     * const userInventory = await prisma.userInventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInventoryCreateManyArgs>(args?: SelectSubset<T, UserInventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInventories and returns the data saved in the database.
     * @param {UserInventoryCreateManyAndReturnArgs} args - Arguments to create many UserInventories.
     * @example
     * // Create many UserInventories
     * const userInventory = await prisma.userInventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInventories and only return the `id`
     * const userInventoryWithIdOnly = await prisma.userInventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserInventory.
     * @param {UserInventoryDeleteArgs} args - Arguments to delete one UserInventory.
     * @example
     * // Delete one UserInventory
     * const UserInventory = await prisma.userInventory.delete({
     *   where: {
     *     // ... filter to delete one UserInventory
     *   }
     * })
     * 
     */
    delete<T extends UserInventoryDeleteArgs>(args: SelectSubset<T, UserInventoryDeleteArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserInventory.
     * @param {UserInventoryUpdateArgs} args - Arguments to update one UserInventory.
     * @example
     * // Update one UserInventory
     * const userInventory = await prisma.userInventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInventoryUpdateArgs>(args: SelectSubset<T, UserInventoryUpdateArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserInventories.
     * @param {UserInventoryDeleteManyArgs} args - Arguments to filter UserInventories to delete.
     * @example
     * // Delete a few UserInventories
     * const { count } = await prisma.userInventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInventoryDeleteManyArgs>(args?: SelectSubset<T, UserInventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInventories
     * const userInventory = await prisma.userInventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInventoryUpdateManyArgs>(args: SelectSubset<T, UserInventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInventories and returns the data updated in the database.
     * @param {UserInventoryUpdateManyAndReturnArgs} args - Arguments to update many UserInventories.
     * @example
     * // Update many UserInventories
     * const userInventory = await prisma.userInventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserInventories and only return the `id`
     * const userInventoryWithIdOnly = await prisma.userInventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserInventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, UserInventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserInventory.
     * @param {UserInventoryUpsertArgs} args - Arguments to update or create a UserInventory.
     * @example
     * // Update or create a UserInventory
     * const userInventory = await prisma.userInventory.upsert({
     *   create: {
     *     // ... data to create a UserInventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInventory we want to update
     *   }
     * })
     */
    upsert<T extends UserInventoryUpsertArgs>(args: SelectSubset<T, UserInventoryUpsertArgs<ExtArgs>>): Prisma__UserInventoryClient<$Result.GetResult<Prisma.$UserInventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryCountArgs} args - Arguments to filter UserInventories to count.
     * @example
     * // Count the number of UserInventories
     * const count = await prisma.userInventory.count({
     *   where: {
     *     // ... the filter for the UserInventories we want to count
     *   }
     * })
    **/
    count<T extends UserInventoryCountArgs>(
      args?: Subset<T, UserInventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInventoryAggregateArgs>(args: Subset<T, UserInventoryAggregateArgs>): Prisma.PrismaPromise<GetUserInventoryAggregateType<T>>

    /**
     * Group by UserInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInventoryGroupByArgs['orderBy'] }
        : { orderBy?: UserInventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInventory model
   */
  readonly fields: UserInventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInventory model
   */
  interface UserInventoryFieldRefs {
    readonly id: FieldRef<"UserInventory", 'Int'>
    readonly user_id: FieldRef<"UserInventory", 'Int'>
    readonly type: FieldRef<"UserInventory", 'String'>
    readonly name: FieldRef<"UserInventory", 'String'>
    readonly quality: FieldRef<"UserInventory", 'String'>
    readonly created_at: FieldRef<"UserInventory", 'DateTime'>
    readonly quantity: FieldRef<"UserInventory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserInventory findUnique
   */
  export type UserInventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * Filter, which UserInventory to fetch.
     */
    where: UserInventoryWhereUniqueInput
  }

  /**
   * UserInventory findUniqueOrThrow
   */
  export type UserInventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * Filter, which UserInventory to fetch.
     */
    where: UserInventoryWhereUniqueInput
  }

  /**
   * UserInventory findFirst
   */
  export type UserInventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * Filter, which UserInventory to fetch.
     */
    where?: UserInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventories to fetch.
     */
    orderBy?: UserInventoryOrderByWithRelationInput | UserInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInventories.
     */
    cursor?: UserInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInventories.
     */
    distinct?: UserInventoryScalarFieldEnum | UserInventoryScalarFieldEnum[]
  }

  /**
   * UserInventory findFirstOrThrow
   */
  export type UserInventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * Filter, which UserInventory to fetch.
     */
    where?: UserInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventories to fetch.
     */
    orderBy?: UserInventoryOrderByWithRelationInput | UserInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInventories.
     */
    cursor?: UserInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInventories.
     */
    distinct?: UserInventoryScalarFieldEnum | UserInventoryScalarFieldEnum[]
  }

  /**
   * UserInventory findMany
   */
  export type UserInventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * Filter, which UserInventories to fetch.
     */
    where?: UserInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInventories to fetch.
     */
    orderBy?: UserInventoryOrderByWithRelationInput | UserInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInventories.
     */
    cursor?: UserInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInventories.
     */
    skip?: number
    distinct?: UserInventoryScalarFieldEnum | UserInventoryScalarFieldEnum[]
  }

  /**
   * UserInventory create
   */
  export type UserInventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInventory.
     */
    data: XOR<UserInventoryCreateInput, UserInventoryUncheckedCreateInput>
  }

  /**
   * UserInventory createMany
   */
  export type UserInventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInventories.
     */
    data: UserInventoryCreateManyInput | UserInventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserInventory createManyAndReturn
   */
  export type UserInventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * The data used to create many UserInventories.
     */
    data: UserInventoryCreateManyInput | UserInventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInventory update
   */
  export type UserInventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInventory.
     */
    data: XOR<UserInventoryUpdateInput, UserInventoryUncheckedUpdateInput>
    /**
     * Choose, which UserInventory to update.
     */
    where: UserInventoryWhereUniqueInput
  }

  /**
   * UserInventory updateMany
   */
  export type UserInventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInventories.
     */
    data: XOR<UserInventoryUpdateManyMutationInput, UserInventoryUncheckedUpdateManyInput>
    /**
     * Filter which UserInventories to update
     */
    where?: UserInventoryWhereInput
    /**
     * Limit how many UserInventories to update.
     */
    limit?: number
  }

  /**
   * UserInventory updateManyAndReturn
   */
  export type UserInventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * The data used to update UserInventories.
     */
    data: XOR<UserInventoryUpdateManyMutationInput, UserInventoryUncheckedUpdateManyInput>
    /**
     * Filter which UserInventories to update
     */
    where?: UserInventoryWhereInput
    /**
     * Limit how many UserInventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInventory upsert
   */
  export type UserInventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInventory to update in case it exists.
     */
    where: UserInventoryWhereUniqueInput
    /**
     * In case the UserInventory found by the `where` argument doesn't exist, create a new UserInventory with this data.
     */
    create: XOR<UserInventoryCreateInput, UserInventoryUncheckedCreateInput>
    /**
     * In case the UserInventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInventoryUpdateInput, UserInventoryUncheckedUpdateInput>
  }

  /**
   * UserInventory delete
   */
  export type UserInventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
    /**
     * Filter which UserInventory to delete.
     */
    where: UserInventoryWhereUniqueInput
  }

  /**
   * UserInventory deleteMany
   */
  export type UserInventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInventories to delete
     */
    where?: UserInventoryWhereInput
    /**
     * Limit how many UserInventories to delete.
     */
    limit?: number
  }

  /**
   * UserInventory without action
   */
  export type UserInventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInventory
     */
    select?: UserInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInventory
     */
    omit?: UserInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInventoryInclude<ExtArgs> | null
  }


  /**
   * Model Tasks
   */

  export type AggregateTasks = {
    _count: TasksCountAggregateOutputType | null
    _avg: TasksAvgAggregateOutputType | null
    _sum: TasksSumAggregateOutputType | null
    _min: TasksMinAggregateOutputType | null
    _max: TasksMaxAggregateOutputType | null
  }

  export type TasksAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type TasksSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type TasksMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    completed_at: Date | null
    created_at: Date | null
  }

  export type TasksMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    completed_at: Date | null
    created_at: Date | null
  }

  export type TasksCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    completed_at: number
    created_at: number
    _all: number
  }


  export type TasksAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type TasksSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type TasksMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    completed_at?: true
    created_at?: true
  }

  export type TasksMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    completed_at?: true
    created_at?: true
  }

  export type TasksCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    completed_at?: true
    created_at?: true
    _all?: true
  }

  export type TasksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to aggregate.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TasksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TasksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TasksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TasksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TasksMaxAggregateInputType
  }

  export type GetTasksAggregateType<T extends TasksAggregateArgs> = {
        [P in keyof T & keyof AggregateTasks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTasks[P]>
      : GetScalarType<T[P], AggregateTasks[P]>
  }




  export type TasksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksWhereInput
    orderBy?: TasksOrderByWithAggregationInput | TasksOrderByWithAggregationInput[]
    by: TasksScalarFieldEnum[] | TasksScalarFieldEnum
    having?: TasksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TasksCountAggregateInputType | true
    _avg?: TasksAvgAggregateInputType
    _sum?: TasksSumAggregateInputType
    _min?: TasksMinAggregateInputType
    _max?: TasksMaxAggregateInputType
  }

  export type TasksGroupByOutputType = {
    id: number
    user_id: number
    name: string | null
    completed_at: Date | null
    created_at: Date
    _count: TasksCountAggregateOutputType | null
    _avg: TasksAvgAggregateOutputType | null
    _sum: TasksSumAggregateOutputType | null
    _min: TasksMinAggregateOutputType | null
    _max: TasksMaxAggregateOutputType | null
  }

  type GetTasksGroupByPayload<T extends TasksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TasksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TasksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TasksGroupByOutputType[P]>
            : GetScalarType<T[P], TasksGroupByOutputType[P]>
        }
      >
    >


  export type TasksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    completed_at?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Tasks$assignedToArgs<ExtArgs>
    _count?: boolean | TasksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasks"]>

  export type TasksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    completed_at?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasks"]>

  export type TasksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    completed_at?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasks"]>

  export type TasksSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    completed_at?: boolean
    created_at?: boolean
  }

  export type TasksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "name" | "completed_at" | "created_at", ExtArgs["result"]["tasks"]>
  export type TasksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assignedTo?: boolean | Tasks$assignedToArgs<ExtArgs>
    _count?: boolean | TasksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TasksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TasksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TasksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tasks"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      assignedTo: Prisma.$TasksUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      name: string | null
      completed_at: Date | null
      created_at: Date
    }, ExtArgs["result"]["tasks"]>
    composites: {}
  }

  type TasksGetPayload<S extends boolean | null | undefined | TasksDefaultArgs> = $Result.GetResult<Prisma.$TasksPayload, S>

  type TasksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TasksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TasksCountAggregateInputType | true
    }

  export interface TasksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tasks'], meta: { name: 'Tasks' } }
    /**
     * Find zero or one Tasks that matches the filter.
     * @param {TasksFindUniqueArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TasksFindUniqueArgs>(args: SelectSubset<T, TasksFindUniqueArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tasks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TasksFindUniqueOrThrowArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TasksFindUniqueOrThrowArgs>(args: SelectSubset<T, TasksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindFirstArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TasksFindFirstArgs>(args?: SelectSubset<T, TasksFindFirstArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tasks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindFirstOrThrowArgs} args - Arguments to find a Tasks
     * @example
     * // Get one Tasks
     * const tasks = await prisma.tasks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TasksFindFirstOrThrowArgs>(args?: SelectSubset<T, TasksFindFirstOrThrowArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.tasks.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.tasks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tasksWithIdOnly = await prisma.tasks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TasksFindManyArgs>(args?: SelectSubset<T, TasksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tasks.
     * @param {TasksCreateArgs} args - Arguments to create a Tasks.
     * @example
     * // Create one Tasks
     * const Tasks = await prisma.tasks.create({
     *   data: {
     *     // ... data to create a Tasks
     *   }
     * })
     * 
     */
    create<T extends TasksCreateArgs>(args: SelectSubset<T, TasksCreateArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TasksCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const tasks = await prisma.tasks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TasksCreateManyArgs>(args?: SelectSubset<T, TasksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TasksCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const tasks = await prisma.tasks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const tasksWithIdOnly = await prisma.tasks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TasksCreateManyAndReturnArgs>(args?: SelectSubset<T, TasksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tasks.
     * @param {TasksDeleteArgs} args - Arguments to delete one Tasks.
     * @example
     * // Delete one Tasks
     * const Tasks = await prisma.tasks.delete({
     *   where: {
     *     // ... filter to delete one Tasks
     *   }
     * })
     * 
     */
    delete<T extends TasksDeleteArgs>(args: SelectSubset<T, TasksDeleteArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tasks.
     * @param {TasksUpdateArgs} args - Arguments to update one Tasks.
     * @example
     * // Update one Tasks
     * const tasks = await prisma.tasks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TasksUpdateArgs>(args: SelectSubset<T, TasksUpdateArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TasksDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.tasks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TasksDeleteManyArgs>(args?: SelectSubset<T, TasksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const tasks = await prisma.tasks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TasksUpdateManyArgs>(args: SelectSubset<T, TasksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TasksUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const tasks = await prisma.tasks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const tasksWithIdOnly = await prisma.tasks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TasksUpdateManyAndReturnArgs>(args: SelectSubset<T, TasksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tasks.
     * @param {TasksUpsertArgs} args - Arguments to update or create a Tasks.
     * @example
     * // Update or create a Tasks
     * const tasks = await prisma.tasks.upsert({
     *   create: {
     *     // ... data to create a Tasks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tasks we want to update
     *   }
     * })
     */
    upsert<T extends TasksUpsertArgs>(args: SelectSubset<T, TasksUpsertArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.tasks.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TasksCountArgs>(
      args?: Subset<T, TasksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TasksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TasksAggregateArgs>(args: Subset<T, TasksAggregateArgs>): Prisma.PrismaPromise<GetTasksAggregateType<T>>

    /**
     * Group by Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TasksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TasksGroupByArgs['orderBy'] }
        : { orderBy?: TasksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TasksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTasksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tasks model
   */
  readonly fields: TasksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tasks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TasksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends Tasks$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Tasks$assignedToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tasks model
   */
  interface TasksFieldRefs {
    readonly id: FieldRef<"Tasks", 'Int'>
    readonly user_id: FieldRef<"Tasks", 'Int'>
    readonly name: FieldRef<"Tasks", 'String'>
    readonly completed_at: FieldRef<"Tasks", 'DateTime'>
    readonly created_at: FieldRef<"Tasks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tasks findUnique
   */
  export type TasksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks findUniqueOrThrow
   */
  export type TasksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks findFirst
   */
  export type TasksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Tasks findFirstOrThrow
   */
  export type TasksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Tasks findMany
   */
  export type TasksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TasksOrderByWithRelationInput | TasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TasksScalarFieldEnum | TasksScalarFieldEnum[]
  }

  /**
   * Tasks create
   */
  export type TasksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * The data needed to create a Tasks.
     */
    data: XOR<TasksCreateInput, TasksUncheckedCreateInput>
  }

  /**
   * Tasks createMany
   */
  export type TasksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TasksCreateManyInput | TasksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tasks createManyAndReturn
   */
  export type TasksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TasksCreateManyInput | TasksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tasks update
   */
  export type TasksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * The data needed to update a Tasks.
     */
    data: XOR<TasksUpdateInput, TasksUncheckedUpdateInput>
    /**
     * Choose, which Tasks to update.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks updateMany
   */
  export type TasksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TasksWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Tasks updateManyAndReturn
   */
  export type TasksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TasksWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tasks upsert
   */
  export type TasksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * The filter to search for the Tasks to update in case it exists.
     */
    where: TasksWhereUniqueInput
    /**
     * In case the Tasks found by the `where` argument doesn't exist, create a new Tasks with this data.
     */
    create: XOR<TasksCreateInput, TasksUncheckedCreateInput>
    /**
     * In case the Tasks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TasksUpdateInput, TasksUncheckedUpdateInput>
  }

  /**
   * Tasks delete
   */
  export type TasksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
    /**
     * Filter which Tasks to delete.
     */
    where: TasksWhereUniqueInput
  }

  /**
   * Tasks deleteMany
   */
  export type TasksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TasksWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Tasks.assignedTo
   */
  export type Tasks$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    where?: TasksUserWhereInput
    orderBy?: TasksUserOrderByWithRelationInput | TasksUserOrderByWithRelationInput[]
    cursor?: TasksUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TasksUserScalarFieldEnum | TasksUserScalarFieldEnum[]
  }

  /**
   * Tasks without action
   */
  export type TasksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tasks
     */
    select?: TasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tasks
     */
    omit?: TasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksInclude<ExtArgs> | null
  }


  /**
   * Model Raid
   */

  export type AggregateRaid = {
    _count: RaidCountAggregateOutputType | null
    _avg: RaidAvgAggregateOutputType | null
    _sum: RaidSumAggregateOutputType | null
    _min: RaidMinAggregateOutputType | null
    _max: RaidMaxAggregateOutputType | null
  }

  export type RaidAvgAggregateOutputType = {
    id: number | null
    dkp_summary: number | null
  }

  export type RaidSumAggregateOutputType = {
    id: number | null
    dkp_summary: number | null
  }

  export type RaidMinAggregateOutputType = {
    id: number | null
    type: string | null
    start_date: Date | null
    created_at: Date | null
    is_pvp: boolean | null
    is_pvp_long: boolean | null
    dkp_summary: number | null
  }

  export type RaidMaxAggregateOutputType = {
    id: number | null
    type: string | null
    start_date: Date | null
    created_at: Date | null
    is_pvp: boolean | null
    is_pvp_long: boolean | null
    dkp_summary: number | null
  }

  export type RaidCountAggregateOutputType = {
    id: number
    type: number
    start_date: number
    created_at: number
    is_pvp: number
    is_pvp_long: number
    dkp_summary: number
    _all: number
  }


  export type RaidAvgAggregateInputType = {
    id?: true
    dkp_summary?: true
  }

  export type RaidSumAggregateInputType = {
    id?: true
    dkp_summary?: true
  }

  export type RaidMinAggregateInputType = {
    id?: true
    type?: true
    start_date?: true
    created_at?: true
    is_pvp?: true
    is_pvp_long?: true
    dkp_summary?: true
  }

  export type RaidMaxAggregateInputType = {
    id?: true
    type?: true
    start_date?: true
    created_at?: true
    is_pvp?: true
    is_pvp_long?: true
    dkp_summary?: true
  }

  export type RaidCountAggregateInputType = {
    id?: true
    type?: true
    start_date?: true
    created_at?: true
    is_pvp?: true
    is_pvp_long?: true
    dkp_summary?: true
    _all?: true
  }

  export type RaidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Raid to aggregate.
     */
    where?: RaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Raids to fetch.
     */
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Raids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Raids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Raids
    **/
    _count?: true | RaidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaidMaxAggregateInputType
  }

  export type GetRaidAggregateType<T extends RaidAggregateArgs> = {
        [P in keyof T & keyof AggregateRaid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaid[P]>
      : GetScalarType<T[P], AggregateRaid[P]>
  }




  export type RaidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidWhereInput
    orderBy?: RaidOrderByWithAggregationInput | RaidOrderByWithAggregationInput[]
    by: RaidScalarFieldEnum[] | RaidScalarFieldEnum
    having?: RaidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaidCountAggregateInputType | true
    _avg?: RaidAvgAggregateInputType
    _sum?: RaidSumAggregateInputType
    _min?: RaidMinAggregateInputType
    _max?: RaidMaxAggregateInputType
  }

  export type RaidGroupByOutputType = {
    id: number
    type: string | null
    start_date: Date | null
    created_at: Date
    is_pvp: boolean | null
    is_pvp_long: boolean | null
    dkp_summary: number | null
    _count: RaidCountAggregateOutputType | null
    _avg: RaidAvgAggregateOutputType | null
    _sum: RaidSumAggregateOutputType | null
    _min: RaidMinAggregateOutputType | null
    _max: RaidMaxAggregateOutputType | null
  }

  type GetRaidGroupByPayload<T extends RaidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaidGroupByOutputType[P]>
            : GetScalarType<T[P], RaidGroupByOutputType[P]>
        }
      >
    >


  export type RaidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    start_date?: boolean
    created_at?: boolean
    is_pvp?: boolean
    is_pvp_long?: boolean
    dkp_summary?: boolean
    attendance?: boolean | Raid$attendanceArgs<ExtArgs>
    raidBosses?: boolean | Raid$raidBossesArgs<ExtArgs>
    _count?: boolean | RaidCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raid"]>

  export type RaidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    start_date?: boolean
    created_at?: boolean
    is_pvp?: boolean
    is_pvp_long?: boolean
    dkp_summary?: boolean
  }, ExtArgs["result"]["raid"]>

  export type RaidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    start_date?: boolean
    created_at?: boolean
    is_pvp?: boolean
    is_pvp_long?: boolean
    dkp_summary?: boolean
  }, ExtArgs["result"]["raid"]>

  export type RaidSelectScalar = {
    id?: boolean
    type?: boolean
    start_date?: boolean
    created_at?: boolean
    is_pvp?: boolean
    is_pvp_long?: boolean
    dkp_summary?: boolean
  }

  export type RaidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "start_date" | "created_at" | "is_pvp" | "is_pvp_long" | "dkp_summary", ExtArgs["result"]["raid"]>
  export type RaidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | Raid$attendanceArgs<ExtArgs>
    raidBosses?: boolean | Raid$raidBossesArgs<ExtArgs>
    _count?: boolean | RaidCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RaidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RaidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RaidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Raid"
    objects: {
      attendance: Prisma.$RaidAttendancePayload<ExtArgs>[]
      raidBosses: Prisma.$RaidBossPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string | null
      start_date: Date | null
      created_at: Date
      is_pvp: boolean | null
      is_pvp_long: boolean | null
      dkp_summary: number | null
    }, ExtArgs["result"]["raid"]>
    composites: {}
  }

  type RaidGetPayload<S extends boolean | null | undefined | RaidDefaultArgs> = $Result.GetResult<Prisma.$RaidPayload, S>

  type RaidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaidCountAggregateInputType | true
    }

  export interface RaidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Raid'], meta: { name: 'Raid' } }
    /**
     * Find zero or one Raid that matches the filter.
     * @param {RaidFindUniqueArgs} args - Arguments to find a Raid
     * @example
     * // Get one Raid
     * const raid = await prisma.raid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaidFindUniqueArgs>(args: SelectSubset<T, RaidFindUniqueArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Raid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaidFindUniqueOrThrowArgs} args - Arguments to find a Raid
     * @example
     * // Get one Raid
     * const raid = await prisma.raid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaidFindUniqueOrThrowArgs>(args: SelectSubset<T, RaidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Raid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidFindFirstArgs} args - Arguments to find a Raid
     * @example
     * // Get one Raid
     * const raid = await prisma.raid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaidFindFirstArgs>(args?: SelectSubset<T, RaidFindFirstArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Raid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidFindFirstOrThrowArgs} args - Arguments to find a Raid
     * @example
     * // Get one Raid
     * const raid = await prisma.raid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaidFindFirstOrThrowArgs>(args?: SelectSubset<T, RaidFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Raids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Raids
     * const raids = await prisma.raid.findMany()
     * 
     * // Get first 10 Raids
     * const raids = await prisma.raid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raidWithIdOnly = await prisma.raid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaidFindManyArgs>(args?: SelectSubset<T, RaidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Raid.
     * @param {RaidCreateArgs} args - Arguments to create a Raid.
     * @example
     * // Create one Raid
     * const Raid = await prisma.raid.create({
     *   data: {
     *     // ... data to create a Raid
     *   }
     * })
     * 
     */
    create<T extends RaidCreateArgs>(args: SelectSubset<T, RaidCreateArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Raids.
     * @param {RaidCreateManyArgs} args - Arguments to create many Raids.
     * @example
     * // Create many Raids
     * const raid = await prisma.raid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaidCreateManyArgs>(args?: SelectSubset<T, RaidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Raids and returns the data saved in the database.
     * @param {RaidCreateManyAndReturnArgs} args - Arguments to create many Raids.
     * @example
     * // Create many Raids
     * const raid = await prisma.raid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Raids and only return the `id`
     * const raidWithIdOnly = await prisma.raid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaidCreateManyAndReturnArgs>(args?: SelectSubset<T, RaidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Raid.
     * @param {RaidDeleteArgs} args - Arguments to delete one Raid.
     * @example
     * // Delete one Raid
     * const Raid = await prisma.raid.delete({
     *   where: {
     *     // ... filter to delete one Raid
     *   }
     * })
     * 
     */
    delete<T extends RaidDeleteArgs>(args: SelectSubset<T, RaidDeleteArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Raid.
     * @param {RaidUpdateArgs} args - Arguments to update one Raid.
     * @example
     * // Update one Raid
     * const raid = await prisma.raid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaidUpdateArgs>(args: SelectSubset<T, RaidUpdateArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Raids.
     * @param {RaidDeleteManyArgs} args - Arguments to filter Raids to delete.
     * @example
     * // Delete a few Raids
     * const { count } = await prisma.raid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaidDeleteManyArgs>(args?: SelectSubset<T, RaidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Raids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Raids
     * const raid = await prisma.raid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaidUpdateManyArgs>(args: SelectSubset<T, RaidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Raids and returns the data updated in the database.
     * @param {RaidUpdateManyAndReturnArgs} args - Arguments to update many Raids.
     * @example
     * // Update many Raids
     * const raid = await prisma.raid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Raids and only return the `id`
     * const raidWithIdOnly = await prisma.raid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaidUpdateManyAndReturnArgs>(args: SelectSubset<T, RaidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Raid.
     * @param {RaidUpsertArgs} args - Arguments to update or create a Raid.
     * @example
     * // Update or create a Raid
     * const raid = await prisma.raid.upsert({
     *   create: {
     *     // ... data to create a Raid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Raid we want to update
     *   }
     * })
     */
    upsert<T extends RaidUpsertArgs>(args: SelectSubset<T, RaidUpsertArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Raids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidCountArgs} args - Arguments to filter Raids to count.
     * @example
     * // Count the number of Raids
     * const count = await prisma.raid.count({
     *   where: {
     *     // ... the filter for the Raids we want to count
     *   }
     * })
    **/
    count<T extends RaidCountArgs>(
      args?: Subset<T, RaidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Raid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaidAggregateArgs>(args: Subset<T, RaidAggregateArgs>): Prisma.PrismaPromise<GetRaidAggregateType<T>>

    /**
     * Group by Raid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaidGroupByArgs['orderBy'] }
        : { orderBy?: RaidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Raid model
   */
  readonly fields: RaidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Raid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendance<T extends Raid$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Raid$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    raidBosses<T extends Raid$raidBossesArgs<ExtArgs> = {}>(args?: Subset<T, Raid$raidBossesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Raid model
   */
  interface RaidFieldRefs {
    readonly id: FieldRef<"Raid", 'Int'>
    readonly type: FieldRef<"Raid", 'String'>
    readonly start_date: FieldRef<"Raid", 'DateTime'>
    readonly created_at: FieldRef<"Raid", 'DateTime'>
    readonly is_pvp: FieldRef<"Raid", 'Boolean'>
    readonly is_pvp_long: FieldRef<"Raid", 'Boolean'>
    readonly dkp_summary: FieldRef<"Raid", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Raid findUnique
   */
  export type RaidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raid to fetch.
     */
    where: RaidWhereUniqueInput
  }

  /**
   * Raid findUniqueOrThrow
   */
  export type RaidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raid to fetch.
     */
    where: RaidWhereUniqueInput
  }

  /**
   * Raid findFirst
   */
  export type RaidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raid to fetch.
     */
    where?: RaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Raids to fetch.
     */
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Raids.
     */
    cursor?: RaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Raids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Raids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Raids.
     */
    distinct?: RaidScalarFieldEnum | RaidScalarFieldEnum[]
  }

  /**
   * Raid findFirstOrThrow
   */
  export type RaidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raid to fetch.
     */
    where?: RaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Raids to fetch.
     */
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Raids.
     */
    cursor?: RaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Raids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Raids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Raids.
     */
    distinct?: RaidScalarFieldEnum | RaidScalarFieldEnum[]
  }

  /**
   * Raid findMany
   */
  export type RaidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter, which Raids to fetch.
     */
    where?: RaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Raids to fetch.
     */
    orderBy?: RaidOrderByWithRelationInput | RaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Raids.
     */
    cursor?: RaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Raids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Raids.
     */
    skip?: number
    distinct?: RaidScalarFieldEnum | RaidScalarFieldEnum[]
  }

  /**
   * Raid create
   */
  export type RaidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * The data needed to create a Raid.
     */
    data: XOR<RaidCreateInput, RaidUncheckedCreateInput>
  }

  /**
   * Raid createMany
   */
  export type RaidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Raids.
     */
    data: RaidCreateManyInput | RaidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Raid createManyAndReturn
   */
  export type RaidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * The data used to create many Raids.
     */
    data: RaidCreateManyInput | RaidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Raid update
   */
  export type RaidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * The data needed to update a Raid.
     */
    data: XOR<RaidUpdateInput, RaidUncheckedUpdateInput>
    /**
     * Choose, which Raid to update.
     */
    where: RaidWhereUniqueInput
  }

  /**
   * Raid updateMany
   */
  export type RaidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Raids.
     */
    data: XOR<RaidUpdateManyMutationInput, RaidUncheckedUpdateManyInput>
    /**
     * Filter which Raids to update
     */
    where?: RaidWhereInput
    /**
     * Limit how many Raids to update.
     */
    limit?: number
  }

  /**
   * Raid updateManyAndReturn
   */
  export type RaidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * The data used to update Raids.
     */
    data: XOR<RaidUpdateManyMutationInput, RaidUncheckedUpdateManyInput>
    /**
     * Filter which Raids to update
     */
    where?: RaidWhereInput
    /**
     * Limit how many Raids to update.
     */
    limit?: number
  }

  /**
   * Raid upsert
   */
  export type RaidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * The filter to search for the Raid to update in case it exists.
     */
    where: RaidWhereUniqueInput
    /**
     * In case the Raid found by the `where` argument doesn't exist, create a new Raid with this data.
     */
    create: XOR<RaidCreateInput, RaidUncheckedCreateInput>
    /**
     * In case the Raid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaidUpdateInput, RaidUncheckedUpdateInput>
  }

  /**
   * Raid delete
   */
  export type RaidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
    /**
     * Filter which Raid to delete.
     */
    where: RaidWhereUniqueInput
  }

  /**
   * Raid deleteMany
   */
  export type RaidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Raids to delete
     */
    where?: RaidWhereInput
    /**
     * Limit how many Raids to delete.
     */
    limit?: number
  }

  /**
   * Raid.attendance
   */
  export type Raid$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    where?: RaidAttendanceWhereInput
    orderBy?: RaidAttendanceOrderByWithRelationInput | RaidAttendanceOrderByWithRelationInput[]
    cursor?: RaidAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaidAttendanceScalarFieldEnum | RaidAttendanceScalarFieldEnum[]
  }

  /**
   * Raid.raidBosses
   */
  export type Raid$raidBossesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    where?: RaidBossWhereInput
    orderBy?: RaidBossOrderByWithRelationInput | RaidBossOrderByWithRelationInput[]
    cursor?: RaidBossWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaidBossScalarFieldEnum | RaidBossScalarFieldEnum[]
  }

  /**
   * Raid without action
   */
  export type RaidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raid
     */
    select?: RaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Raid
     */
    omit?: RaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidInclude<ExtArgs> | null
  }


  /**
   * Model Boss
   */

  export type AggregateBoss = {
    _count: BossCountAggregateOutputType | null
    _avg: BossAvgAggregateOutputType | null
    _sum: BossSumAggregateOutputType | null
    _min: BossMinAggregateOutputType | null
    _max: BossMaxAggregateOutputType | null
  }

  export type BossAvgAggregateOutputType = {
    id: number | null
    dkp_points: number | null
  }

  export type BossSumAggregateOutputType = {
    id: number | null
    dkp_points: number | null
  }

  export type BossMinAggregateOutputType = {
    id: number | null
    boss_name: string | null
    dkp_points: number | null
    category: string | null
  }

  export type BossMaxAggregateOutputType = {
    id: number | null
    boss_name: string | null
    dkp_points: number | null
    category: string | null
  }

  export type BossCountAggregateOutputType = {
    id: number
    boss_name: number
    dkp_points: number
    category: number
    _all: number
  }


  export type BossAvgAggregateInputType = {
    id?: true
    dkp_points?: true
  }

  export type BossSumAggregateInputType = {
    id?: true
    dkp_points?: true
  }

  export type BossMinAggregateInputType = {
    id?: true
    boss_name?: true
    dkp_points?: true
    category?: true
  }

  export type BossMaxAggregateInputType = {
    id?: true
    boss_name?: true
    dkp_points?: true
    category?: true
  }

  export type BossCountAggregateInputType = {
    id?: true
    boss_name?: true
    dkp_points?: true
    category?: true
    _all?: true
  }

  export type BossAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boss to aggregate.
     */
    where?: BossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bosses to fetch.
     */
    orderBy?: BossOrderByWithRelationInput | BossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bosses
    **/
    _count?: true | BossCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BossAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BossSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BossMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BossMaxAggregateInputType
  }

  export type GetBossAggregateType<T extends BossAggregateArgs> = {
        [P in keyof T & keyof AggregateBoss]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoss[P]>
      : GetScalarType<T[P], AggregateBoss[P]>
  }




  export type BossGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BossWhereInput
    orderBy?: BossOrderByWithAggregationInput | BossOrderByWithAggregationInput[]
    by: BossScalarFieldEnum[] | BossScalarFieldEnum
    having?: BossScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BossCountAggregateInputType | true
    _avg?: BossAvgAggregateInputType
    _sum?: BossSumAggregateInputType
    _min?: BossMinAggregateInputType
    _max?: BossMaxAggregateInputType
  }

  export type BossGroupByOutputType = {
    id: number
    boss_name: string
    dkp_points: number
    category: string | null
    _count: BossCountAggregateOutputType | null
    _avg: BossAvgAggregateOutputType | null
    _sum: BossSumAggregateOutputType | null
    _min: BossMinAggregateOutputType | null
    _max: BossMaxAggregateOutputType | null
  }

  type GetBossGroupByPayload<T extends BossGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BossGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BossGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BossGroupByOutputType[P]>
            : GetScalarType<T[P], BossGroupByOutputType[P]>
        }
      >
    >


  export type BossSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boss_name?: boolean
    dkp_points?: boolean
    category?: boolean
    raidBosses?: boolean | Boss$raidBossesArgs<ExtArgs>
    _count?: boolean | BossCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boss"]>

  export type BossSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boss_name?: boolean
    dkp_points?: boolean
    category?: boolean
  }, ExtArgs["result"]["boss"]>

  export type BossSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boss_name?: boolean
    dkp_points?: boolean
    category?: boolean
  }, ExtArgs["result"]["boss"]>

  export type BossSelectScalar = {
    id?: boolean
    boss_name?: boolean
    dkp_points?: boolean
    category?: boolean
  }

  export type BossOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "boss_name" | "dkp_points" | "category", ExtArgs["result"]["boss"]>
  export type BossInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raidBosses?: boolean | Boss$raidBossesArgs<ExtArgs>
    _count?: boolean | BossCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BossIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BossIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BossPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Boss"
    objects: {
      raidBosses: Prisma.$RaidBossPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      boss_name: string
      dkp_points: number
      category: string | null
    }, ExtArgs["result"]["boss"]>
    composites: {}
  }

  type BossGetPayload<S extends boolean | null | undefined | BossDefaultArgs> = $Result.GetResult<Prisma.$BossPayload, S>

  type BossCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BossFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BossCountAggregateInputType | true
    }

  export interface BossDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Boss'], meta: { name: 'Boss' } }
    /**
     * Find zero or one Boss that matches the filter.
     * @param {BossFindUniqueArgs} args - Arguments to find a Boss
     * @example
     * // Get one Boss
     * const boss = await prisma.boss.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BossFindUniqueArgs>(args: SelectSubset<T, BossFindUniqueArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Boss that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BossFindUniqueOrThrowArgs} args - Arguments to find a Boss
     * @example
     * // Get one Boss
     * const boss = await prisma.boss.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BossFindUniqueOrThrowArgs>(args: SelectSubset<T, BossFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boss that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossFindFirstArgs} args - Arguments to find a Boss
     * @example
     * // Get one Boss
     * const boss = await prisma.boss.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BossFindFirstArgs>(args?: SelectSubset<T, BossFindFirstArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boss that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossFindFirstOrThrowArgs} args - Arguments to find a Boss
     * @example
     * // Get one Boss
     * const boss = await prisma.boss.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BossFindFirstOrThrowArgs>(args?: SelectSubset<T, BossFindFirstOrThrowArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bosses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bosses
     * const bosses = await prisma.boss.findMany()
     * 
     * // Get first 10 Bosses
     * const bosses = await prisma.boss.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bossWithIdOnly = await prisma.boss.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BossFindManyArgs>(args?: SelectSubset<T, BossFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Boss.
     * @param {BossCreateArgs} args - Arguments to create a Boss.
     * @example
     * // Create one Boss
     * const Boss = await prisma.boss.create({
     *   data: {
     *     // ... data to create a Boss
     *   }
     * })
     * 
     */
    create<T extends BossCreateArgs>(args: SelectSubset<T, BossCreateArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bosses.
     * @param {BossCreateManyArgs} args - Arguments to create many Bosses.
     * @example
     * // Create many Bosses
     * const boss = await prisma.boss.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BossCreateManyArgs>(args?: SelectSubset<T, BossCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bosses and returns the data saved in the database.
     * @param {BossCreateManyAndReturnArgs} args - Arguments to create many Bosses.
     * @example
     * // Create many Bosses
     * const boss = await prisma.boss.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bosses and only return the `id`
     * const bossWithIdOnly = await prisma.boss.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BossCreateManyAndReturnArgs>(args?: SelectSubset<T, BossCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Boss.
     * @param {BossDeleteArgs} args - Arguments to delete one Boss.
     * @example
     * // Delete one Boss
     * const Boss = await prisma.boss.delete({
     *   where: {
     *     // ... filter to delete one Boss
     *   }
     * })
     * 
     */
    delete<T extends BossDeleteArgs>(args: SelectSubset<T, BossDeleteArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Boss.
     * @param {BossUpdateArgs} args - Arguments to update one Boss.
     * @example
     * // Update one Boss
     * const boss = await prisma.boss.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BossUpdateArgs>(args: SelectSubset<T, BossUpdateArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bosses.
     * @param {BossDeleteManyArgs} args - Arguments to filter Bosses to delete.
     * @example
     * // Delete a few Bosses
     * const { count } = await prisma.boss.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BossDeleteManyArgs>(args?: SelectSubset<T, BossDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bosses
     * const boss = await prisma.boss.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BossUpdateManyArgs>(args: SelectSubset<T, BossUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bosses and returns the data updated in the database.
     * @param {BossUpdateManyAndReturnArgs} args - Arguments to update many Bosses.
     * @example
     * // Update many Bosses
     * const boss = await prisma.boss.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bosses and only return the `id`
     * const bossWithIdOnly = await prisma.boss.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BossUpdateManyAndReturnArgs>(args: SelectSubset<T, BossUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Boss.
     * @param {BossUpsertArgs} args - Arguments to update or create a Boss.
     * @example
     * // Update or create a Boss
     * const boss = await prisma.boss.upsert({
     *   create: {
     *     // ... data to create a Boss
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Boss we want to update
     *   }
     * })
     */
    upsert<T extends BossUpsertArgs>(args: SelectSubset<T, BossUpsertArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossCountArgs} args - Arguments to filter Bosses to count.
     * @example
     * // Count the number of Bosses
     * const count = await prisma.boss.count({
     *   where: {
     *     // ... the filter for the Bosses we want to count
     *   }
     * })
    **/
    count<T extends BossCountArgs>(
      args?: Subset<T, BossCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BossCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Boss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BossAggregateArgs>(args: Subset<T, BossAggregateArgs>): Prisma.PrismaPromise<GetBossAggregateType<T>>

    /**
     * Group by Boss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BossGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BossGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BossGroupByArgs['orderBy'] }
        : { orderBy?: BossGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BossGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBossGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Boss model
   */
  readonly fields: BossFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Boss.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BossClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    raidBosses<T extends Boss$raidBossesArgs<ExtArgs> = {}>(args?: Subset<T, Boss$raidBossesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Boss model
   */
  interface BossFieldRefs {
    readonly id: FieldRef<"Boss", 'Int'>
    readonly boss_name: FieldRef<"Boss", 'String'>
    readonly dkp_points: FieldRef<"Boss", 'Int'>
    readonly category: FieldRef<"Boss", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Boss findUnique
   */
  export type BossFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * Filter, which Boss to fetch.
     */
    where: BossWhereUniqueInput
  }

  /**
   * Boss findUniqueOrThrow
   */
  export type BossFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * Filter, which Boss to fetch.
     */
    where: BossWhereUniqueInput
  }

  /**
   * Boss findFirst
   */
  export type BossFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * Filter, which Boss to fetch.
     */
    where?: BossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bosses to fetch.
     */
    orderBy?: BossOrderByWithRelationInput | BossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bosses.
     */
    cursor?: BossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bosses.
     */
    distinct?: BossScalarFieldEnum | BossScalarFieldEnum[]
  }

  /**
   * Boss findFirstOrThrow
   */
  export type BossFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * Filter, which Boss to fetch.
     */
    where?: BossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bosses to fetch.
     */
    orderBy?: BossOrderByWithRelationInput | BossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bosses.
     */
    cursor?: BossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bosses.
     */
    distinct?: BossScalarFieldEnum | BossScalarFieldEnum[]
  }

  /**
   * Boss findMany
   */
  export type BossFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * Filter, which Bosses to fetch.
     */
    where?: BossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bosses to fetch.
     */
    orderBy?: BossOrderByWithRelationInput | BossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bosses.
     */
    cursor?: BossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bosses.
     */
    skip?: number
    distinct?: BossScalarFieldEnum | BossScalarFieldEnum[]
  }

  /**
   * Boss create
   */
  export type BossCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * The data needed to create a Boss.
     */
    data: XOR<BossCreateInput, BossUncheckedCreateInput>
  }

  /**
   * Boss createMany
   */
  export type BossCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bosses.
     */
    data: BossCreateManyInput | BossCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Boss createManyAndReturn
   */
  export type BossCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * The data used to create many Bosses.
     */
    data: BossCreateManyInput | BossCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Boss update
   */
  export type BossUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * The data needed to update a Boss.
     */
    data: XOR<BossUpdateInput, BossUncheckedUpdateInput>
    /**
     * Choose, which Boss to update.
     */
    where: BossWhereUniqueInput
  }

  /**
   * Boss updateMany
   */
  export type BossUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bosses.
     */
    data: XOR<BossUpdateManyMutationInput, BossUncheckedUpdateManyInput>
    /**
     * Filter which Bosses to update
     */
    where?: BossWhereInput
    /**
     * Limit how many Bosses to update.
     */
    limit?: number
  }

  /**
   * Boss updateManyAndReturn
   */
  export type BossUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * The data used to update Bosses.
     */
    data: XOR<BossUpdateManyMutationInput, BossUncheckedUpdateManyInput>
    /**
     * Filter which Bosses to update
     */
    where?: BossWhereInput
    /**
     * Limit how many Bosses to update.
     */
    limit?: number
  }

  /**
   * Boss upsert
   */
  export type BossUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * The filter to search for the Boss to update in case it exists.
     */
    where: BossWhereUniqueInput
    /**
     * In case the Boss found by the `where` argument doesn't exist, create a new Boss with this data.
     */
    create: XOR<BossCreateInput, BossUncheckedCreateInput>
    /**
     * In case the Boss was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BossUpdateInput, BossUncheckedUpdateInput>
  }

  /**
   * Boss delete
   */
  export type BossDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
    /**
     * Filter which Boss to delete.
     */
    where: BossWhereUniqueInput
  }

  /**
   * Boss deleteMany
   */
  export type BossDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bosses to delete
     */
    where?: BossWhereInput
    /**
     * Limit how many Bosses to delete.
     */
    limit?: number
  }

  /**
   * Boss.raidBosses
   */
  export type Boss$raidBossesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    where?: RaidBossWhereInput
    orderBy?: RaidBossOrderByWithRelationInput | RaidBossOrderByWithRelationInput[]
    cursor?: RaidBossWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaidBossScalarFieldEnum | RaidBossScalarFieldEnum[]
  }

  /**
   * Boss without action
   */
  export type BossDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Boss
     */
    select?: BossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Boss
     */
    omit?: BossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BossInclude<ExtArgs> | null
  }


  /**
   * Model RaidBoss
   */

  export type AggregateRaidBoss = {
    _count: RaidBossCountAggregateOutputType | null
    _avg: RaidBossAvgAggregateOutputType | null
    _sum: RaidBossSumAggregateOutputType | null
    _min: RaidBossMinAggregateOutputType | null
    _max: RaidBossMaxAggregateOutputType | null
  }

  export type RaidBossAvgAggregateOutputType = {
    raid_id: number | null
    boss_id: number | null
  }

  export type RaidBossSumAggregateOutputType = {
    raid_id: number | null
    boss_id: number | null
  }

  export type RaidBossMinAggregateOutputType = {
    raid_id: number | null
    boss_id: number | null
  }

  export type RaidBossMaxAggregateOutputType = {
    raid_id: number | null
    boss_id: number | null
  }

  export type RaidBossCountAggregateOutputType = {
    raid_id: number
    boss_id: number
    _all: number
  }


  export type RaidBossAvgAggregateInputType = {
    raid_id?: true
    boss_id?: true
  }

  export type RaidBossSumAggregateInputType = {
    raid_id?: true
    boss_id?: true
  }

  export type RaidBossMinAggregateInputType = {
    raid_id?: true
    boss_id?: true
  }

  export type RaidBossMaxAggregateInputType = {
    raid_id?: true
    boss_id?: true
  }

  export type RaidBossCountAggregateInputType = {
    raid_id?: true
    boss_id?: true
    _all?: true
  }

  export type RaidBossAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaidBoss to aggregate.
     */
    where?: RaidBossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidBosses to fetch.
     */
    orderBy?: RaidBossOrderByWithRelationInput | RaidBossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaidBossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidBosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidBosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaidBosses
    **/
    _count?: true | RaidBossCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaidBossAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaidBossSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaidBossMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaidBossMaxAggregateInputType
  }

  export type GetRaidBossAggregateType<T extends RaidBossAggregateArgs> = {
        [P in keyof T & keyof AggregateRaidBoss]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaidBoss[P]>
      : GetScalarType<T[P], AggregateRaidBoss[P]>
  }




  export type RaidBossGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidBossWhereInput
    orderBy?: RaidBossOrderByWithAggregationInput | RaidBossOrderByWithAggregationInput[]
    by: RaidBossScalarFieldEnum[] | RaidBossScalarFieldEnum
    having?: RaidBossScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaidBossCountAggregateInputType | true
    _avg?: RaidBossAvgAggregateInputType
    _sum?: RaidBossSumAggregateInputType
    _min?: RaidBossMinAggregateInputType
    _max?: RaidBossMaxAggregateInputType
  }

  export type RaidBossGroupByOutputType = {
    raid_id: number
    boss_id: number
    _count: RaidBossCountAggregateOutputType | null
    _avg: RaidBossAvgAggregateOutputType | null
    _sum: RaidBossSumAggregateOutputType | null
    _min: RaidBossMinAggregateOutputType | null
    _max: RaidBossMaxAggregateOutputType | null
  }

  type GetRaidBossGroupByPayload<T extends RaidBossGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaidBossGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaidBossGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaidBossGroupByOutputType[P]>
            : GetScalarType<T[P], RaidBossGroupByOutputType[P]>
        }
      >
    >


  export type RaidBossSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raid_id?: boolean
    boss_id?: boolean
    boss?: boolean | BossDefaultArgs<ExtArgs>
    raid?: boolean | RaidDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raidBoss"]>

  export type RaidBossSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raid_id?: boolean
    boss_id?: boolean
    boss?: boolean | BossDefaultArgs<ExtArgs>
    raid?: boolean | RaidDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raidBoss"]>

  export type RaidBossSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    raid_id?: boolean
    boss_id?: boolean
    boss?: boolean | BossDefaultArgs<ExtArgs>
    raid?: boolean | RaidDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raidBoss"]>

  export type RaidBossSelectScalar = {
    raid_id?: boolean
    boss_id?: boolean
  }

  export type RaidBossOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"raid_id" | "boss_id", ExtArgs["result"]["raidBoss"]>
  export type RaidBossInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boss?: boolean | BossDefaultArgs<ExtArgs>
    raid?: boolean | RaidDefaultArgs<ExtArgs>
  }
  export type RaidBossIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boss?: boolean | BossDefaultArgs<ExtArgs>
    raid?: boolean | RaidDefaultArgs<ExtArgs>
  }
  export type RaidBossIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boss?: boolean | BossDefaultArgs<ExtArgs>
    raid?: boolean | RaidDefaultArgs<ExtArgs>
  }

  export type $RaidBossPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaidBoss"
    objects: {
      boss: Prisma.$BossPayload<ExtArgs>
      raid: Prisma.$RaidPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      raid_id: number
      boss_id: number
    }, ExtArgs["result"]["raidBoss"]>
    composites: {}
  }

  type RaidBossGetPayload<S extends boolean | null | undefined | RaidBossDefaultArgs> = $Result.GetResult<Prisma.$RaidBossPayload, S>

  type RaidBossCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaidBossFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaidBossCountAggregateInputType | true
    }

  export interface RaidBossDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaidBoss'], meta: { name: 'RaidBoss' } }
    /**
     * Find zero or one RaidBoss that matches the filter.
     * @param {RaidBossFindUniqueArgs} args - Arguments to find a RaidBoss
     * @example
     * // Get one RaidBoss
     * const raidBoss = await prisma.raidBoss.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaidBossFindUniqueArgs>(args: SelectSubset<T, RaidBossFindUniqueArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaidBoss that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaidBossFindUniqueOrThrowArgs} args - Arguments to find a RaidBoss
     * @example
     * // Get one RaidBoss
     * const raidBoss = await prisma.raidBoss.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaidBossFindUniqueOrThrowArgs>(args: SelectSubset<T, RaidBossFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaidBoss that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossFindFirstArgs} args - Arguments to find a RaidBoss
     * @example
     * // Get one RaidBoss
     * const raidBoss = await prisma.raidBoss.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaidBossFindFirstArgs>(args?: SelectSubset<T, RaidBossFindFirstArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaidBoss that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossFindFirstOrThrowArgs} args - Arguments to find a RaidBoss
     * @example
     * // Get one RaidBoss
     * const raidBoss = await prisma.raidBoss.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaidBossFindFirstOrThrowArgs>(args?: SelectSubset<T, RaidBossFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaidBosses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaidBosses
     * const raidBosses = await prisma.raidBoss.findMany()
     * 
     * // Get first 10 RaidBosses
     * const raidBosses = await prisma.raidBoss.findMany({ take: 10 })
     * 
     * // Only select the `raid_id`
     * const raidBossWithRaid_idOnly = await prisma.raidBoss.findMany({ select: { raid_id: true } })
     * 
     */
    findMany<T extends RaidBossFindManyArgs>(args?: SelectSubset<T, RaidBossFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaidBoss.
     * @param {RaidBossCreateArgs} args - Arguments to create a RaidBoss.
     * @example
     * // Create one RaidBoss
     * const RaidBoss = await prisma.raidBoss.create({
     *   data: {
     *     // ... data to create a RaidBoss
     *   }
     * })
     * 
     */
    create<T extends RaidBossCreateArgs>(args: SelectSubset<T, RaidBossCreateArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaidBosses.
     * @param {RaidBossCreateManyArgs} args - Arguments to create many RaidBosses.
     * @example
     * // Create many RaidBosses
     * const raidBoss = await prisma.raidBoss.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaidBossCreateManyArgs>(args?: SelectSubset<T, RaidBossCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RaidBosses and returns the data saved in the database.
     * @param {RaidBossCreateManyAndReturnArgs} args - Arguments to create many RaidBosses.
     * @example
     * // Create many RaidBosses
     * const raidBoss = await prisma.raidBoss.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RaidBosses and only return the `raid_id`
     * const raidBossWithRaid_idOnly = await prisma.raidBoss.createManyAndReturn({
     *   select: { raid_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaidBossCreateManyAndReturnArgs>(args?: SelectSubset<T, RaidBossCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RaidBoss.
     * @param {RaidBossDeleteArgs} args - Arguments to delete one RaidBoss.
     * @example
     * // Delete one RaidBoss
     * const RaidBoss = await prisma.raidBoss.delete({
     *   where: {
     *     // ... filter to delete one RaidBoss
     *   }
     * })
     * 
     */
    delete<T extends RaidBossDeleteArgs>(args: SelectSubset<T, RaidBossDeleteArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaidBoss.
     * @param {RaidBossUpdateArgs} args - Arguments to update one RaidBoss.
     * @example
     * // Update one RaidBoss
     * const raidBoss = await prisma.raidBoss.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaidBossUpdateArgs>(args: SelectSubset<T, RaidBossUpdateArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaidBosses.
     * @param {RaidBossDeleteManyArgs} args - Arguments to filter RaidBosses to delete.
     * @example
     * // Delete a few RaidBosses
     * const { count } = await prisma.raidBoss.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaidBossDeleteManyArgs>(args?: SelectSubset<T, RaidBossDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaidBosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaidBosses
     * const raidBoss = await prisma.raidBoss.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaidBossUpdateManyArgs>(args: SelectSubset<T, RaidBossUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaidBosses and returns the data updated in the database.
     * @param {RaidBossUpdateManyAndReturnArgs} args - Arguments to update many RaidBosses.
     * @example
     * // Update many RaidBosses
     * const raidBoss = await prisma.raidBoss.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RaidBosses and only return the `raid_id`
     * const raidBossWithRaid_idOnly = await prisma.raidBoss.updateManyAndReturn({
     *   select: { raid_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaidBossUpdateManyAndReturnArgs>(args: SelectSubset<T, RaidBossUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RaidBoss.
     * @param {RaidBossUpsertArgs} args - Arguments to update or create a RaidBoss.
     * @example
     * // Update or create a RaidBoss
     * const raidBoss = await prisma.raidBoss.upsert({
     *   create: {
     *     // ... data to create a RaidBoss
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaidBoss we want to update
     *   }
     * })
     */
    upsert<T extends RaidBossUpsertArgs>(args: SelectSubset<T, RaidBossUpsertArgs<ExtArgs>>): Prisma__RaidBossClient<$Result.GetResult<Prisma.$RaidBossPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaidBosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossCountArgs} args - Arguments to filter RaidBosses to count.
     * @example
     * // Count the number of RaidBosses
     * const count = await prisma.raidBoss.count({
     *   where: {
     *     // ... the filter for the RaidBosses we want to count
     *   }
     * })
    **/
    count<T extends RaidBossCountArgs>(
      args?: Subset<T, RaidBossCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaidBossCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaidBoss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaidBossAggregateArgs>(args: Subset<T, RaidBossAggregateArgs>): Prisma.PrismaPromise<GetRaidBossAggregateType<T>>

    /**
     * Group by RaidBoss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidBossGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaidBossGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaidBossGroupByArgs['orderBy'] }
        : { orderBy?: RaidBossGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaidBossGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaidBossGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaidBoss model
   */
  readonly fields: RaidBossFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaidBoss.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaidBossClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    boss<T extends BossDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BossDefaultArgs<ExtArgs>>): Prisma__BossClient<$Result.GetResult<Prisma.$BossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    raid<T extends RaidDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaidDefaultArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaidBoss model
   */
  interface RaidBossFieldRefs {
    readonly raid_id: FieldRef<"RaidBoss", 'Int'>
    readonly boss_id: FieldRef<"RaidBoss", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RaidBoss findUnique
   */
  export type RaidBossFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * Filter, which RaidBoss to fetch.
     */
    where: RaidBossWhereUniqueInput
  }

  /**
   * RaidBoss findUniqueOrThrow
   */
  export type RaidBossFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * Filter, which RaidBoss to fetch.
     */
    where: RaidBossWhereUniqueInput
  }

  /**
   * RaidBoss findFirst
   */
  export type RaidBossFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * Filter, which RaidBoss to fetch.
     */
    where?: RaidBossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidBosses to fetch.
     */
    orderBy?: RaidBossOrderByWithRelationInput | RaidBossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaidBosses.
     */
    cursor?: RaidBossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidBosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidBosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaidBosses.
     */
    distinct?: RaidBossScalarFieldEnum | RaidBossScalarFieldEnum[]
  }

  /**
   * RaidBoss findFirstOrThrow
   */
  export type RaidBossFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * Filter, which RaidBoss to fetch.
     */
    where?: RaidBossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidBosses to fetch.
     */
    orderBy?: RaidBossOrderByWithRelationInput | RaidBossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaidBosses.
     */
    cursor?: RaidBossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidBosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidBosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaidBosses.
     */
    distinct?: RaidBossScalarFieldEnum | RaidBossScalarFieldEnum[]
  }

  /**
   * RaidBoss findMany
   */
  export type RaidBossFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * Filter, which RaidBosses to fetch.
     */
    where?: RaidBossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidBosses to fetch.
     */
    orderBy?: RaidBossOrderByWithRelationInput | RaidBossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaidBosses.
     */
    cursor?: RaidBossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidBosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidBosses.
     */
    skip?: number
    distinct?: RaidBossScalarFieldEnum | RaidBossScalarFieldEnum[]
  }

  /**
   * RaidBoss create
   */
  export type RaidBossCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * The data needed to create a RaidBoss.
     */
    data: XOR<RaidBossCreateInput, RaidBossUncheckedCreateInput>
  }

  /**
   * RaidBoss createMany
   */
  export type RaidBossCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaidBosses.
     */
    data: RaidBossCreateManyInput | RaidBossCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaidBoss createManyAndReturn
   */
  export type RaidBossCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * The data used to create many RaidBosses.
     */
    data: RaidBossCreateManyInput | RaidBossCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaidBoss update
   */
  export type RaidBossUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * The data needed to update a RaidBoss.
     */
    data: XOR<RaidBossUpdateInput, RaidBossUncheckedUpdateInput>
    /**
     * Choose, which RaidBoss to update.
     */
    where: RaidBossWhereUniqueInput
  }

  /**
   * RaidBoss updateMany
   */
  export type RaidBossUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaidBosses.
     */
    data: XOR<RaidBossUpdateManyMutationInput, RaidBossUncheckedUpdateManyInput>
    /**
     * Filter which RaidBosses to update
     */
    where?: RaidBossWhereInput
    /**
     * Limit how many RaidBosses to update.
     */
    limit?: number
  }

  /**
   * RaidBoss updateManyAndReturn
   */
  export type RaidBossUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * The data used to update RaidBosses.
     */
    data: XOR<RaidBossUpdateManyMutationInput, RaidBossUncheckedUpdateManyInput>
    /**
     * Filter which RaidBosses to update
     */
    where?: RaidBossWhereInput
    /**
     * Limit how many RaidBosses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaidBoss upsert
   */
  export type RaidBossUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * The filter to search for the RaidBoss to update in case it exists.
     */
    where: RaidBossWhereUniqueInput
    /**
     * In case the RaidBoss found by the `where` argument doesn't exist, create a new RaidBoss with this data.
     */
    create: XOR<RaidBossCreateInput, RaidBossUncheckedCreateInput>
    /**
     * In case the RaidBoss was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaidBossUpdateInput, RaidBossUncheckedUpdateInput>
  }

  /**
   * RaidBoss delete
   */
  export type RaidBossDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
    /**
     * Filter which RaidBoss to delete.
     */
    where: RaidBossWhereUniqueInput
  }

  /**
   * RaidBoss deleteMany
   */
  export type RaidBossDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaidBosses to delete
     */
    where?: RaidBossWhereInput
    /**
     * Limit how many RaidBosses to delete.
     */
    limit?: number
  }

  /**
   * RaidBoss without action
   */
  export type RaidBossDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidBoss
     */
    select?: RaidBossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidBoss
     */
    omit?: RaidBossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidBossInclude<ExtArgs> | null
  }


  /**
   * Model RaidAttendance
   */

  export type AggregateRaidAttendance = {
    _count: RaidAttendanceCountAggregateOutputType | null
    _avg: RaidAttendanceAvgAggregateOutputType | null
    _sum: RaidAttendanceSumAggregateOutputType | null
    _min: RaidAttendanceMinAggregateOutputType | null
    _max: RaidAttendanceMaxAggregateOutputType | null
  }

  export type RaidAttendanceAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    raid_id: number | null
  }

  export type RaidAttendanceSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    raid_id: number | null
  }

  export type RaidAttendanceMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    raid_id: number | null
    created_at: Date | null
  }

  export type RaidAttendanceMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    raid_id: number | null
    created_at: Date | null
  }

  export type RaidAttendanceCountAggregateOutputType = {
    id: number
    user_id: number
    raid_id: number
    created_at: number
    _all: number
  }


  export type RaidAttendanceAvgAggregateInputType = {
    id?: true
    user_id?: true
    raid_id?: true
  }

  export type RaidAttendanceSumAggregateInputType = {
    id?: true
    user_id?: true
    raid_id?: true
  }

  export type RaidAttendanceMinAggregateInputType = {
    id?: true
    user_id?: true
    raid_id?: true
    created_at?: true
  }

  export type RaidAttendanceMaxAggregateInputType = {
    id?: true
    user_id?: true
    raid_id?: true
    created_at?: true
  }

  export type RaidAttendanceCountAggregateInputType = {
    id?: true
    user_id?: true
    raid_id?: true
    created_at?: true
    _all?: true
  }

  export type RaidAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaidAttendance to aggregate.
     */
    where?: RaidAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidAttendances to fetch.
     */
    orderBy?: RaidAttendanceOrderByWithRelationInput | RaidAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaidAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RaidAttendances
    **/
    _count?: true | RaidAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaidAttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaidAttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaidAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaidAttendanceMaxAggregateInputType
  }

  export type GetRaidAttendanceAggregateType<T extends RaidAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateRaidAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaidAttendance[P]>
      : GetScalarType<T[P], AggregateRaidAttendance[P]>
  }




  export type RaidAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaidAttendanceWhereInput
    orderBy?: RaidAttendanceOrderByWithAggregationInput | RaidAttendanceOrderByWithAggregationInput[]
    by: RaidAttendanceScalarFieldEnum[] | RaidAttendanceScalarFieldEnum
    having?: RaidAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaidAttendanceCountAggregateInputType | true
    _avg?: RaidAttendanceAvgAggregateInputType
    _sum?: RaidAttendanceSumAggregateInputType
    _min?: RaidAttendanceMinAggregateInputType
    _max?: RaidAttendanceMaxAggregateInputType
  }

  export type RaidAttendanceGroupByOutputType = {
    id: number
    user_id: number
    raid_id: number
    created_at: Date
    _count: RaidAttendanceCountAggregateOutputType | null
    _avg: RaidAttendanceAvgAggregateOutputType | null
    _sum: RaidAttendanceSumAggregateOutputType | null
    _min: RaidAttendanceMinAggregateOutputType | null
    _max: RaidAttendanceMaxAggregateOutputType | null
  }

  type GetRaidAttendanceGroupByPayload<T extends RaidAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaidAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaidAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaidAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], RaidAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type RaidAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    raid_id?: boolean
    created_at?: boolean
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raidAttendance"]>

  export type RaidAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    raid_id?: boolean
    created_at?: boolean
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raidAttendance"]>

  export type RaidAttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    raid_id?: boolean
    created_at?: boolean
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raidAttendance"]>

  export type RaidAttendanceSelectScalar = {
    id?: boolean
    user_id?: boolean
    raid_id?: boolean
    created_at?: boolean
  }

  export type RaidAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "raid_id" | "created_at", ExtArgs["result"]["raidAttendance"]>
  export type RaidAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RaidAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RaidAttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    raid?: boolean | RaidDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RaidAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RaidAttendance"
    objects: {
      raid: Prisma.$RaidPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      raid_id: number
      created_at: Date
    }, ExtArgs["result"]["raidAttendance"]>
    composites: {}
  }

  type RaidAttendanceGetPayload<S extends boolean | null | undefined | RaidAttendanceDefaultArgs> = $Result.GetResult<Prisma.$RaidAttendancePayload, S>

  type RaidAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RaidAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RaidAttendanceCountAggregateInputType | true
    }

  export interface RaidAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RaidAttendance'], meta: { name: 'RaidAttendance' } }
    /**
     * Find zero or one RaidAttendance that matches the filter.
     * @param {RaidAttendanceFindUniqueArgs} args - Arguments to find a RaidAttendance
     * @example
     * // Get one RaidAttendance
     * const raidAttendance = await prisma.raidAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaidAttendanceFindUniqueArgs>(args: SelectSubset<T, RaidAttendanceFindUniqueArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RaidAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RaidAttendanceFindUniqueOrThrowArgs} args - Arguments to find a RaidAttendance
     * @example
     * // Get one RaidAttendance
     * const raidAttendance = await prisma.raidAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaidAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, RaidAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaidAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceFindFirstArgs} args - Arguments to find a RaidAttendance
     * @example
     * // Get one RaidAttendance
     * const raidAttendance = await prisma.raidAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaidAttendanceFindFirstArgs>(args?: SelectSubset<T, RaidAttendanceFindFirstArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RaidAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceFindFirstOrThrowArgs} args - Arguments to find a RaidAttendance
     * @example
     * // Get one RaidAttendance
     * const raidAttendance = await prisma.raidAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaidAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, RaidAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RaidAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RaidAttendances
     * const raidAttendances = await prisma.raidAttendance.findMany()
     * 
     * // Get first 10 RaidAttendances
     * const raidAttendances = await prisma.raidAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raidAttendanceWithIdOnly = await prisma.raidAttendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaidAttendanceFindManyArgs>(args?: SelectSubset<T, RaidAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RaidAttendance.
     * @param {RaidAttendanceCreateArgs} args - Arguments to create a RaidAttendance.
     * @example
     * // Create one RaidAttendance
     * const RaidAttendance = await prisma.raidAttendance.create({
     *   data: {
     *     // ... data to create a RaidAttendance
     *   }
     * })
     * 
     */
    create<T extends RaidAttendanceCreateArgs>(args: SelectSubset<T, RaidAttendanceCreateArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RaidAttendances.
     * @param {RaidAttendanceCreateManyArgs} args - Arguments to create many RaidAttendances.
     * @example
     * // Create many RaidAttendances
     * const raidAttendance = await prisma.raidAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaidAttendanceCreateManyArgs>(args?: SelectSubset<T, RaidAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RaidAttendances and returns the data saved in the database.
     * @param {RaidAttendanceCreateManyAndReturnArgs} args - Arguments to create many RaidAttendances.
     * @example
     * // Create many RaidAttendances
     * const raidAttendance = await prisma.raidAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RaidAttendances and only return the `id`
     * const raidAttendanceWithIdOnly = await prisma.raidAttendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaidAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, RaidAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RaidAttendance.
     * @param {RaidAttendanceDeleteArgs} args - Arguments to delete one RaidAttendance.
     * @example
     * // Delete one RaidAttendance
     * const RaidAttendance = await prisma.raidAttendance.delete({
     *   where: {
     *     // ... filter to delete one RaidAttendance
     *   }
     * })
     * 
     */
    delete<T extends RaidAttendanceDeleteArgs>(args: SelectSubset<T, RaidAttendanceDeleteArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RaidAttendance.
     * @param {RaidAttendanceUpdateArgs} args - Arguments to update one RaidAttendance.
     * @example
     * // Update one RaidAttendance
     * const raidAttendance = await prisma.raidAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaidAttendanceUpdateArgs>(args: SelectSubset<T, RaidAttendanceUpdateArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RaidAttendances.
     * @param {RaidAttendanceDeleteManyArgs} args - Arguments to filter RaidAttendances to delete.
     * @example
     * // Delete a few RaidAttendances
     * const { count } = await prisma.raidAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaidAttendanceDeleteManyArgs>(args?: SelectSubset<T, RaidAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaidAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RaidAttendances
     * const raidAttendance = await prisma.raidAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaidAttendanceUpdateManyArgs>(args: SelectSubset<T, RaidAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RaidAttendances and returns the data updated in the database.
     * @param {RaidAttendanceUpdateManyAndReturnArgs} args - Arguments to update many RaidAttendances.
     * @example
     * // Update many RaidAttendances
     * const raidAttendance = await prisma.raidAttendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RaidAttendances and only return the `id`
     * const raidAttendanceWithIdOnly = await prisma.raidAttendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RaidAttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, RaidAttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RaidAttendance.
     * @param {RaidAttendanceUpsertArgs} args - Arguments to update or create a RaidAttendance.
     * @example
     * // Update or create a RaidAttendance
     * const raidAttendance = await prisma.raidAttendance.upsert({
     *   create: {
     *     // ... data to create a RaidAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RaidAttendance we want to update
     *   }
     * })
     */
    upsert<T extends RaidAttendanceUpsertArgs>(args: SelectSubset<T, RaidAttendanceUpsertArgs<ExtArgs>>): Prisma__RaidAttendanceClient<$Result.GetResult<Prisma.$RaidAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RaidAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceCountArgs} args - Arguments to filter RaidAttendances to count.
     * @example
     * // Count the number of RaidAttendances
     * const count = await prisma.raidAttendance.count({
     *   where: {
     *     // ... the filter for the RaidAttendances we want to count
     *   }
     * })
    **/
    count<T extends RaidAttendanceCountArgs>(
      args?: Subset<T, RaidAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaidAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RaidAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaidAttendanceAggregateArgs>(args: Subset<T, RaidAttendanceAggregateArgs>): Prisma.PrismaPromise<GetRaidAttendanceAggregateType<T>>

    /**
     * Group by RaidAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaidAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaidAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaidAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: RaidAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaidAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaidAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RaidAttendance model
   */
  readonly fields: RaidAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RaidAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaidAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    raid<T extends RaidDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaidDefaultArgs<ExtArgs>>): Prisma__RaidClient<$Result.GetResult<Prisma.$RaidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RaidAttendance model
   */
  interface RaidAttendanceFieldRefs {
    readonly id: FieldRef<"RaidAttendance", 'Int'>
    readonly user_id: FieldRef<"RaidAttendance", 'Int'>
    readonly raid_id: FieldRef<"RaidAttendance", 'Int'>
    readonly created_at: FieldRef<"RaidAttendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RaidAttendance findUnique
   */
  export type RaidAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RaidAttendance to fetch.
     */
    where: RaidAttendanceWhereUniqueInput
  }

  /**
   * RaidAttendance findUniqueOrThrow
   */
  export type RaidAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RaidAttendance to fetch.
     */
    where: RaidAttendanceWhereUniqueInput
  }

  /**
   * RaidAttendance findFirst
   */
  export type RaidAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RaidAttendance to fetch.
     */
    where?: RaidAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidAttendances to fetch.
     */
    orderBy?: RaidAttendanceOrderByWithRelationInput | RaidAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaidAttendances.
     */
    cursor?: RaidAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaidAttendances.
     */
    distinct?: RaidAttendanceScalarFieldEnum | RaidAttendanceScalarFieldEnum[]
  }

  /**
   * RaidAttendance findFirstOrThrow
   */
  export type RaidAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RaidAttendance to fetch.
     */
    where?: RaidAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidAttendances to fetch.
     */
    orderBy?: RaidAttendanceOrderByWithRelationInput | RaidAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RaidAttendances.
     */
    cursor?: RaidAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RaidAttendances.
     */
    distinct?: RaidAttendanceScalarFieldEnum | RaidAttendanceScalarFieldEnum[]
  }

  /**
   * RaidAttendance findMany
   */
  export type RaidAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RaidAttendances to fetch.
     */
    where?: RaidAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RaidAttendances to fetch.
     */
    orderBy?: RaidAttendanceOrderByWithRelationInput | RaidAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RaidAttendances.
     */
    cursor?: RaidAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RaidAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RaidAttendances.
     */
    skip?: number
    distinct?: RaidAttendanceScalarFieldEnum | RaidAttendanceScalarFieldEnum[]
  }

  /**
   * RaidAttendance create
   */
  export type RaidAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a RaidAttendance.
     */
    data: XOR<RaidAttendanceCreateInput, RaidAttendanceUncheckedCreateInput>
  }

  /**
   * RaidAttendance createMany
   */
  export type RaidAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RaidAttendances.
     */
    data: RaidAttendanceCreateManyInput | RaidAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RaidAttendance createManyAndReturn
   */
  export type RaidAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many RaidAttendances.
     */
    data: RaidAttendanceCreateManyInput | RaidAttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaidAttendance update
   */
  export type RaidAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a RaidAttendance.
     */
    data: XOR<RaidAttendanceUpdateInput, RaidAttendanceUncheckedUpdateInput>
    /**
     * Choose, which RaidAttendance to update.
     */
    where: RaidAttendanceWhereUniqueInput
  }

  /**
   * RaidAttendance updateMany
   */
  export type RaidAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RaidAttendances.
     */
    data: XOR<RaidAttendanceUpdateManyMutationInput, RaidAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which RaidAttendances to update
     */
    where?: RaidAttendanceWhereInput
    /**
     * Limit how many RaidAttendances to update.
     */
    limit?: number
  }

  /**
   * RaidAttendance updateManyAndReturn
   */
  export type RaidAttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * The data used to update RaidAttendances.
     */
    data: XOR<RaidAttendanceUpdateManyMutationInput, RaidAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which RaidAttendances to update
     */
    where?: RaidAttendanceWhereInput
    /**
     * Limit how many RaidAttendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RaidAttendance upsert
   */
  export type RaidAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the RaidAttendance to update in case it exists.
     */
    where: RaidAttendanceWhereUniqueInput
    /**
     * In case the RaidAttendance found by the `where` argument doesn't exist, create a new RaidAttendance with this data.
     */
    create: XOR<RaidAttendanceCreateInput, RaidAttendanceUncheckedCreateInput>
    /**
     * In case the RaidAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaidAttendanceUpdateInput, RaidAttendanceUncheckedUpdateInput>
  }

  /**
   * RaidAttendance delete
   */
  export type RaidAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
    /**
     * Filter which RaidAttendance to delete.
     */
    where: RaidAttendanceWhereUniqueInput
  }

  /**
   * RaidAttendance deleteMany
   */
  export type RaidAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RaidAttendances to delete
     */
    where?: RaidAttendanceWhereInput
    /**
     * Limit how many RaidAttendances to delete.
     */
    limit?: number
  }

  /**
   * RaidAttendance without action
   */
  export type RaidAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaidAttendance
     */
    select?: RaidAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RaidAttendance
     */
    omit?: RaidAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaidAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model ItemType
   */

  export type AggregateItemType = {
    _count: ItemTypeCountAggregateOutputType | null
    _avg: ItemTypeAvgAggregateOutputType | null
    _sum: ItemTypeSumAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  export type ItemTypeAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ItemTypeSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ItemTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
  }

  export type ItemTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
  }

  export type ItemTypeCountAggregateOutputType = {
    id: number
    name: number
    price: number
    _all: number
  }


  export type ItemTypeAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type ItemTypeSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type ItemTypeMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
  }

  export type ItemTypeMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
  }

  export type ItemTypeCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    _all?: true
  }

  export type ItemTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemType to aggregate.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemTypes
    **/
    _count?: true | ItemTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemTypeMaxAggregateInputType
  }

  export type GetItemTypeAggregateType<T extends ItemTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateItemType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemType[P]>
      : GetScalarType<T[P], AggregateItemType[P]>
  }




  export type ItemTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemTypeWhereInput
    orderBy?: ItemTypeOrderByWithAggregationInput | ItemTypeOrderByWithAggregationInput[]
    by: ItemTypeScalarFieldEnum[] | ItemTypeScalarFieldEnum
    having?: ItemTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemTypeCountAggregateInputType | true
    _avg?: ItemTypeAvgAggregateInputType
    _sum?: ItemTypeSumAggregateInputType
    _min?: ItemTypeMinAggregateInputType
    _max?: ItemTypeMaxAggregateInputType
  }

  export type ItemTypeGroupByOutputType = {
    id: number
    name: string
    price: number | null
    _count: ItemTypeCountAggregateOutputType | null
    _avg: ItemTypeAvgAggregateOutputType | null
    _sum: ItemTypeSumAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  type GetItemTypeGroupByPayload<T extends ItemTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
        }
      >
    >


  export type ItemTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    loot?: boolean | ItemType$lootArgs<ExtArgs>
    lootQueue?: boolean | ItemType$lootQueueArgs<ExtArgs>
    _count?: boolean | ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemType"]>

  export type ItemTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
  }, ExtArgs["result"]["itemType"]>

  export type ItemTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
  }, ExtArgs["result"]["itemType"]>

  export type ItemTypeSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
  }

  export type ItemTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price", ExtArgs["result"]["itemType"]>
  export type ItemTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loot?: boolean | ItemType$lootArgs<ExtArgs>
    lootQueue?: boolean | ItemType$lootQueueArgs<ExtArgs>
    _count?: boolean | ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemType"
    objects: {
      loot: Prisma.$LootPayload<ExtArgs>[]
      lootQueue: Prisma.$LootQueuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      price: number | null
    }, ExtArgs["result"]["itemType"]>
    composites: {}
  }

  type ItemTypeGetPayload<S extends boolean | null | undefined | ItemTypeDefaultArgs> = $Result.GetResult<Prisma.$ItemTypePayload, S>

  type ItemTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemTypeCountAggregateInputType | true
    }

  export interface ItemTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemType'], meta: { name: 'ItemType' } }
    /**
     * Find zero or one ItemType that matches the filter.
     * @param {ItemTypeFindUniqueArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemTypeFindUniqueArgs>(args: SelectSubset<T, ItemTypeFindUniqueArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemTypeFindUniqueOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemTypeFindFirstArgs>(args?: SelectSubset<T, ItemTypeFindFirstArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemTypes
     * const itemTypes = await prisma.itemType.findMany()
     * 
     * // Get first 10 ItemTypes
     * const itemTypes = await prisma.itemType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemTypeWithIdOnly = await prisma.itemType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemTypeFindManyArgs>(args?: SelectSubset<T, ItemTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemType.
     * @param {ItemTypeCreateArgs} args - Arguments to create a ItemType.
     * @example
     * // Create one ItemType
     * const ItemType = await prisma.itemType.create({
     *   data: {
     *     // ... data to create a ItemType
     *   }
     * })
     * 
     */
    create<T extends ItemTypeCreateArgs>(args: SelectSubset<T, ItemTypeCreateArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemTypes.
     * @param {ItemTypeCreateManyArgs} args - Arguments to create many ItemTypes.
     * @example
     * // Create many ItemTypes
     * const itemType = await prisma.itemType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemTypeCreateManyArgs>(args?: SelectSubset<T, ItemTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemTypes and returns the data saved in the database.
     * @param {ItemTypeCreateManyAndReturnArgs} args - Arguments to create many ItemTypes.
     * @example
     * // Create many ItemTypes
     * const itemType = await prisma.itemType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemTypes and only return the `id`
     * const itemTypeWithIdOnly = await prisma.itemType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemType.
     * @param {ItemTypeDeleteArgs} args - Arguments to delete one ItemType.
     * @example
     * // Delete one ItemType
     * const ItemType = await prisma.itemType.delete({
     *   where: {
     *     // ... filter to delete one ItemType
     *   }
     * })
     * 
     */
    delete<T extends ItemTypeDeleteArgs>(args: SelectSubset<T, ItemTypeDeleteArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemType.
     * @param {ItemTypeUpdateArgs} args - Arguments to update one ItemType.
     * @example
     * // Update one ItemType
     * const itemType = await prisma.itemType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemTypeUpdateArgs>(args: SelectSubset<T, ItemTypeUpdateArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemTypes.
     * @param {ItemTypeDeleteManyArgs} args - Arguments to filter ItemTypes to delete.
     * @example
     * // Delete a few ItemTypes
     * const { count } = await prisma.itemType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemTypeDeleteManyArgs>(args?: SelectSubset<T, ItemTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemTypes
     * const itemType = await prisma.itemType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemTypeUpdateManyArgs>(args: SelectSubset<T, ItemTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTypes and returns the data updated in the database.
     * @param {ItemTypeUpdateManyAndReturnArgs} args - Arguments to update many ItemTypes.
     * @example
     * // Update many ItemTypes
     * const itemType = await prisma.itemType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemTypes and only return the `id`
     * const itemTypeWithIdOnly = await prisma.itemType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemType.
     * @param {ItemTypeUpsertArgs} args - Arguments to update or create a ItemType.
     * @example
     * // Update or create a ItemType
     * const itemType = await prisma.itemType.upsert({
     *   create: {
     *     // ... data to create a ItemType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemType we want to update
     *   }
     * })
     */
    upsert<T extends ItemTypeUpsertArgs>(args: SelectSubset<T, ItemTypeUpsertArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeCountArgs} args - Arguments to filter ItemTypes to count.
     * @example
     * // Count the number of ItemTypes
     * const count = await prisma.itemType.count({
     *   where: {
     *     // ... the filter for the ItemTypes we want to count
     *   }
     * })
    **/
    count<T extends ItemTypeCountArgs>(
      args?: Subset<T, ItemTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemTypeAggregateArgs>(args: Subset<T, ItemTypeAggregateArgs>): Prisma.PrismaPromise<GetItemTypeAggregateType<T>>

    /**
     * Group by ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemTypeGroupByArgs['orderBy'] }
        : { orderBy?: ItemTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemType model
   */
  readonly fields: ItemTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loot<T extends ItemType$lootArgs<ExtArgs> = {}>(args?: Subset<T, ItemType$lootArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lootQueue<T extends ItemType$lootQueueArgs<ExtArgs> = {}>(args?: Subset<T, ItemType$lootQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemType model
   */
  interface ItemTypeFieldRefs {
    readonly id: FieldRef<"ItemType", 'Int'>
    readonly name: FieldRef<"ItemType", 'String'>
    readonly price: FieldRef<"ItemType", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ItemType findUnique
   */
  export type ItemTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType findUniqueOrThrow
   */
  export type ItemTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType findFirst
   */
  export type ItemTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     */
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }

  /**
   * ItemType findFirstOrThrow
   */
  export type ItemTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     */
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }

  /**
   * ItemType findMany
   */
  export type ItemTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemTypes to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }

  /**
   * ItemType create
   */
  export type ItemTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemType.
     */
    data: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
  }

  /**
   * ItemType createMany
   */
  export type ItemTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemTypes.
     */
    data: ItemTypeCreateManyInput | ItemTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemType createManyAndReturn
   */
  export type ItemTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ItemTypes.
     */
    data: ItemTypeCreateManyInput | ItemTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemType update
   */
  export type ItemTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemType.
     */
    data: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
    /**
     * Choose, which ItemType to update.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType updateMany
   */
  export type ItemTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemTypes.
     */
    data: XOR<ItemTypeUpdateManyMutationInput, ItemTypeUncheckedUpdateManyInput>
    /**
     * Filter which ItemTypes to update
     */
    where?: ItemTypeWhereInput
    /**
     * Limit how many ItemTypes to update.
     */
    limit?: number
  }

  /**
   * ItemType updateManyAndReturn
   */
  export type ItemTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * The data used to update ItemTypes.
     */
    data: XOR<ItemTypeUpdateManyMutationInput, ItemTypeUncheckedUpdateManyInput>
    /**
     * Filter which ItemTypes to update
     */
    where?: ItemTypeWhereInput
    /**
     * Limit how many ItemTypes to update.
     */
    limit?: number
  }

  /**
   * ItemType upsert
   */
  export type ItemTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemType to update in case it exists.
     */
    where: ItemTypeWhereUniqueInput
    /**
     * In case the ItemType found by the `where` argument doesn't exist, create a new ItemType with this data.
     */
    create: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
    /**
     * In case the ItemType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
  }

  /**
   * ItemType delete
   */
  export type ItemTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter which ItemType to delete.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType deleteMany
   */
  export type ItemTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemTypes to delete
     */
    where?: ItemTypeWhereInput
    /**
     * Limit how many ItemTypes to delete.
     */
    limit?: number
  }

  /**
   * ItemType.loot
   */
  export type ItemType$lootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    where?: LootWhereInput
    orderBy?: LootOrderByWithRelationInput | LootOrderByWithRelationInput[]
    cursor?: LootWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LootScalarFieldEnum | LootScalarFieldEnum[]
  }

  /**
   * ItemType.lootQueue
   */
  export type ItemType$lootQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    where?: LootQueueWhereInput
    orderBy?: LootQueueOrderByWithRelationInput | LootQueueOrderByWithRelationInput[]
    cursor?: LootQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LootQueueScalarFieldEnum | LootQueueScalarFieldEnum[]
  }

  /**
   * ItemType without action
   */
  export type ItemTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemType
     */
    omit?: ItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
  }


  /**
   * Model Loot
   */

  export type AggregateLoot = {
    _count: LootCountAggregateOutputType | null
    _avg: LootAvgAggregateOutputType | null
    _sum: LootSumAggregateOutputType | null
    _min: LootMinAggregateOutputType | null
    _max: LootMaxAggregateOutputType | null
  }

  export type LootAvgAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    sold_to_user_id: number | null
    quantity: number | null
    price: number | null
  }

  export type LootSumAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    sold_to_user_id: number | null
    quantity: number | null
    price: number | null
  }

  export type LootMinAggregateOutputType = {
    id: number | null
    status: string | null
    sold_at: Date | null
    sold_to: string | null
    comment: string | null
    created_at: Date | null
    source: string | null
    acquired_at: Date | null
    itemTypeId: number | null
    sold_to_user_id: number | null
    quantity: number | null
    price: number | null
  }

  export type LootMaxAggregateOutputType = {
    id: number | null
    status: string | null
    sold_at: Date | null
    sold_to: string | null
    comment: string | null
    created_at: Date | null
    source: string | null
    acquired_at: Date | null
    itemTypeId: number | null
    sold_to_user_id: number | null
    quantity: number | null
    price: number | null
  }

  export type LootCountAggregateOutputType = {
    id: number
    status: number
    sold_at: number
    sold_to: number
    comment: number
    created_at: number
    source: number
    acquired_at: number
    itemTypeId: number
    sold_to_user_id: number
    quantity: number
    price: number
    _all: number
  }


  export type LootAvgAggregateInputType = {
    id?: true
    itemTypeId?: true
    sold_to_user_id?: true
    quantity?: true
    price?: true
  }

  export type LootSumAggregateInputType = {
    id?: true
    itemTypeId?: true
    sold_to_user_id?: true
    quantity?: true
    price?: true
  }

  export type LootMinAggregateInputType = {
    id?: true
    status?: true
    sold_at?: true
    sold_to?: true
    comment?: true
    created_at?: true
    source?: true
    acquired_at?: true
    itemTypeId?: true
    sold_to_user_id?: true
    quantity?: true
    price?: true
  }

  export type LootMaxAggregateInputType = {
    id?: true
    status?: true
    sold_at?: true
    sold_to?: true
    comment?: true
    created_at?: true
    source?: true
    acquired_at?: true
    itemTypeId?: true
    sold_to_user_id?: true
    quantity?: true
    price?: true
  }

  export type LootCountAggregateInputType = {
    id?: true
    status?: true
    sold_at?: true
    sold_to?: true
    comment?: true
    created_at?: true
    source?: true
    acquired_at?: true
    itemTypeId?: true
    sold_to_user_id?: true
    quantity?: true
    price?: true
    _all?: true
  }

  export type LootAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loot to aggregate.
     */
    where?: LootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loots to fetch.
     */
    orderBy?: LootOrderByWithRelationInput | LootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Loots
    **/
    _count?: true | LootCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LootAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LootSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LootMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LootMaxAggregateInputType
  }

  export type GetLootAggregateType<T extends LootAggregateArgs> = {
        [P in keyof T & keyof AggregateLoot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoot[P]>
      : GetScalarType<T[P], AggregateLoot[P]>
  }




  export type LootGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LootWhereInput
    orderBy?: LootOrderByWithAggregationInput | LootOrderByWithAggregationInput[]
    by: LootScalarFieldEnum[] | LootScalarFieldEnum
    having?: LootScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LootCountAggregateInputType | true
    _avg?: LootAvgAggregateInputType
    _sum?: LootSumAggregateInputType
    _min?: LootMinAggregateInputType
    _max?: LootMaxAggregateInputType
  }

  export type LootGroupByOutputType = {
    id: number
    status: string | null
    sold_at: Date | null
    sold_to: string | null
    comment: string | null
    created_at: Date
    source: string | null
    acquired_at: Date | null
    itemTypeId: number
    sold_to_user_id: number | null
    quantity: number
    price: number | null
    _count: LootCountAggregateOutputType | null
    _avg: LootAvgAggregateOutputType | null
    _sum: LootSumAggregateOutputType | null
    _min: LootMinAggregateOutputType | null
    _max: LootMaxAggregateOutputType | null
  }

  type GetLootGroupByPayload<T extends LootGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LootGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LootGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LootGroupByOutputType[P]>
            : GetScalarType<T[P], LootGroupByOutputType[P]>
        }
      >
    >


  export type LootSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    sold_at?: boolean
    sold_to?: boolean
    comment?: boolean
    created_at?: boolean
    source?: boolean
    acquired_at?: boolean
    itemTypeId?: boolean
    sold_to_user_id?: boolean
    quantity?: boolean
    price?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    soldToUser?: boolean | Loot$soldToUserArgs<ExtArgs>
  }, ExtArgs["result"]["loot"]>

  export type LootSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    sold_at?: boolean
    sold_to?: boolean
    comment?: boolean
    created_at?: boolean
    source?: boolean
    acquired_at?: boolean
    itemTypeId?: boolean
    sold_to_user_id?: boolean
    quantity?: boolean
    price?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    soldToUser?: boolean | Loot$soldToUserArgs<ExtArgs>
  }, ExtArgs["result"]["loot"]>

  export type LootSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    sold_at?: boolean
    sold_to?: boolean
    comment?: boolean
    created_at?: boolean
    source?: boolean
    acquired_at?: boolean
    itemTypeId?: boolean
    sold_to_user_id?: boolean
    quantity?: boolean
    price?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    soldToUser?: boolean | Loot$soldToUserArgs<ExtArgs>
  }, ExtArgs["result"]["loot"]>

  export type LootSelectScalar = {
    id?: boolean
    status?: boolean
    sold_at?: boolean
    sold_to?: boolean
    comment?: boolean
    created_at?: boolean
    source?: boolean
    acquired_at?: boolean
    itemTypeId?: boolean
    sold_to_user_id?: boolean
    quantity?: boolean
    price?: boolean
  }

  export type LootOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "sold_at" | "sold_to" | "comment" | "created_at" | "source" | "acquired_at" | "itemTypeId" | "sold_to_user_id" | "quantity" | "price", ExtArgs["result"]["loot"]>
  export type LootInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    soldToUser?: boolean | Loot$soldToUserArgs<ExtArgs>
  }
  export type LootIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    soldToUser?: boolean | Loot$soldToUserArgs<ExtArgs>
  }
  export type LootIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    soldToUser?: boolean | Loot$soldToUserArgs<ExtArgs>
  }

  export type $LootPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Loot"
    objects: {
      itemType: Prisma.$ItemTypePayload<ExtArgs>
      soldToUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: string | null
      sold_at: Date | null
      sold_to: string | null
      comment: string | null
      created_at: Date
      source: string | null
      acquired_at: Date | null
      itemTypeId: number
      sold_to_user_id: number | null
      quantity: number
      price: number | null
    }, ExtArgs["result"]["loot"]>
    composites: {}
  }

  type LootGetPayload<S extends boolean | null | undefined | LootDefaultArgs> = $Result.GetResult<Prisma.$LootPayload, S>

  type LootCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LootFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LootCountAggregateInputType | true
    }

  export interface LootDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Loot'], meta: { name: 'Loot' } }
    /**
     * Find zero or one Loot that matches the filter.
     * @param {LootFindUniqueArgs} args - Arguments to find a Loot
     * @example
     * // Get one Loot
     * const loot = await prisma.loot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LootFindUniqueArgs>(args: SelectSubset<T, LootFindUniqueArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Loot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LootFindUniqueOrThrowArgs} args - Arguments to find a Loot
     * @example
     * // Get one Loot
     * const loot = await prisma.loot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LootFindUniqueOrThrowArgs>(args: SelectSubset<T, LootFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootFindFirstArgs} args - Arguments to find a Loot
     * @example
     * // Get one Loot
     * const loot = await prisma.loot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LootFindFirstArgs>(args?: SelectSubset<T, LootFindFirstArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootFindFirstOrThrowArgs} args - Arguments to find a Loot
     * @example
     * // Get one Loot
     * const loot = await prisma.loot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LootFindFirstOrThrowArgs>(args?: SelectSubset<T, LootFindFirstOrThrowArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Loots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loots
     * const loots = await prisma.loot.findMany()
     * 
     * // Get first 10 Loots
     * const loots = await prisma.loot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lootWithIdOnly = await prisma.loot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LootFindManyArgs>(args?: SelectSubset<T, LootFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Loot.
     * @param {LootCreateArgs} args - Arguments to create a Loot.
     * @example
     * // Create one Loot
     * const Loot = await prisma.loot.create({
     *   data: {
     *     // ... data to create a Loot
     *   }
     * })
     * 
     */
    create<T extends LootCreateArgs>(args: SelectSubset<T, LootCreateArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Loots.
     * @param {LootCreateManyArgs} args - Arguments to create many Loots.
     * @example
     * // Create many Loots
     * const loot = await prisma.loot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LootCreateManyArgs>(args?: SelectSubset<T, LootCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Loots and returns the data saved in the database.
     * @param {LootCreateManyAndReturnArgs} args - Arguments to create many Loots.
     * @example
     * // Create many Loots
     * const loot = await prisma.loot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Loots and only return the `id`
     * const lootWithIdOnly = await prisma.loot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LootCreateManyAndReturnArgs>(args?: SelectSubset<T, LootCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Loot.
     * @param {LootDeleteArgs} args - Arguments to delete one Loot.
     * @example
     * // Delete one Loot
     * const Loot = await prisma.loot.delete({
     *   where: {
     *     // ... filter to delete one Loot
     *   }
     * })
     * 
     */
    delete<T extends LootDeleteArgs>(args: SelectSubset<T, LootDeleteArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Loot.
     * @param {LootUpdateArgs} args - Arguments to update one Loot.
     * @example
     * // Update one Loot
     * const loot = await prisma.loot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LootUpdateArgs>(args: SelectSubset<T, LootUpdateArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Loots.
     * @param {LootDeleteManyArgs} args - Arguments to filter Loots to delete.
     * @example
     * // Delete a few Loots
     * const { count } = await prisma.loot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LootDeleteManyArgs>(args?: SelectSubset<T, LootDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loots
     * const loot = await prisma.loot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LootUpdateManyArgs>(args: SelectSubset<T, LootUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loots and returns the data updated in the database.
     * @param {LootUpdateManyAndReturnArgs} args - Arguments to update many Loots.
     * @example
     * // Update many Loots
     * const loot = await prisma.loot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Loots and only return the `id`
     * const lootWithIdOnly = await prisma.loot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LootUpdateManyAndReturnArgs>(args: SelectSubset<T, LootUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Loot.
     * @param {LootUpsertArgs} args - Arguments to update or create a Loot.
     * @example
     * // Update or create a Loot
     * const loot = await prisma.loot.upsert({
     *   create: {
     *     // ... data to create a Loot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loot we want to update
     *   }
     * })
     */
    upsert<T extends LootUpsertArgs>(args: SelectSubset<T, LootUpsertArgs<ExtArgs>>): Prisma__LootClient<$Result.GetResult<Prisma.$LootPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Loots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootCountArgs} args - Arguments to filter Loots to count.
     * @example
     * // Count the number of Loots
     * const count = await prisma.loot.count({
     *   where: {
     *     // ... the filter for the Loots we want to count
     *   }
     * })
    **/
    count<T extends LootCountArgs>(
      args?: Subset<T, LootCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LootCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LootAggregateArgs>(args: Subset<T, LootAggregateArgs>): Prisma.PrismaPromise<GetLootAggregateType<T>>

    /**
     * Group by Loot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LootGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LootGroupByArgs['orderBy'] }
        : { orderBy?: LootGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LootGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLootGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Loot model
   */
  readonly fields: LootFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Loot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LootClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemType<T extends ItemTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemTypeDefaultArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    soldToUser<T extends Loot$soldToUserArgs<ExtArgs> = {}>(args?: Subset<T, Loot$soldToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Loot model
   */
  interface LootFieldRefs {
    readonly id: FieldRef<"Loot", 'Int'>
    readonly status: FieldRef<"Loot", 'String'>
    readonly sold_at: FieldRef<"Loot", 'DateTime'>
    readonly sold_to: FieldRef<"Loot", 'String'>
    readonly comment: FieldRef<"Loot", 'String'>
    readonly created_at: FieldRef<"Loot", 'DateTime'>
    readonly source: FieldRef<"Loot", 'String'>
    readonly acquired_at: FieldRef<"Loot", 'DateTime'>
    readonly itemTypeId: FieldRef<"Loot", 'Int'>
    readonly sold_to_user_id: FieldRef<"Loot", 'Int'>
    readonly quantity: FieldRef<"Loot", 'Int'>
    readonly price: FieldRef<"Loot", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Loot findUnique
   */
  export type LootFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * Filter, which Loot to fetch.
     */
    where: LootWhereUniqueInput
  }

  /**
   * Loot findUniqueOrThrow
   */
  export type LootFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * Filter, which Loot to fetch.
     */
    where: LootWhereUniqueInput
  }

  /**
   * Loot findFirst
   */
  export type LootFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * Filter, which Loot to fetch.
     */
    where?: LootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loots to fetch.
     */
    orderBy?: LootOrderByWithRelationInput | LootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loots.
     */
    cursor?: LootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loots.
     */
    distinct?: LootScalarFieldEnum | LootScalarFieldEnum[]
  }

  /**
   * Loot findFirstOrThrow
   */
  export type LootFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * Filter, which Loot to fetch.
     */
    where?: LootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loots to fetch.
     */
    orderBy?: LootOrderByWithRelationInput | LootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Loots.
     */
    cursor?: LootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Loots.
     */
    distinct?: LootScalarFieldEnum | LootScalarFieldEnum[]
  }

  /**
   * Loot findMany
   */
  export type LootFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * Filter, which Loots to fetch.
     */
    where?: LootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Loots to fetch.
     */
    orderBy?: LootOrderByWithRelationInput | LootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Loots.
     */
    cursor?: LootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Loots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Loots.
     */
    skip?: number
    distinct?: LootScalarFieldEnum | LootScalarFieldEnum[]
  }

  /**
   * Loot create
   */
  export type LootCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * The data needed to create a Loot.
     */
    data: XOR<LootCreateInput, LootUncheckedCreateInput>
  }

  /**
   * Loot createMany
   */
  export type LootCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Loots.
     */
    data: LootCreateManyInput | LootCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Loot createManyAndReturn
   */
  export type LootCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * The data used to create many Loots.
     */
    data: LootCreateManyInput | LootCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Loot update
   */
  export type LootUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * The data needed to update a Loot.
     */
    data: XOR<LootUpdateInput, LootUncheckedUpdateInput>
    /**
     * Choose, which Loot to update.
     */
    where: LootWhereUniqueInput
  }

  /**
   * Loot updateMany
   */
  export type LootUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Loots.
     */
    data: XOR<LootUpdateManyMutationInput, LootUncheckedUpdateManyInput>
    /**
     * Filter which Loots to update
     */
    where?: LootWhereInput
    /**
     * Limit how many Loots to update.
     */
    limit?: number
  }

  /**
   * Loot updateManyAndReturn
   */
  export type LootUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * The data used to update Loots.
     */
    data: XOR<LootUpdateManyMutationInput, LootUncheckedUpdateManyInput>
    /**
     * Filter which Loots to update
     */
    where?: LootWhereInput
    /**
     * Limit how many Loots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Loot upsert
   */
  export type LootUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * The filter to search for the Loot to update in case it exists.
     */
    where: LootWhereUniqueInput
    /**
     * In case the Loot found by the `where` argument doesn't exist, create a new Loot with this data.
     */
    create: XOR<LootCreateInput, LootUncheckedCreateInput>
    /**
     * In case the Loot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LootUpdateInput, LootUncheckedUpdateInput>
  }

  /**
   * Loot delete
   */
  export type LootDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
    /**
     * Filter which Loot to delete.
     */
    where: LootWhereUniqueInput
  }

  /**
   * Loot deleteMany
   */
  export type LootDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loots to delete
     */
    where?: LootWhereInput
    /**
     * Limit how many Loots to delete.
     */
    limit?: number
  }

  /**
   * Loot.soldToUser
   */
  export type Loot$soldToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Loot without action
   */
  export type LootDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loot
     */
    select?: LootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Loot
     */
    omit?: LootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootInclude<ExtArgs> | null
  }


  /**
   * Model TasksUser
   */

  export type AggregateTasksUser = {
    _count: TasksUserCountAggregateOutputType | null
    _avg: TasksUserAvgAggregateOutputType | null
    _sum: TasksUserSumAggregateOutputType | null
    _min: TasksUserMinAggregateOutputType | null
    _max: TasksUserMaxAggregateOutputType | null
  }

  export type TasksUserAvgAggregateOutputType = {
    tasks_user_id: number | null
    user_id: number | null
  }

  export type TasksUserSumAggregateOutputType = {
    tasks_user_id: number | null
    user_id: number | null
  }

  export type TasksUserMinAggregateOutputType = {
    tasks_user_id: number | null
    user_id: number | null
  }

  export type TasksUserMaxAggregateOutputType = {
    tasks_user_id: number | null
    user_id: number | null
  }

  export type TasksUserCountAggregateOutputType = {
    tasks_user_id: number
    user_id: number
    _all: number
  }


  export type TasksUserAvgAggregateInputType = {
    tasks_user_id?: true
    user_id?: true
  }

  export type TasksUserSumAggregateInputType = {
    tasks_user_id?: true
    user_id?: true
  }

  export type TasksUserMinAggregateInputType = {
    tasks_user_id?: true
    user_id?: true
  }

  export type TasksUserMaxAggregateInputType = {
    tasks_user_id?: true
    user_id?: true
  }

  export type TasksUserCountAggregateInputType = {
    tasks_user_id?: true
    user_id?: true
    _all?: true
  }

  export type TasksUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TasksUser to aggregate.
     */
    where?: TasksUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TasksUsers to fetch.
     */
    orderBy?: TasksUserOrderByWithRelationInput | TasksUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TasksUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TasksUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TasksUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TasksUsers
    **/
    _count?: true | TasksUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TasksUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TasksUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TasksUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TasksUserMaxAggregateInputType
  }

  export type GetTasksUserAggregateType<T extends TasksUserAggregateArgs> = {
        [P in keyof T & keyof AggregateTasksUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTasksUser[P]>
      : GetScalarType<T[P], AggregateTasksUser[P]>
  }




  export type TasksUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TasksUserWhereInput
    orderBy?: TasksUserOrderByWithAggregationInput | TasksUserOrderByWithAggregationInput[]
    by: TasksUserScalarFieldEnum[] | TasksUserScalarFieldEnum
    having?: TasksUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TasksUserCountAggregateInputType | true
    _avg?: TasksUserAvgAggregateInputType
    _sum?: TasksUserSumAggregateInputType
    _min?: TasksUserMinAggregateInputType
    _max?: TasksUserMaxAggregateInputType
  }

  export type TasksUserGroupByOutputType = {
    tasks_user_id: number
    user_id: number
    _count: TasksUserCountAggregateOutputType | null
    _avg: TasksUserAvgAggregateOutputType | null
    _sum: TasksUserSumAggregateOutputType | null
    _min: TasksUserMinAggregateOutputType | null
    _max: TasksUserMaxAggregateOutputType | null
  }

  type GetTasksUserGroupByPayload<T extends TasksUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TasksUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TasksUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TasksUserGroupByOutputType[P]>
            : GetScalarType<T[P], TasksUserGroupByOutputType[P]>
        }
      >
    >


  export type TasksUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tasks_user_id?: boolean
    user_id?: boolean
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasksUser"]>

  export type TasksUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tasks_user_id?: boolean
    user_id?: boolean
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasksUser"]>

  export type TasksUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tasks_user_id?: boolean
    user_id?: boolean
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tasksUser"]>

  export type TasksUserSelectScalar = {
    tasks_user_id?: boolean
    user_id?: boolean
  }

  export type TasksUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tasks_user_id" | "user_id", ExtArgs["result"]["tasksUser"]>
  export type TasksUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TasksUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TasksUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TasksDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TasksUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TasksUser"
    objects: {
      task: Prisma.$TasksPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tasks_user_id: number
      user_id: number
    }, ExtArgs["result"]["tasksUser"]>
    composites: {}
  }

  type TasksUserGetPayload<S extends boolean | null | undefined | TasksUserDefaultArgs> = $Result.GetResult<Prisma.$TasksUserPayload, S>

  type TasksUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TasksUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TasksUserCountAggregateInputType | true
    }

  export interface TasksUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TasksUser'], meta: { name: 'TasksUser' } }
    /**
     * Find zero or one TasksUser that matches the filter.
     * @param {TasksUserFindUniqueArgs} args - Arguments to find a TasksUser
     * @example
     * // Get one TasksUser
     * const tasksUser = await prisma.tasksUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TasksUserFindUniqueArgs>(args: SelectSubset<T, TasksUserFindUniqueArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TasksUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TasksUserFindUniqueOrThrowArgs} args - Arguments to find a TasksUser
     * @example
     * // Get one TasksUser
     * const tasksUser = await prisma.tasksUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TasksUserFindUniqueOrThrowArgs>(args: SelectSubset<T, TasksUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TasksUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserFindFirstArgs} args - Arguments to find a TasksUser
     * @example
     * // Get one TasksUser
     * const tasksUser = await prisma.tasksUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TasksUserFindFirstArgs>(args?: SelectSubset<T, TasksUserFindFirstArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TasksUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserFindFirstOrThrowArgs} args - Arguments to find a TasksUser
     * @example
     * // Get one TasksUser
     * const tasksUser = await prisma.tasksUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TasksUserFindFirstOrThrowArgs>(args?: SelectSubset<T, TasksUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TasksUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TasksUsers
     * const tasksUsers = await prisma.tasksUser.findMany()
     * 
     * // Get first 10 TasksUsers
     * const tasksUsers = await prisma.tasksUser.findMany({ take: 10 })
     * 
     * // Only select the `tasks_user_id`
     * const tasksUserWithTasks_user_idOnly = await prisma.tasksUser.findMany({ select: { tasks_user_id: true } })
     * 
     */
    findMany<T extends TasksUserFindManyArgs>(args?: SelectSubset<T, TasksUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TasksUser.
     * @param {TasksUserCreateArgs} args - Arguments to create a TasksUser.
     * @example
     * // Create one TasksUser
     * const TasksUser = await prisma.tasksUser.create({
     *   data: {
     *     // ... data to create a TasksUser
     *   }
     * })
     * 
     */
    create<T extends TasksUserCreateArgs>(args: SelectSubset<T, TasksUserCreateArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TasksUsers.
     * @param {TasksUserCreateManyArgs} args - Arguments to create many TasksUsers.
     * @example
     * // Create many TasksUsers
     * const tasksUser = await prisma.tasksUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TasksUserCreateManyArgs>(args?: SelectSubset<T, TasksUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TasksUsers and returns the data saved in the database.
     * @param {TasksUserCreateManyAndReturnArgs} args - Arguments to create many TasksUsers.
     * @example
     * // Create many TasksUsers
     * const tasksUser = await prisma.tasksUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TasksUsers and only return the `tasks_user_id`
     * const tasksUserWithTasks_user_idOnly = await prisma.tasksUser.createManyAndReturn({
     *   select: { tasks_user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TasksUserCreateManyAndReturnArgs>(args?: SelectSubset<T, TasksUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TasksUser.
     * @param {TasksUserDeleteArgs} args - Arguments to delete one TasksUser.
     * @example
     * // Delete one TasksUser
     * const TasksUser = await prisma.tasksUser.delete({
     *   where: {
     *     // ... filter to delete one TasksUser
     *   }
     * })
     * 
     */
    delete<T extends TasksUserDeleteArgs>(args: SelectSubset<T, TasksUserDeleteArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TasksUser.
     * @param {TasksUserUpdateArgs} args - Arguments to update one TasksUser.
     * @example
     * // Update one TasksUser
     * const tasksUser = await prisma.tasksUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TasksUserUpdateArgs>(args: SelectSubset<T, TasksUserUpdateArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TasksUsers.
     * @param {TasksUserDeleteManyArgs} args - Arguments to filter TasksUsers to delete.
     * @example
     * // Delete a few TasksUsers
     * const { count } = await prisma.tasksUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TasksUserDeleteManyArgs>(args?: SelectSubset<T, TasksUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TasksUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TasksUsers
     * const tasksUser = await prisma.tasksUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TasksUserUpdateManyArgs>(args: SelectSubset<T, TasksUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TasksUsers and returns the data updated in the database.
     * @param {TasksUserUpdateManyAndReturnArgs} args - Arguments to update many TasksUsers.
     * @example
     * // Update many TasksUsers
     * const tasksUser = await prisma.tasksUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TasksUsers and only return the `tasks_user_id`
     * const tasksUserWithTasks_user_idOnly = await prisma.tasksUser.updateManyAndReturn({
     *   select: { tasks_user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TasksUserUpdateManyAndReturnArgs>(args: SelectSubset<T, TasksUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TasksUser.
     * @param {TasksUserUpsertArgs} args - Arguments to update or create a TasksUser.
     * @example
     * // Update or create a TasksUser
     * const tasksUser = await prisma.tasksUser.upsert({
     *   create: {
     *     // ... data to create a TasksUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TasksUser we want to update
     *   }
     * })
     */
    upsert<T extends TasksUserUpsertArgs>(args: SelectSubset<T, TasksUserUpsertArgs<ExtArgs>>): Prisma__TasksUserClient<$Result.GetResult<Prisma.$TasksUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TasksUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserCountArgs} args - Arguments to filter TasksUsers to count.
     * @example
     * // Count the number of TasksUsers
     * const count = await prisma.tasksUser.count({
     *   where: {
     *     // ... the filter for the TasksUsers we want to count
     *   }
     * })
    **/
    count<T extends TasksUserCountArgs>(
      args?: Subset<T, TasksUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TasksUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TasksUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TasksUserAggregateArgs>(args: Subset<T, TasksUserAggregateArgs>): Prisma.PrismaPromise<GetTasksUserAggregateType<T>>

    /**
     * Group by TasksUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TasksUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TasksUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TasksUserGroupByArgs['orderBy'] }
        : { orderBy?: TasksUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TasksUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTasksUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TasksUser model
   */
  readonly fields: TasksUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TasksUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TasksUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TasksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TasksDefaultArgs<ExtArgs>>): Prisma__TasksClient<$Result.GetResult<Prisma.$TasksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TasksUser model
   */
  interface TasksUserFieldRefs {
    readonly tasks_user_id: FieldRef<"TasksUser", 'Int'>
    readonly user_id: FieldRef<"TasksUser", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TasksUser findUnique
   */
  export type TasksUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * Filter, which TasksUser to fetch.
     */
    where: TasksUserWhereUniqueInput
  }

  /**
   * TasksUser findUniqueOrThrow
   */
  export type TasksUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * Filter, which TasksUser to fetch.
     */
    where: TasksUserWhereUniqueInput
  }

  /**
   * TasksUser findFirst
   */
  export type TasksUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * Filter, which TasksUser to fetch.
     */
    where?: TasksUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TasksUsers to fetch.
     */
    orderBy?: TasksUserOrderByWithRelationInput | TasksUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TasksUsers.
     */
    cursor?: TasksUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TasksUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TasksUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TasksUsers.
     */
    distinct?: TasksUserScalarFieldEnum | TasksUserScalarFieldEnum[]
  }

  /**
   * TasksUser findFirstOrThrow
   */
  export type TasksUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * Filter, which TasksUser to fetch.
     */
    where?: TasksUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TasksUsers to fetch.
     */
    orderBy?: TasksUserOrderByWithRelationInput | TasksUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TasksUsers.
     */
    cursor?: TasksUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TasksUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TasksUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TasksUsers.
     */
    distinct?: TasksUserScalarFieldEnum | TasksUserScalarFieldEnum[]
  }

  /**
   * TasksUser findMany
   */
  export type TasksUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * Filter, which TasksUsers to fetch.
     */
    where?: TasksUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TasksUsers to fetch.
     */
    orderBy?: TasksUserOrderByWithRelationInput | TasksUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TasksUsers.
     */
    cursor?: TasksUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TasksUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TasksUsers.
     */
    skip?: number
    distinct?: TasksUserScalarFieldEnum | TasksUserScalarFieldEnum[]
  }

  /**
   * TasksUser create
   */
  export type TasksUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * The data needed to create a TasksUser.
     */
    data: XOR<TasksUserCreateInput, TasksUserUncheckedCreateInput>
  }

  /**
   * TasksUser createMany
   */
  export type TasksUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TasksUsers.
     */
    data: TasksUserCreateManyInput | TasksUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TasksUser createManyAndReturn
   */
  export type TasksUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * The data used to create many TasksUsers.
     */
    data: TasksUserCreateManyInput | TasksUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TasksUser update
   */
  export type TasksUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * The data needed to update a TasksUser.
     */
    data: XOR<TasksUserUpdateInput, TasksUserUncheckedUpdateInput>
    /**
     * Choose, which TasksUser to update.
     */
    where: TasksUserWhereUniqueInput
  }

  /**
   * TasksUser updateMany
   */
  export type TasksUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TasksUsers.
     */
    data: XOR<TasksUserUpdateManyMutationInput, TasksUserUncheckedUpdateManyInput>
    /**
     * Filter which TasksUsers to update
     */
    where?: TasksUserWhereInput
    /**
     * Limit how many TasksUsers to update.
     */
    limit?: number
  }

  /**
   * TasksUser updateManyAndReturn
   */
  export type TasksUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * The data used to update TasksUsers.
     */
    data: XOR<TasksUserUpdateManyMutationInput, TasksUserUncheckedUpdateManyInput>
    /**
     * Filter which TasksUsers to update
     */
    where?: TasksUserWhereInput
    /**
     * Limit how many TasksUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TasksUser upsert
   */
  export type TasksUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * The filter to search for the TasksUser to update in case it exists.
     */
    where: TasksUserWhereUniqueInput
    /**
     * In case the TasksUser found by the `where` argument doesn't exist, create a new TasksUser with this data.
     */
    create: XOR<TasksUserCreateInput, TasksUserUncheckedCreateInput>
    /**
     * In case the TasksUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TasksUserUpdateInput, TasksUserUncheckedUpdateInput>
  }

  /**
   * TasksUser delete
   */
  export type TasksUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
    /**
     * Filter which TasksUser to delete.
     */
    where: TasksUserWhereUniqueInput
  }

  /**
   * TasksUser deleteMany
   */
  export type TasksUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TasksUsers to delete
     */
    where?: TasksUserWhereInput
    /**
     * Limit how many TasksUsers to delete.
     */
    limit?: number
  }

  /**
   * TasksUser without action
   */
  export type TasksUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TasksUser
     */
    select?: TasksUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TasksUser
     */
    omit?: TasksUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TasksUserInclude<ExtArgs> | null
  }


  /**
   * Model LootQueue
   */

  export type AggregateLootQueue = {
    _count: LootQueueCountAggregateOutputType | null
    _avg: LootQueueAvgAggregateOutputType | null
    _sum: LootQueueSumAggregateOutputType | null
    _min: LootQueueMinAggregateOutputType | null
    _max: LootQueueMaxAggregateOutputType | null
  }

  export type LootQueueAvgAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    userId: number | null
    remaining: number | null
    required: number | null
    delivered: number | null
  }

  export type LootQueueSumAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    userId: number | null
    remaining: number | null
    required: number | null
    delivered: number | null
  }

  export type LootQueueMinAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    userId: number | null
    created_at: Date | null
    status: string | null
    synth_target: string | null
    remaining: number | null
    required: number | null
    delivered: number | null
  }

  export type LootQueueMaxAggregateOutputType = {
    id: number | null
    itemTypeId: number | null
    userId: number | null
    created_at: Date | null
    status: string | null
    synth_target: string | null
    remaining: number | null
    required: number | null
    delivered: number | null
  }

  export type LootQueueCountAggregateOutputType = {
    id: number
    itemTypeId: number
    userId: number
    created_at: number
    status: number
    synth_target: number
    remaining: number
    required: number
    delivered: number
    _all: number
  }


  export type LootQueueAvgAggregateInputType = {
    id?: true
    itemTypeId?: true
    userId?: true
    remaining?: true
    required?: true
    delivered?: true
  }

  export type LootQueueSumAggregateInputType = {
    id?: true
    itemTypeId?: true
    userId?: true
    remaining?: true
    required?: true
    delivered?: true
  }

  export type LootQueueMinAggregateInputType = {
    id?: true
    itemTypeId?: true
    userId?: true
    created_at?: true
    status?: true
    synth_target?: true
    remaining?: true
    required?: true
    delivered?: true
  }

  export type LootQueueMaxAggregateInputType = {
    id?: true
    itemTypeId?: true
    userId?: true
    created_at?: true
    status?: true
    synth_target?: true
    remaining?: true
    required?: true
    delivered?: true
  }

  export type LootQueueCountAggregateInputType = {
    id?: true
    itemTypeId?: true
    userId?: true
    created_at?: true
    status?: true
    synth_target?: true
    remaining?: true
    required?: true
    delivered?: true
    _all?: true
  }

  export type LootQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LootQueue to aggregate.
     */
    where?: LootQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LootQueues to fetch.
     */
    orderBy?: LootQueueOrderByWithRelationInput | LootQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LootQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LootQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LootQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LootQueues
    **/
    _count?: true | LootQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LootQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LootQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LootQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LootQueueMaxAggregateInputType
  }

  export type GetLootQueueAggregateType<T extends LootQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateLootQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLootQueue[P]>
      : GetScalarType<T[P], AggregateLootQueue[P]>
  }




  export type LootQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LootQueueWhereInput
    orderBy?: LootQueueOrderByWithAggregationInput | LootQueueOrderByWithAggregationInput[]
    by: LootQueueScalarFieldEnum[] | LootQueueScalarFieldEnum
    having?: LootQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LootQueueCountAggregateInputType | true
    _avg?: LootQueueAvgAggregateInputType
    _sum?: LootQueueSumAggregateInputType
    _min?: LootQueueMinAggregateInputType
    _max?: LootQueueMaxAggregateInputType
  }

  export type LootQueueGroupByOutputType = {
    id: number
    itemTypeId: number
    userId: number
    created_at: Date | null
    status: string | null
    synth_target: string | null
    remaining: number | null
    required: number
    delivered: number
    _count: LootQueueCountAggregateOutputType | null
    _avg: LootQueueAvgAggregateOutputType | null
    _sum: LootQueueSumAggregateOutputType | null
    _min: LootQueueMinAggregateOutputType | null
    _max: LootQueueMaxAggregateOutputType | null
  }

  type GetLootQueueGroupByPayload<T extends LootQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LootQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LootQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LootQueueGroupByOutputType[P]>
            : GetScalarType<T[P], LootQueueGroupByOutputType[P]>
        }
      >
    >


  export type LootQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemTypeId?: boolean
    userId?: boolean
    created_at?: boolean
    status?: boolean
    synth_target?: boolean
    remaining?: boolean
    required?: boolean
    delivered?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lootQueue"]>

  export type LootQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemTypeId?: boolean
    userId?: boolean
    created_at?: boolean
    status?: boolean
    synth_target?: boolean
    remaining?: boolean
    required?: boolean
    delivered?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lootQueue"]>

  export type LootQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemTypeId?: boolean
    userId?: boolean
    created_at?: boolean
    status?: boolean
    synth_target?: boolean
    remaining?: boolean
    required?: boolean
    delivered?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lootQueue"]>

  export type LootQueueSelectScalar = {
    id?: boolean
    itemTypeId?: boolean
    userId?: boolean
    created_at?: boolean
    status?: boolean
    synth_target?: boolean
    remaining?: boolean
    required?: boolean
    delivered?: boolean
  }

  export type LootQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemTypeId" | "userId" | "created_at" | "status" | "synth_target" | "remaining" | "required" | "delivered", ExtArgs["result"]["lootQueue"]>
  export type LootQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LootQueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LootQueueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LootQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LootQueue"
    objects: {
      itemType: Prisma.$ItemTypePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemTypeId: number
      userId: number
      created_at: Date | null
      status: string | null
      synth_target: string | null
      remaining: number | null
      required: number
      delivered: number
    }, ExtArgs["result"]["lootQueue"]>
    composites: {}
  }

  type LootQueueGetPayload<S extends boolean | null | undefined | LootQueueDefaultArgs> = $Result.GetResult<Prisma.$LootQueuePayload, S>

  type LootQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LootQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LootQueueCountAggregateInputType | true
    }

  export interface LootQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LootQueue'], meta: { name: 'LootQueue' } }
    /**
     * Find zero or one LootQueue that matches the filter.
     * @param {LootQueueFindUniqueArgs} args - Arguments to find a LootQueue
     * @example
     * // Get one LootQueue
     * const lootQueue = await prisma.lootQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LootQueueFindUniqueArgs>(args: SelectSubset<T, LootQueueFindUniqueArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LootQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LootQueueFindUniqueOrThrowArgs} args - Arguments to find a LootQueue
     * @example
     * // Get one LootQueue
     * const lootQueue = await prisma.lootQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LootQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, LootQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LootQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueFindFirstArgs} args - Arguments to find a LootQueue
     * @example
     * // Get one LootQueue
     * const lootQueue = await prisma.lootQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LootQueueFindFirstArgs>(args?: SelectSubset<T, LootQueueFindFirstArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LootQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueFindFirstOrThrowArgs} args - Arguments to find a LootQueue
     * @example
     * // Get one LootQueue
     * const lootQueue = await prisma.lootQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LootQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, LootQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LootQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LootQueues
     * const lootQueues = await prisma.lootQueue.findMany()
     * 
     * // Get first 10 LootQueues
     * const lootQueues = await prisma.lootQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lootQueueWithIdOnly = await prisma.lootQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LootQueueFindManyArgs>(args?: SelectSubset<T, LootQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LootQueue.
     * @param {LootQueueCreateArgs} args - Arguments to create a LootQueue.
     * @example
     * // Create one LootQueue
     * const LootQueue = await prisma.lootQueue.create({
     *   data: {
     *     // ... data to create a LootQueue
     *   }
     * })
     * 
     */
    create<T extends LootQueueCreateArgs>(args: SelectSubset<T, LootQueueCreateArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LootQueues.
     * @param {LootQueueCreateManyArgs} args - Arguments to create many LootQueues.
     * @example
     * // Create many LootQueues
     * const lootQueue = await prisma.lootQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LootQueueCreateManyArgs>(args?: SelectSubset<T, LootQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LootQueues and returns the data saved in the database.
     * @param {LootQueueCreateManyAndReturnArgs} args - Arguments to create many LootQueues.
     * @example
     * // Create many LootQueues
     * const lootQueue = await prisma.lootQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LootQueues and only return the `id`
     * const lootQueueWithIdOnly = await prisma.lootQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LootQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, LootQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LootQueue.
     * @param {LootQueueDeleteArgs} args - Arguments to delete one LootQueue.
     * @example
     * // Delete one LootQueue
     * const LootQueue = await prisma.lootQueue.delete({
     *   where: {
     *     // ... filter to delete one LootQueue
     *   }
     * })
     * 
     */
    delete<T extends LootQueueDeleteArgs>(args: SelectSubset<T, LootQueueDeleteArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LootQueue.
     * @param {LootQueueUpdateArgs} args - Arguments to update one LootQueue.
     * @example
     * // Update one LootQueue
     * const lootQueue = await prisma.lootQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LootQueueUpdateArgs>(args: SelectSubset<T, LootQueueUpdateArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LootQueues.
     * @param {LootQueueDeleteManyArgs} args - Arguments to filter LootQueues to delete.
     * @example
     * // Delete a few LootQueues
     * const { count } = await prisma.lootQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LootQueueDeleteManyArgs>(args?: SelectSubset<T, LootQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LootQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LootQueues
     * const lootQueue = await prisma.lootQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LootQueueUpdateManyArgs>(args: SelectSubset<T, LootQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LootQueues and returns the data updated in the database.
     * @param {LootQueueUpdateManyAndReturnArgs} args - Arguments to update many LootQueues.
     * @example
     * // Update many LootQueues
     * const lootQueue = await prisma.lootQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LootQueues and only return the `id`
     * const lootQueueWithIdOnly = await prisma.lootQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LootQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, LootQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LootQueue.
     * @param {LootQueueUpsertArgs} args - Arguments to update or create a LootQueue.
     * @example
     * // Update or create a LootQueue
     * const lootQueue = await prisma.lootQueue.upsert({
     *   create: {
     *     // ... data to create a LootQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LootQueue we want to update
     *   }
     * })
     */
    upsert<T extends LootQueueUpsertArgs>(args: SelectSubset<T, LootQueueUpsertArgs<ExtArgs>>): Prisma__LootQueueClient<$Result.GetResult<Prisma.$LootQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LootQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueCountArgs} args - Arguments to filter LootQueues to count.
     * @example
     * // Count the number of LootQueues
     * const count = await prisma.lootQueue.count({
     *   where: {
     *     // ... the filter for the LootQueues we want to count
     *   }
     * })
    **/
    count<T extends LootQueueCountArgs>(
      args?: Subset<T, LootQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LootQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LootQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LootQueueAggregateArgs>(args: Subset<T, LootQueueAggregateArgs>): Prisma.PrismaPromise<GetLootQueueAggregateType<T>>

    /**
     * Group by LootQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LootQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LootQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LootQueueGroupByArgs['orderBy'] }
        : { orderBy?: LootQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LootQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLootQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LootQueue model
   */
  readonly fields: LootQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LootQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LootQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemType<T extends ItemTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemTypeDefaultArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LootQueue model
   */
  interface LootQueueFieldRefs {
    readonly id: FieldRef<"LootQueue", 'Int'>
    readonly itemTypeId: FieldRef<"LootQueue", 'Int'>
    readonly userId: FieldRef<"LootQueue", 'Int'>
    readonly created_at: FieldRef<"LootQueue", 'DateTime'>
    readonly status: FieldRef<"LootQueue", 'String'>
    readonly synth_target: FieldRef<"LootQueue", 'String'>
    readonly remaining: FieldRef<"LootQueue", 'Int'>
    readonly required: FieldRef<"LootQueue", 'Int'>
    readonly delivered: FieldRef<"LootQueue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LootQueue findUnique
   */
  export type LootQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * Filter, which LootQueue to fetch.
     */
    where: LootQueueWhereUniqueInput
  }

  /**
   * LootQueue findUniqueOrThrow
   */
  export type LootQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * Filter, which LootQueue to fetch.
     */
    where: LootQueueWhereUniqueInput
  }

  /**
   * LootQueue findFirst
   */
  export type LootQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * Filter, which LootQueue to fetch.
     */
    where?: LootQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LootQueues to fetch.
     */
    orderBy?: LootQueueOrderByWithRelationInput | LootQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LootQueues.
     */
    cursor?: LootQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LootQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LootQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LootQueues.
     */
    distinct?: LootQueueScalarFieldEnum | LootQueueScalarFieldEnum[]
  }

  /**
   * LootQueue findFirstOrThrow
   */
  export type LootQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * Filter, which LootQueue to fetch.
     */
    where?: LootQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LootQueues to fetch.
     */
    orderBy?: LootQueueOrderByWithRelationInput | LootQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LootQueues.
     */
    cursor?: LootQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LootQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LootQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LootQueues.
     */
    distinct?: LootQueueScalarFieldEnum | LootQueueScalarFieldEnum[]
  }

  /**
   * LootQueue findMany
   */
  export type LootQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * Filter, which LootQueues to fetch.
     */
    where?: LootQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LootQueues to fetch.
     */
    orderBy?: LootQueueOrderByWithRelationInput | LootQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LootQueues.
     */
    cursor?: LootQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LootQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LootQueues.
     */
    skip?: number
    distinct?: LootQueueScalarFieldEnum | LootQueueScalarFieldEnum[]
  }

  /**
   * LootQueue create
   */
  export type LootQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a LootQueue.
     */
    data: XOR<LootQueueCreateInput, LootQueueUncheckedCreateInput>
  }

  /**
   * LootQueue createMany
   */
  export type LootQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LootQueues.
     */
    data: LootQueueCreateManyInput | LootQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LootQueue createManyAndReturn
   */
  export type LootQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * The data used to create many LootQueues.
     */
    data: LootQueueCreateManyInput | LootQueueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LootQueue update
   */
  export type LootQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a LootQueue.
     */
    data: XOR<LootQueueUpdateInput, LootQueueUncheckedUpdateInput>
    /**
     * Choose, which LootQueue to update.
     */
    where: LootQueueWhereUniqueInput
  }

  /**
   * LootQueue updateMany
   */
  export type LootQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LootQueues.
     */
    data: XOR<LootQueueUpdateManyMutationInput, LootQueueUncheckedUpdateManyInput>
    /**
     * Filter which LootQueues to update
     */
    where?: LootQueueWhereInput
    /**
     * Limit how many LootQueues to update.
     */
    limit?: number
  }

  /**
   * LootQueue updateManyAndReturn
   */
  export type LootQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * The data used to update LootQueues.
     */
    data: XOR<LootQueueUpdateManyMutationInput, LootQueueUncheckedUpdateManyInput>
    /**
     * Filter which LootQueues to update
     */
    where?: LootQueueWhereInput
    /**
     * Limit how many LootQueues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LootQueue upsert
   */
  export type LootQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the LootQueue to update in case it exists.
     */
    where: LootQueueWhereUniqueInput
    /**
     * In case the LootQueue found by the `where` argument doesn't exist, create a new LootQueue with this data.
     */
    create: XOR<LootQueueCreateInput, LootQueueUncheckedCreateInput>
    /**
     * In case the LootQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LootQueueUpdateInput, LootQueueUncheckedUpdateInput>
  }

  /**
   * LootQueue delete
   */
  export type LootQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
    /**
     * Filter which LootQueue to delete.
     */
    where: LootQueueWhereUniqueInput
  }

  /**
   * LootQueue deleteMany
   */
  export type LootQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LootQueues to delete
     */
    where?: LootQueueWhereInput
    /**
     * Limit how many LootQueues to delete.
     */
    limit?: number
  }

  /**
   * LootQueue without action
   */
  export type LootQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LootQueue
     */
    select?: LootQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LootQueue
     */
    omit?: LootQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LootQueueInclude<ExtArgs> | null
  }


  /**
   * Model GivenAwayLoot
   */

  export type AggregateGivenAwayLoot = {
    _count: GivenAwayLootCountAggregateOutputType | null
    _avg: GivenAwayLootAvgAggregateOutputType | null
    _sum: GivenAwayLootSumAggregateOutputType | null
    _min: GivenAwayLootMinAggregateOutputType | null
    _max: GivenAwayLootMaxAggregateOutputType | null
  }

  export type GivenAwayLootAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type GivenAwayLootSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type GivenAwayLootMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    date: Date | null
    comment: string | null
    created_at: Date | null
    status: string | null
  }

  export type GivenAwayLootMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    date: Date | null
    comment: string | null
    created_at: Date | null
    status: string | null
  }

  export type GivenAwayLootCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    date: number
    comment: number
    created_at: number
    status: number
    _all: number
  }


  export type GivenAwayLootAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type GivenAwayLootSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type GivenAwayLootMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    date?: true
    comment?: true
    created_at?: true
    status?: true
  }

  export type GivenAwayLootMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    date?: true
    comment?: true
    created_at?: true
    status?: true
  }

  export type GivenAwayLootCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    date?: true
    comment?: true
    created_at?: true
    status?: true
    _all?: true
  }

  export type GivenAwayLootAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GivenAwayLoot to aggregate.
     */
    where?: GivenAwayLootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GivenAwayLoots to fetch.
     */
    orderBy?: GivenAwayLootOrderByWithRelationInput | GivenAwayLootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GivenAwayLootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GivenAwayLoots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GivenAwayLoots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GivenAwayLoots
    **/
    _count?: true | GivenAwayLootCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GivenAwayLootAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GivenAwayLootSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GivenAwayLootMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GivenAwayLootMaxAggregateInputType
  }

  export type GetGivenAwayLootAggregateType<T extends GivenAwayLootAggregateArgs> = {
        [P in keyof T & keyof AggregateGivenAwayLoot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGivenAwayLoot[P]>
      : GetScalarType<T[P], AggregateGivenAwayLoot[P]>
  }




  export type GivenAwayLootGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GivenAwayLootWhereInput
    orderBy?: GivenAwayLootOrderByWithAggregationInput | GivenAwayLootOrderByWithAggregationInput[]
    by: GivenAwayLootScalarFieldEnum[] | GivenAwayLootScalarFieldEnum
    having?: GivenAwayLootScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GivenAwayLootCountAggregateInputType | true
    _avg?: GivenAwayLootAvgAggregateInputType
    _sum?: GivenAwayLootSumAggregateInputType
    _min?: GivenAwayLootMinAggregateInputType
    _max?: GivenAwayLootMaxAggregateInputType
  }

  export type GivenAwayLootGroupByOutputType = {
    id: number
    user_id: number
    name: string
    date: Date
    comment: string | null
    created_at: Date | null
    status: string | null
    _count: GivenAwayLootCountAggregateOutputType | null
    _avg: GivenAwayLootAvgAggregateOutputType | null
    _sum: GivenAwayLootSumAggregateOutputType | null
    _min: GivenAwayLootMinAggregateOutputType | null
    _max: GivenAwayLootMaxAggregateOutputType | null
  }

  type GetGivenAwayLootGroupByPayload<T extends GivenAwayLootGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GivenAwayLootGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GivenAwayLootGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GivenAwayLootGroupByOutputType[P]>
            : GetScalarType<T[P], GivenAwayLootGroupByOutputType[P]>
        }
      >
    >


  export type GivenAwayLootSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    date?: boolean
    comment?: boolean
    created_at?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["givenAwayLoot"]>

  export type GivenAwayLootSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    date?: boolean
    comment?: boolean
    created_at?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["givenAwayLoot"]>

  export type GivenAwayLootSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    date?: boolean
    comment?: boolean
    created_at?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["givenAwayLoot"]>

  export type GivenAwayLootSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    date?: boolean
    comment?: boolean
    created_at?: boolean
    status?: boolean
  }

  export type GivenAwayLootOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "name" | "date" | "comment" | "created_at" | "status", ExtArgs["result"]["givenAwayLoot"]>
  export type GivenAwayLootInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GivenAwayLootIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GivenAwayLootIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GivenAwayLootPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GivenAwayLoot"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      name: string
      date: Date
      comment: string | null
      created_at: Date | null
      status: string | null
    }, ExtArgs["result"]["givenAwayLoot"]>
    composites: {}
  }

  type GivenAwayLootGetPayload<S extends boolean | null | undefined | GivenAwayLootDefaultArgs> = $Result.GetResult<Prisma.$GivenAwayLootPayload, S>

  type GivenAwayLootCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GivenAwayLootFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GivenAwayLootCountAggregateInputType | true
    }

  export interface GivenAwayLootDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GivenAwayLoot'], meta: { name: 'GivenAwayLoot' } }
    /**
     * Find zero or one GivenAwayLoot that matches the filter.
     * @param {GivenAwayLootFindUniqueArgs} args - Arguments to find a GivenAwayLoot
     * @example
     * // Get one GivenAwayLoot
     * const givenAwayLoot = await prisma.givenAwayLoot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GivenAwayLootFindUniqueArgs>(args: SelectSubset<T, GivenAwayLootFindUniqueArgs<ExtArgs>>): Prisma__GivenAwayLootClient<$Result.GetResult<Prisma.$GivenAwayLootPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GivenAwayLoot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GivenAwayLootFindUniqueOrThrowArgs} args - Arguments to find a GivenAwayLoot
     * @example
     * // Get one GivenAwayLoot
     * const givenAwayLoot = await prisma.givenAwayLoot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GivenAwayLootFindUniqueOrThrowArgs>(args: SelectSubset<T, GivenAwayLootFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GivenAwayLootClient<$Result.GetResult<Prisma.$GivenAwayLootPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GivenAwayLoot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenAwayLootFindFirstArgs} args - Arguments to find a GivenAwayLoot
     * @example
     * // Get one GivenAwayLoot
     * const givenAwayLoot = await prisma.givenAwayLoot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GivenAwayLootFindFirstArgs>(args?: SelectSubset<T, GivenAwayLootFindFirstArgs<ExtArgs>>): Prisma__GivenAwayLootClient<$Result.GetResult<Prisma.$GivenAwayLootPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GivenAwayLoot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenAwayLootFindFirstOrThrowArgs} args - Arguments to find a GivenAwayLoot
     * @example
     * // Get one GivenAwayLoot
     * const givenAwayLoot = await prisma.givenAwayLoot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GivenAwayLootFindFirstOrThrowArgs>(args?: SelectSubset<T, GivenAwayLootFindFirstOrThrowArgs<ExtArgs>>): Prisma__GivenAwayLootClient<$Result.GetResult<Prisma.$GivenAwayLootPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GivenAwayLoots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenAwayLootFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GivenAwayLoots
     * const givenAwayLoots = await prisma.givenAwayLoot.findMany()
     * 
     * // Get first 10 GivenAwayLoots
     * const givenAwayLoots = await prisma.givenAwayLoot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const givenAwayLootWithIdOnly = await prisma.givenAwayLoot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GivenAwayLootFindManyArgs>(args?: SelectSubset<T, GivenAwayLootFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GivenAwayLootPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GivenAwayLoot.
     * @param {GivenAwayLootCreateArgs} args - Arguments to create a GivenAwayLoot.
     * @example
     * // Create one GivenAwayLoot
     * const GivenAwayLoot = await prisma.givenAwayLoot.create({
     *   data: {
     *     // ... data to create a GivenAwayLoot
     *   }
     * })
     * 
     */
    create<T extends GivenAwayLootCreateArgs>(args: SelectSubset<T, GivenAwayLootCreateArgs<ExtArgs>>): Prisma__GivenAwayLootClient<$Result.GetResult<Prisma.$GivenAwayLootPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GivenAwayLoots.
     * @param {GivenAwayLootCreateManyArgs} args - Arguments to create many GivenAwayLoots.
     * @example
     * // Create many GivenAwayLoots
     * const givenAwayLoot = await prisma.givenAwayLoot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GivenAwayLootCreateManyArgs>(args?: SelectSubset<T, GivenAwayLootCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GivenAwayLoots and returns the data saved in the database.
     * @param {GivenAwayLootCreateManyAndReturnArgs} args - Arguments to create many GivenAwayLoots.
     * @example
     * // Create many GivenAwayLoots
     * const givenAwayLoot = await prisma.givenAwayLoot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GivenAwayLoots and only return the `id`
     * const givenAwayLootWithIdOnly = await prisma.givenAwayLoot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GivenAwayLootCreateManyAndReturnArgs>(args?: SelectSubset<T, GivenAwayLootCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GivenAwayLootPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GivenAwayLoot.
     * @param {GivenAwayLootDeleteArgs} args - Arguments to delete one GivenAwayLoot.
     * @example
     * // Delete one GivenAwayLoot
     * const GivenAwayLoot = await prisma.givenAwayLoot.delete({
     *   where: {
     *     // ... filter to delete one GivenAwayLoot
     *   }
     * })
     * 
     */
    delete<T extends GivenAwayLootDeleteArgs>(args: SelectSubset<T, GivenAwayLootDeleteArgs<ExtArgs>>): Prisma__GivenAwayLootClient<$Result.GetResult<Prisma.$GivenAwayLootPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GivenAwayLoot.
     * @param {GivenAwayLootUpdateArgs} args - Arguments to update one GivenAwayLoot.
     * @example
     * // Update one GivenAwayLoot
     * const givenAwayLoot = await prisma.givenAwayLoot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GivenAwayLootUpdateArgs>(args: SelectSubset<T, GivenAwayLootUpdateArgs<ExtArgs>>): Prisma__GivenAwayLootClient<$Result.GetResult<Prisma.$GivenAwayLootPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GivenAwayLoots.
     * @param {GivenAwayLootDeleteManyArgs} args - Arguments to filter GivenAwayLoots to delete.
     * @example
     * // Delete a few GivenAwayLoots
     * const { count } = await prisma.givenAwayLoot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GivenAwayLootDeleteManyArgs>(args?: SelectSubset<T, GivenAwayLootDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GivenAwayLoots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenAwayLootUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GivenAwayLoots
     * const givenAwayLoot = await prisma.givenAwayLoot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GivenAwayLootUpdateManyArgs>(args: SelectSubset<T, GivenAwayLootUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GivenAwayLoots and returns the data updated in the database.
     * @param {GivenAwayLootUpdateManyAndReturnArgs} args - Arguments to update many GivenAwayLoots.
     * @example
     * // Update many GivenAwayLoots
     * const givenAwayLoot = await prisma.givenAwayLoot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GivenAwayLoots and only return the `id`
     * const givenAwayLootWithIdOnly = await prisma.givenAwayLoot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GivenAwayLootUpdateManyAndReturnArgs>(args: SelectSubset<T, GivenAwayLootUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GivenAwayLootPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GivenAwayLoot.
     * @param {GivenAwayLootUpsertArgs} args - Arguments to update or create a GivenAwayLoot.
     * @example
     * // Update or create a GivenAwayLoot
     * const givenAwayLoot = await prisma.givenAwayLoot.upsert({
     *   create: {
     *     // ... data to create a GivenAwayLoot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GivenAwayLoot we want to update
     *   }
     * })
     */
    upsert<T extends GivenAwayLootUpsertArgs>(args: SelectSubset<T, GivenAwayLootUpsertArgs<ExtArgs>>): Prisma__GivenAwayLootClient<$Result.GetResult<Prisma.$GivenAwayLootPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GivenAwayLoots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenAwayLootCountArgs} args - Arguments to filter GivenAwayLoots to count.
     * @example
     * // Count the number of GivenAwayLoots
     * const count = await prisma.givenAwayLoot.count({
     *   where: {
     *     // ... the filter for the GivenAwayLoots we want to count
     *   }
     * })
    **/
    count<T extends GivenAwayLootCountArgs>(
      args?: Subset<T, GivenAwayLootCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GivenAwayLootCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GivenAwayLoot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenAwayLootAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GivenAwayLootAggregateArgs>(args: Subset<T, GivenAwayLootAggregateArgs>): Prisma.PrismaPromise<GetGivenAwayLootAggregateType<T>>

    /**
     * Group by GivenAwayLoot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenAwayLootGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GivenAwayLootGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GivenAwayLootGroupByArgs['orderBy'] }
        : { orderBy?: GivenAwayLootGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GivenAwayLootGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGivenAwayLootGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GivenAwayLoot model
   */
  readonly fields: GivenAwayLootFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GivenAwayLoot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GivenAwayLootClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GivenAwayLoot model
   */
  interface GivenAwayLootFieldRefs {
    readonly id: FieldRef<"GivenAwayLoot", 'Int'>
    readonly user_id: FieldRef<"GivenAwayLoot", 'Int'>
    readonly name: FieldRef<"GivenAwayLoot", 'String'>
    readonly date: FieldRef<"GivenAwayLoot", 'DateTime'>
    readonly comment: FieldRef<"GivenAwayLoot", 'String'>
    readonly created_at: FieldRef<"GivenAwayLoot", 'DateTime'>
    readonly status: FieldRef<"GivenAwayLoot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GivenAwayLoot findUnique
   */
  export type GivenAwayLootFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootInclude<ExtArgs> | null
    /**
     * Filter, which GivenAwayLoot to fetch.
     */
    where: GivenAwayLootWhereUniqueInput
  }

  /**
   * GivenAwayLoot findUniqueOrThrow
   */
  export type GivenAwayLootFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootInclude<ExtArgs> | null
    /**
     * Filter, which GivenAwayLoot to fetch.
     */
    where: GivenAwayLootWhereUniqueInput
  }

  /**
   * GivenAwayLoot findFirst
   */
  export type GivenAwayLootFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootInclude<ExtArgs> | null
    /**
     * Filter, which GivenAwayLoot to fetch.
     */
    where?: GivenAwayLootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GivenAwayLoots to fetch.
     */
    orderBy?: GivenAwayLootOrderByWithRelationInput | GivenAwayLootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GivenAwayLoots.
     */
    cursor?: GivenAwayLootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GivenAwayLoots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GivenAwayLoots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GivenAwayLoots.
     */
    distinct?: GivenAwayLootScalarFieldEnum | GivenAwayLootScalarFieldEnum[]
  }

  /**
   * GivenAwayLoot findFirstOrThrow
   */
  export type GivenAwayLootFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootInclude<ExtArgs> | null
    /**
     * Filter, which GivenAwayLoot to fetch.
     */
    where?: GivenAwayLootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GivenAwayLoots to fetch.
     */
    orderBy?: GivenAwayLootOrderByWithRelationInput | GivenAwayLootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GivenAwayLoots.
     */
    cursor?: GivenAwayLootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GivenAwayLoots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GivenAwayLoots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GivenAwayLoots.
     */
    distinct?: GivenAwayLootScalarFieldEnum | GivenAwayLootScalarFieldEnum[]
  }

  /**
   * GivenAwayLoot findMany
   */
  export type GivenAwayLootFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootInclude<ExtArgs> | null
    /**
     * Filter, which GivenAwayLoots to fetch.
     */
    where?: GivenAwayLootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GivenAwayLoots to fetch.
     */
    orderBy?: GivenAwayLootOrderByWithRelationInput | GivenAwayLootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GivenAwayLoots.
     */
    cursor?: GivenAwayLootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GivenAwayLoots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GivenAwayLoots.
     */
    skip?: number
    distinct?: GivenAwayLootScalarFieldEnum | GivenAwayLootScalarFieldEnum[]
  }

  /**
   * GivenAwayLoot create
   */
  export type GivenAwayLootCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootInclude<ExtArgs> | null
    /**
     * The data needed to create a GivenAwayLoot.
     */
    data: XOR<GivenAwayLootCreateInput, GivenAwayLootUncheckedCreateInput>
  }

  /**
   * GivenAwayLoot createMany
   */
  export type GivenAwayLootCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GivenAwayLoots.
     */
    data: GivenAwayLootCreateManyInput | GivenAwayLootCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GivenAwayLoot createManyAndReturn
   */
  export type GivenAwayLootCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * The data used to create many GivenAwayLoots.
     */
    data: GivenAwayLootCreateManyInput | GivenAwayLootCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GivenAwayLoot update
   */
  export type GivenAwayLootUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootInclude<ExtArgs> | null
    /**
     * The data needed to update a GivenAwayLoot.
     */
    data: XOR<GivenAwayLootUpdateInput, GivenAwayLootUncheckedUpdateInput>
    /**
     * Choose, which GivenAwayLoot to update.
     */
    where: GivenAwayLootWhereUniqueInput
  }

  /**
   * GivenAwayLoot updateMany
   */
  export type GivenAwayLootUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GivenAwayLoots.
     */
    data: XOR<GivenAwayLootUpdateManyMutationInput, GivenAwayLootUncheckedUpdateManyInput>
    /**
     * Filter which GivenAwayLoots to update
     */
    where?: GivenAwayLootWhereInput
    /**
     * Limit how many GivenAwayLoots to update.
     */
    limit?: number
  }

  /**
   * GivenAwayLoot updateManyAndReturn
   */
  export type GivenAwayLootUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * The data used to update GivenAwayLoots.
     */
    data: XOR<GivenAwayLootUpdateManyMutationInput, GivenAwayLootUncheckedUpdateManyInput>
    /**
     * Filter which GivenAwayLoots to update
     */
    where?: GivenAwayLootWhereInput
    /**
     * Limit how many GivenAwayLoots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GivenAwayLoot upsert
   */
  export type GivenAwayLootUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootInclude<ExtArgs> | null
    /**
     * The filter to search for the GivenAwayLoot to update in case it exists.
     */
    where: GivenAwayLootWhereUniqueInput
    /**
     * In case the GivenAwayLoot found by the `where` argument doesn't exist, create a new GivenAwayLoot with this data.
     */
    create: XOR<GivenAwayLootCreateInput, GivenAwayLootUncheckedCreateInput>
    /**
     * In case the GivenAwayLoot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GivenAwayLootUpdateInput, GivenAwayLootUncheckedUpdateInput>
  }

  /**
   * GivenAwayLoot delete
   */
  export type GivenAwayLootDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootInclude<ExtArgs> | null
    /**
     * Filter which GivenAwayLoot to delete.
     */
    where: GivenAwayLootWhereUniqueInput
  }

  /**
   * GivenAwayLoot deleteMany
   */
  export type GivenAwayLootDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GivenAwayLoots to delete
     */
    where?: GivenAwayLootWhereInput
    /**
     * Limit how many GivenAwayLoots to delete.
     */
    limit?: number
  }

  /**
   * GivenAwayLoot without action
   */
  export type GivenAwayLootDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenAwayLoot
     */
    select?: GivenAwayLootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenAwayLoot
     */
    omit?: GivenAwayLootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenAwayLootInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: number | null
    date: Date | null
    amount: number | null
    target: string | null
    source: string | null
    comment: string | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    amount: number | null
    target: string | null
    source: string | null
    comment: string | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    date: number
    amount: number
    target: number
    source: number
    comment: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    id?: true
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    id?: true
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    target?: true
    source?: true
    comment?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    target?: true
    source?: true
    comment?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    date?: true
    amount?: true
    target?: true
    source?: true
    comment?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: number
    date: Date
    amount: number
    target: string
    source: string
    comment: string | null
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    amount?: boolean
    target?: boolean
    source?: boolean
    comment?: boolean
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    amount?: boolean
    target?: boolean
    source?: boolean
    comment?: boolean
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    amount?: boolean
    target?: boolean
    source?: boolean
    comment?: boolean
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    date?: boolean
    amount?: boolean
    target?: boolean
    source?: boolean
    comment?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "amount" | "target" | "source" | "comment", ExtArgs["result"]["expense"]>

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      amount: number
      target: string
      source: string
      comment: string | null
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'Int'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly amount: FieldRef<"Expense", 'Int'>
    readonly target: FieldRef<"Expense", 'String'>
    readonly source: FieldRef<"Expense", 'String'>
    readonly comment: FieldRef<"Expense", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
  }


  /**
   * Model GuildFunds
   */

  export type AggregateGuildFunds = {
    _count: GuildFundsCountAggregateOutputType | null
    _avg: GuildFundsAvgAggregateOutputType | null
    _sum: GuildFundsSumAggregateOutputType | null
    _min: GuildFundsMinAggregateOutputType | null
    _max: GuildFundsMaxAggregateOutputType | null
  }

  export type GuildFundsAvgAggregateOutputType = {
    id: number | null
    year: number | null
    month: number | null
    totalIncome: number | null
    totalExpenses: number | null
    profit: number | null
    salaryBudget: number | null
    treasuryLeft: number | null
  }

  export type GuildFundsSumAggregateOutputType = {
    id: number | null
    year: number | null
    month: number | null
    totalIncome: number | null
    totalExpenses: number | null
    profit: number | null
    salaryBudget: number | null
    treasuryLeft: number | null
  }

  export type GuildFundsMinAggregateOutputType = {
    id: number | null
    year: number | null
    month: number | null
    totalIncome: number | null
    totalExpenses: number | null
    profit: number | null
    salaryBudget: number | null
    treasuryLeft: number | null
  }

  export type GuildFundsMaxAggregateOutputType = {
    id: number | null
    year: number | null
    month: number | null
    totalIncome: number | null
    totalExpenses: number | null
    profit: number | null
    salaryBudget: number | null
    treasuryLeft: number | null
  }

  export type GuildFundsCountAggregateOutputType = {
    id: number
    year: number
    month: number
    totalIncome: number
    totalExpenses: number
    profit: number
    salaryBudget: number
    treasuryLeft: number
    _all: number
  }


  export type GuildFundsAvgAggregateInputType = {
    id?: true
    year?: true
    month?: true
    totalIncome?: true
    totalExpenses?: true
    profit?: true
    salaryBudget?: true
    treasuryLeft?: true
  }

  export type GuildFundsSumAggregateInputType = {
    id?: true
    year?: true
    month?: true
    totalIncome?: true
    totalExpenses?: true
    profit?: true
    salaryBudget?: true
    treasuryLeft?: true
  }

  export type GuildFundsMinAggregateInputType = {
    id?: true
    year?: true
    month?: true
    totalIncome?: true
    totalExpenses?: true
    profit?: true
    salaryBudget?: true
    treasuryLeft?: true
  }

  export type GuildFundsMaxAggregateInputType = {
    id?: true
    year?: true
    month?: true
    totalIncome?: true
    totalExpenses?: true
    profit?: true
    salaryBudget?: true
    treasuryLeft?: true
  }

  export type GuildFundsCountAggregateInputType = {
    id?: true
    year?: true
    month?: true
    totalIncome?: true
    totalExpenses?: true
    profit?: true
    salaryBudget?: true
    treasuryLeft?: true
    _all?: true
  }

  export type GuildFundsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildFunds to aggregate.
     */
    where?: GuildFundsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildFunds to fetch.
     */
    orderBy?: GuildFundsOrderByWithRelationInput | GuildFundsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildFundsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildFunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildFunds
    **/
    _count?: true | GuildFundsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildFundsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildFundsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildFundsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildFundsMaxAggregateInputType
  }

  export type GetGuildFundsAggregateType<T extends GuildFundsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildFunds]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildFunds[P]>
      : GetScalarType<T[P], AggregateGuildFunds[P]>
  }




  export type GuildFundsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildFundsWhereInput
    orderBy?: GuildFundsOrderByWithAggregationInput | GuildFundsOrderByWithAggregationInput[]
    by: GuildFundsScalarFieldEnum[] | GuildFundsScalarFieldEnum
    having?: GuildFundsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildFundsCountAggregateInputType | true
    _avg?: GuildFundsAvgAggregateInputType
    _sum?: GuildFundsSumAggregateInputType
    _min?: GuildFundsMinAggregateInputType
    _max?: GuildFundsMaxAggregateInputType
  }

  export type GuildFundsGroupByOutputType = {
    id: number
    year: number
    month: number
    totalIncome: number
    totalExpenses: number
    profit: number
    salaryBudget: number
    treasuryLeft: number
    _count: GuildFundsCountAggregateOutputType | null
    _avg: GuildFundsAvgAggregateOutputType | null
    _sum: GuildFundsSumAggregateOutputType | null
    _min: GuildFundsMinAggregateOutputType | null
    _max: GuildFundsMaxAggregateOutputType | null
  }

  type GetGuildFundsGroupByPayload<T extends GuildFundsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildFundsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildFundsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildFundsGroupByOutputType[P]>
            : GetScalarType<T[P], GuildFundsGroupByOutputType[P]>
        }
      >
    >


  export type GuildFundsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    month?: boolean
    totalIncome?: boolean
    totalExpenses?: boolean
    profit?: boolean
    salaryBudget?: boolean
    treasuryLeft?: boolean
  }, ExtArgs["result"]["guildFunds"]>

  export type GuildFundsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    month?: boolean
    totalIncome?: boolean
    totalExpenses?: boolean
    profit?: boolean
    salaryBudget?: boolean
    treasuryLeft?: boolean
  }, ExtArgs["result"]["guildFunds"]>

  export type GuildFundsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    month?: boolean
    totalIncome?: boolean
    totalExpenses?: boolean
    profit?: boolean
    salaryBudget?: boolean
    treasuryLeft?: boolean
  }, ExtArgs["result"]["guildFunds"]>

  export type GuildFundsSelectScalar = {
    id?: boolean
    year?: boolean
    month?: boolean
    totalIncome?: boolean
    totalExpenses?: boolean
    profit?: boolean
    salaryBudget?: boolean
    treasuryLeft?: boolean
  }

  export type GuildFundsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "month" | "totalIncome" | "totalExpenses" | "profit" | "salaryBudget" | "treasuryLeft", ExtArgs["result"]["guildFunds"]>

  export type $GuildFundsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildFunds"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      year: number
      month: number
      totalIncome: number
      totalExpenses: number
      profit: number
      salaryBudget: number
      treasuryLeft: number
    }, ExtArgs["result"]["guildFunds"]>
    composites: {}
  }

  type GuildFundsGetPayload<S extends boolean | null | undefined | GuildFundsDefaultArgs> = $Result.GetResult<Prisma.$GuildFundsPayload, S>

  type GuildFundsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuildFundsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuildFundsCountAggregateInputType | true
    }

  export interface GuildFundsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildFunds'], meta: { name: 'GuildFunds' } }
    /**
     * Find zero or one GuildFunds that matches the filter.
     * @param {GuildFundsFindUniqueArgs} args - Arguments to find a GuildFunds
     * @example
     * // Get one GuildFunds
     * const guildFunds = await prisma.guildFunds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuildFundsFindUniqueArgs>(args: SelectSubset<T, GuildFundsFindUniqueArgs<ExtArgs>>): Prisma__GuildFundsClient<$Result.GetResult<Prisma.$GuildFundsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuildFunds that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuildFundsFindUniqueOrThrowArgs} args - Arguments to find a GuildFunds
     * @example
     * // Get one GuildFunds
     * const guildFunds = await prisma.guildFunds.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuildFundsFindUniqueOrThrowArgs>(args: SelectSubset<T, GuildFundsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuildFundsClient<$Result.GetResult<Prisma.$GuildFundsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildFunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFundsFindFirstArgs} args - Arguments to find a GuildFunds
     * @example
     * // Get one GuildFunds
     * const guildFunds = await prisma.guildFunds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuildFundsFindFirstArgs>(args?: SelectSubset<T, GuildFundsFindFirstArgs<ExtArgs>>): Prisma__GuildFundsClient<$Result.GetResult<Prisma.$GuildFundsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuildFunds that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFundsFindFirstOrThrowArgs} args - Arguments to find a GuildFunds
     * @example
     * // Get one GuildFunds
     * const guildFunds = await prisma.guildFunds.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuildFundsFindFirstOrThrowArgs>(args?: SelectSubset<T, GuildFundsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuildFundsClient<$Result.GetResult<Prisma.$GuildFundsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuildFunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFundsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildFunds
     * const guildFunds = await prisma.guildFunds.findMany()
     * 
     * // Get first 10 GuildFunds
     * const guildFunds = await prisma.guildFunds.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildFundsWithIdOnly = await prisma.guildFunds.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuildFundsFindManyArgs>(args?: SelectSubset<T, GuildFundsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildFundsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuildFunds.
     * @param {GuildFundsCreateArgs} args - Arguments to create a GuildFunds.
     * @example
     * // Create one GuildFunds
     * const GuildFunds = await prisma.guildFunds.create({
     *   data: {
     *     // ... data to create a GuildFunds
     *   }
     * })
     * 
     */
    create<T extends GuildFundsCreateArgs>(args: SelectSubset<T, GuildFundsCreateArgs<ExtArgs>>): Prisma__GuildFundsClient<$Result.GetResult<Prisma.$GuildFundsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuildFunds.
     * @param {GuildFundsCreateManyArgs} args - Arguments to create many GuildFunds.
     * @example
     * // Create many GuildFunds
     * const guildFunds = await prisma.guildFunds.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuildFundsCreateManyArgs>(args?: SelectSubset<T, GuildFundsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GuildFunds and returns the data saved in the database.
     * @param {GuildFundsCreateManyAndReturnArgs} args - Arguments to create many GuildFunds.
     * @example
     * // Create many GuildFunds
     * const guildFunds = await prisma.guildFunds.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GuildFunds and only return the `id`
     * const guildFundsWithIdOnly = await prisma.guildFunds.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuildFundsCreateManyAndReturnArgs>(args?: SelectSubset<T, GuildFundsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildFundsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GuildFunds.
     * @param {GuildFundsDeleteArgs} args - Arguments to delete one GuildFunds.
     * @example
     * // Delete one GuildFunds
     * const GuildFunds = await prisma.guildFunds.delete({
     *   where: {
     *     // ... filter to delete one GuildFunds
     *   }
     * })
     * 
     */
    delete<T extends GuildFundsDeleteArgs>(args: SelectSubset<T, GuildFundsDeleteArgs<ExtArgs>>): Prisma__GuildFundsClient<$Result.GetResult<Prisma.$GuildFundsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuildFunds.
     * @param {GuildFundsUpdateArgs} args - Arguments to update one GuildFunds.
     * @example
     * // Update one GuildFunds
     * const guildFunds = await prisma.guildFunds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuildFundsUpdateArgs>(args: SelectSubset<T, GuildFundsUpdateArgs<ExtArgs>>): Prisma__GuildFundsClient<$Result.GetResult<Prisma.$GuildFundsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuildFunds.
     * @param {GuildFundsDeleteManyArgs} args - Arguments to filter GuildFunds to delete.
     * @example
     * // Delete a few GuildFunds
     * const { count } = await prisma.guildFunds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuildFundsDeleteManyArgs>(args?: SelectSubset<T, GuildFundsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildFunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFundsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildFunds
     * const guildFunds = await prisma.guildFunds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuildFundsUpdateManyArgs>(args: SelectSubset<T, GuildFundsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildFunds and returns the data updated in the database.
     * @param {GuildFundsUpdateManyAndReturnArgs} args - Arguments to update many GuildFunds.
     * @example
     * // Update many GuildFunds
     * const guildFunds = await prisma.guildFunds.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GuildFunds and only return the `id`
     * const guildFundsWithIdOnly = await prisma.guildFunds.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuildFundsUpdateManyAndReturnArgs>(args: SelectSubset<T, GuildFundsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildFundsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GuildFunds.
     * @param {GuildFundsUpsertArgs} args - Arguments to update or create a GuildFunds.
     * @example
     * // Update or create a GuildFunds
     * const guildFunds = await prisma.guildFunds.upsert({
     *   create: {
     *     // ... data to create a GuildFunds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildFunds we want to update
     *   }
     * })
     */
    upsert<T extends GuildFundsUpsertArgs>(args: SelectSubset<T, GuildFundsUpsertArgs<ExtArgs>>): Prisma__GuildFundsClient<$Result.GetResult<Prisma.$GuildFundsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GuildFunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFundsCountArgs} args - Arguments to filter GuildFunds to count.
     * @example
     * // Count the number of GuildFunds
     * const count = await prisma.guildFunds.count({
     *   where: {
     *     // ... the filter for the GuildFunds we want to count
     *   }
     * })
    **/
    count<T extends GuildFundsCountArgs>(
      args?: Subset<T, GuildFundsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildFundsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildFunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFundsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildFundsAggregateArgs>(args: Subset<T, GuildFundsAggregateArgs>): Prisma.PrismaPromise<GetGuildFundsAggregateType<T>>

    /**
     * Group by GuildFunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFundsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildFundsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildFundsGroupByArgs['orderBy'] }
        : { orderBy?: GuildFundsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildFundsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildFundsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildFunds model
   */
  readonly fields: GuildFundsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildFunds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildFundsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuildFunds model
   */
  interface GuildFundsFieldRefs {
    readonly id: FieldRef<"GuildFunds", 'Int'>
    readonly year: FieldRef<"GuildFunds", 'Int'>
    readonly month: FieldRef<"GuildFunds", 'Int'>
    readonly totalIncome: FieldRef<"GuildFunds", 'Int'>
    readonly totalExpenses: FieldRef<"GuildFunds", 'Int'>
    readonly profit: FieldRef<"GuildFunds", 'Int'>
    readonly salaryBudget: FieldRef<"GuildFunds", 'Int'>
    readonly treasuryLeft: FieldRef<"GuildFunds", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GuildFunds findUnique
   */
  export type GuildFundsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFunds
     */
    select?: GuildFundsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFunds
     */
    omit?: GuildFundsOmit<ExtArgs> | null
    /**
     * Filter, which GuildFunds to fetch.
     */
    where: GuildFundsWhereUniqueInput
  }

  /**
   * GuildFunds findUniqueOrThrow
   */
  export type GuildFundsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFunds
     */
    select?: GuildFundsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFunds
     */
    omit?: GuildFundsOmit<ExtArgs> | null
    /**
     * Filter, which GuildFunds to fetch.
     */
    where: GuildFundsWhereUniqueInput
  }

  /**
   * GuildFunds findFirst
   */
  export type GuildFundsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFunds
     */
    select?: GuildFundsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFunds
     */
    omit?: GuildFundsOmit<ExtArgs> | null
    /**
     * Filter, which GuildFunds to fetch.
     */
    where?: GuildFundsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildFunds to fetch.
     */
    orderBy?: GuildFundsOrderByWithRelationInput | GuildFundsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildFunds.
     */
    cursor?: GuildFundsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildFunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildFunds.
     */
    distinct?: GuildFundsScalarFieldEnum | GuildFundsScalarFieldEnum[]
  }

  /**
   * GuildFunds findFirstOrThrow
   */
  export type GuildFundsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFunds
     */
    select?: GuildFundsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFunds
     */
    omit?: GuildFundsOmit<ExtArgs> | null
    /**
     * Filter, which GuildFunds to fetch.
     */
    where?: GuildFundsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildFunds to fetch.
     */
    orderBy?: GuildFundsOrderByWithRelationInput | GuildFundsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildFunds.
     */
    cursor?: GuildFundsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildFunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildFunds.
     */
    distinct?: GuildFundsScalarFieldEnum | GuildFundsScalarFieldEnum[]
  }

  /**
   * GuildFunds findMany
   */
  export type GuildFundsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFunds
     */
    select?: GuildFundsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFunds
     */
    omit?: GuildFundsOmit<ExtArgs> | null
    /**
     * Filter, which GuildFunds to fetch.
     */
    where?: GuildFundsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildFunds to fetch.
     */
    orderBy?: GuildFundsOrderByWithRelationInput | GuildFundsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildFunds.
     */
    cursor?: GuildFundsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildFunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildFunds.
     */
    skip?: number
    distinct?: GuildFundsScalarFieldEnum | GuildFundsScalarFieldEnum[]
  }

  /**
   * GuildFunds create
   */
  export type GuildFundsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFunds
     */
    select?: GuildFundsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFunds
     */
    omit?: GuildFundsOmit<ExtArgs> | null
    /**
     * The data needed to create a GuildFunds.
     */
    data: XOR<GuildFundsCreateInput, GuildFundsUncheckedCreateInput>
  }

  /**
   * GuildFunds createMany
   */
  export type GuildFundsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildFunds.
     */
    data: GuildFundsCreateManyInput | GuildFundsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GuildFunds createManyAndReturn
   */
  export type GuildFundsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFunds
     */
    select?: GuildFundsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFunds
     */
    omit?: GuildFundsOmit<ExtArgs> | null
    /**
     * The data used to create many GuildFunds.
     */
    data: GuildFundsCreateManyInput | GuildFundsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GuildFunds update
   */
  export type GuildFundsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFunds
     */
    select?: GuildFundsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFunds
     */
    omit?: GuildFundsOmit<ExtArgs> | null
    /**
     * The data needed to update a GuildFunds.
     */
    data: XOR<GuildFundsUpdateInput, GuildFundsUncheckedUpdateInput>
    /**
     * Choose, which GuildFunds to update.
     */
    where: GuildFundsWhereUniqueInput
  }

  /**
   * GuildFunds updateMany
   */
  export type GuildFundsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildFunds.
     */
    data: XOR<GuildFundsUpdateManyMutationInput, GuildFundsUncheckedUpdateManyInput>
    /**
     * Filter which GuildFunds to update
     */
    where?: GuildFundsWhereInput
    /**
     * Limit how many GuildFunds to update.
     */
    limit?: number
  }

  /**
   * GuildFunds updateManyAndReturn
   */
  export type GuildFundsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFunds
     */
    select?: GuildFundsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFunds
     */
    omit?: GuildFundsOmit<ExtArgs> | null
    /**
     * The data used to update GuildFunds.
     */
    data: XOR<GuildFundsUpdateManyMutationInput, GuildFundsUncheckedUpdateManyInput>
    /**
     * Filter which GuildFunds to update
     */
    where?: GuildFundsWhereInput
    /**
     * Limit how many GuildFunds to update.
     */
    limit?: number
  }

  /**
   * GuildFunds upsert
   */
  export type GuildFundsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFunds
     */
    select?: GuildFundsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFunds
     */
    omit?: GuildFundsOmit<ExtArgs> | null
    /**
     * The filter to search for the GuildFunds to update in case it exists.
     */
    where: GuildFundsWhereUniqueInput
    /**
     * In case the GuildFunds found by the `where` argument doesn't exist, create a new GuildFunds with this data.
     */
    create: XOR<GuildFundsCreateInput, GuildFundsUncheckedCreateInput>
    /**
     * In case the GuildFunds was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildFundsUpdateInput, GuildFundsUncheckedUpdateInput>
  }

  /**
   * GuildFunds delete
   */
  export type GuildFundsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFunds
     */
    select?: GuildFundsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFunds
     */
    omit?: GuildFundsOmit<ExtArgs> | null
    /**
     * Filter which GuildFunds to delete.
     */
    where: GuildFundsWhereUniqueInput
  }

  /**
   * GuildFunds deleteMany
   */
  export type GuildFundsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildFunds to delete
     */
    where?: GuildFundsWhereInput
    /**
     * Limit how many GuildFunds to delete.
     */
    limit?: number
  }

  /**
   * GuildFunds without action
   */
  export type GuildFundsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildFunds
     */
    select?: GuildFundsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuildFunds
     */
    omit?: GuildFundsOmit<ExtArgs> | null
  }


  /**
   * Model Salary
   */

  export type AggregateSalary = {
    _count: SalaryCountAggregateOutputType | null
    _avg: SalaryAvgAggregateOutputType | null
    _sum: SalarySumAggregateOutputType | null
    _min: SalaryMinAggregateOutputType | null
    _max: SalaryMaxAggregateOutputType | null
  }

  export type SalaryAvgAggregateOutputType = {
    id: number | null
    year: number | null
    month: number | null
    userId: number | null
    amount: number | null
    bonus: number | null
    total: number | null
  }

  export type SalarySumAggregateOutputType = {
    id: number | null
    year: number | null
    month: number | null
    userId: number | null
    amount: number | null
    bonus: number | null
    total: number | null
  }

  export type SalaryMinAggregateOutputType = {
    id: number | null
    year: number | null
    month: number | null
    userId: number | null
    amount: number | null
    bonus: number | null
    total: number | null
  }

  export type SalaryMaxAggregateOutputType = {
    id: number | null
    year: number | null
    month: number | null
    userId: number | null
    amount: number | null
    bonus: number | null
    total: number | null
  }

  export type SalaryCountAggregateOutputType = {
    id: number
    year: number
    month: number
    userId: number
    amount: number
    bonus: number
    total: number
    _all: number
  }


  export type SalaryAvgAggregateInputType = {
    id?: true
    year?: true
    month?: true
    userId?: true
    amount?: true
    bonus?: true
    total?: true
  }

  export type SalarySumAggregateInputType = {
    id?: true
    year?: true
    month?: true
    userId?: true
    amount?: true
    bonus?: true
    total?: true
  }

  export type SalaryMinAggregateInputType = {
    id?: true
    year?: true
    month?: true
    userId?: true
    amount?: true
    bonus?: true
    total?: true
  }

  export type SalaryMaxAggregateInputType = {
    id?: true
    year?: true
    month?: true
    userId?: true
    amount?: true
    bonus?: true
    total?: true
  }

  export type SalaryCountAggregateInputType = {
    id?: true
    year?: true
    month?: true
    userId?: true
    amount?: true
    bonus?: true
    total?: true
    _all?: true
  }

  export type SalaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salary to aggregate.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salaries
    **/
    _count?: true | SalaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryMaxAggregateInputType
  }

  export type GetSalaryAggregateType<T extends SalaryAggregateArgs> = {
        [P in keyof T & keyof AggregateSalary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalary[P]>
      : GetScalarType<T[P], AggregateSalary[P]>
  }




  export type SalaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryWhereInput
    orderBy?: SalaryOrderByWithAggregationInput | SalaryOrderByWithAggregationInput[]
    by: SalaryScalarFieldEnum[] | SalaryScalarFieldEnum
    having?: SalaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryCountAggregateInputType | true
    _avg?: SalaryAvgAggregateInputType
    _sum?: SalarySumAggregateInputType
    _min?: SalaryMinAggregateInputType
    _max?: SalaryMaxAggregateInputType
  }

  export type SalaryGroupByOutputType = {
    id: number
    year: number
    month: number
    userId: number
    amount: number
    bonus: number | null
    total: number
    _count: SalaryCountAggregateOutputType | null
    _avg: SalaryAvgAggregateOutputType | null
    _sum: SalarySumAggregateOutputType | null
    _min: SalaryMinAggregateOutputType | null
    _max: SalaryMaxAggregateOutputType | null
  }

  type GetSalaryGroupByPayload<T extends SalaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryGroupByOutputType[P]>
        }
      >
    >


  export type SalarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    month?: boolean
    userId?: boolean
    amount?: boolean
    bonus?: boolean
    total?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salary"]>

  export type SalarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    month?: boolean
    userId?: boolean
    amount?: boolean
    bonus?: boolean
    total?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salary"]>

  export type SalarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    month?: boolean
    userId?: boolean
    amount?: boolean
    bonus?: boolean
    total?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salary"]>

  export type SalarySelectScalar = {
    id?: boolean
    year?: boolean
    month?: boolean
    userId?: boolean
    amount?: boolean
    bonus?: boolean
    total?: boolean
  }

  export type SalaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "month" | "userId" | "amount" | "bonus" | "total", ExtArgs["result"]["salary"]>
  export type SalaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SalaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SalaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SalaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Salary"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      year: number
      month: number
      userId: number
      amount: number
      bonus: number | null
      total: number
    }, ExtArgs["result"]["salary"]>
    composites: {}
  }

  type SalaryGetPayload<S extends boolean | null | undefined | SalaryDefaultArgs> = $Result.GetResult<Prisma.$SalaryPayload, S>

  type SalaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryCountAggregateInputType | true
    }

  export interface SalaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Salary'], meta: { name: 'Salary' } }
    /**
     * Find zero or one Salary that matches the filter.
     * @param {SalaryFindUniqueArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryFindUniqueArgs>(args: SelectSubset<T, SalaryFindUniqueArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Salary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryFindUniqueOrThrowArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Salary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindFirstArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryFindFirstArgs>(args?: SelectSubset<T, SalaryFindFirstArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Salary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindFirstOrThrowArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Salaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salaries
     * const salaries = await prisma.salary.findMany()
     * 
     * // Get first 10 Salaries
     * const salaries = await prisma.salary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryWithIdOnly = await prisma.salary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryFindManyArgs>(args?: SelectSubset<T, SalaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Salary.
     * @param {SalaryCreateArgs} args - Arguments to create a Salary.
     * @example
     * // Create one Salary
     * const Salary = await prisma.salary.create({
     *   data: {
     *     // ... data to create a Salary
     *   }
     * })
     * 
     */
    create<T extends SalaryCreateArgs>(args: SelectSubset<T, SalaryCreateArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Salaries.
     * @param {SalaryCreateManyArgs} args - Arguments to create many Salaries.
     * @example
     * // Create many Salaries
     * const salary = await prisma.salary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryCreateManyArgs>(args?: SelectSubset<T, SalaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Salaries and returns the data saved in the database.
     * @param {SalaryCreateManyAndReturnArgs} args - Arguments to create many Salaries.
     * @example
     * // Create many Salaries
     * const salary = await prisma.salary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Salaries and only return the `id`
     * const salaryWithIdOnly = await prisma.salary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Salary.
     * @param {SalaryDeleteArgs} args - Arguments to delete one Salary.
     * @example
     * // Delete one Salary
     * const Salary = await prisma.salary.delete({
     *   where: {
     *     // ... filter to delete one Salary
     *   }
     * })
     * 
     */
    delete<T extends SalaryDeleteArgs>(args: SelectSubset<T, SalaryDeleteArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Salary.
     * @param {SalaryUpdateArgs} args - Arguments to update one Salary.
     * @example
     * // Update one Salary
     * const salary = await prisma.salary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryUpdateArgs>(args: SelectSubset<T, SalaryUpdateArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Salaries.
     * @param {SalaryDeleteManyArgs} args - Arguments to filter Salaries to delete.
     * @example
     * // Delete a few Salaries
     * const { count } = await prisma.salary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryDeleteManyArgs>(args?: SelectSubset<T, SalaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salaries
     * const salary = await prisma.salary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryUpdateManyArgs>(args: SelectSubset<T, SalaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salaries and returns the data updated in the database.
     * @param {SalaryUpdateManyAndReturnArgs} args - Arguments to update many Salaries.
     * @example
     * // Update many Salaries
     * const salary = await prisma.salary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Salaries and only return the `id`
     * const salaryWithIdOnly = await prisma.salary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaryUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Salary.
     * @param {SalaryUpsertArgs} args - Arguments to update or create a Salary.
     * @example
     * // Update or create a Salary
     * const salary = await prisma.salary.upsert({
     *   create: {
     *     // ... data to create a Salary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salary we want to update
     *   }
     * })
     */
    upsert<T extends SalaryUpsertArgs>(args: SelectSubset<T, SalaryUpsertArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryCountArgs} args - Arguments to filter Salaries to count.
     * @example
     * // Count the number of Salaries
     * const count = await prisma.salary.count({
     *   where: {
     *     // ... the filter for the Salaries we want to count
     *   }
     * })
    **/
    count<T extends SalaryCountArgs>(
      args?: Subset<T, SalaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryAggregateArgs>(args: Subset<T, SalaryAggregateArgs>): Prisma.PrismaPromise<GetSalaryAggregateType<T>>

    /**
     * Group by Salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryGroupByArgs['orderBy'] }
        : { orderBy?: SalaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Salary model
   */
  readonly fields: SalaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Salary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Salary model
   */
  interface SalaryFieldRefs {
    readonly id: FieldRef<"Salary", 'Int'>
    readonly year: FieldRef<"Salary", 'Int'>
    readonly month: FieldRef<"Salary", 'Int'>
    readonly userId: FieldRef<"Salary", 'Int'>
    readonly amount: FieldRef<"Salary", 'Int'>
    readonly bonus: FieldRef<"Salary", 'Int'>
    readonly total: FieldRef<"Salary", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Salary findUnique
   */
  export type SalaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary findUniqueOrThrow
   */
  export type SalaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary findFirst
   */
  export type SalaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salaries.
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salaries.
     */
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Salary findFirstOrThrow
   */
  export type SalaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salaries.
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salaries.
     */
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Salary findMany
   */
  export type SalaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salaries to fetch.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salaries.
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Salary create
   */
  export type SalaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * The data needed to create a Salary.
     */
    data: XOR<SalaryCreateInput, SalaryUncheckedCreateInput>
  }

  /**
   * Salary createMany
   */
  export type SalaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Salaries.
     */
    data: SalaryCreateManyInput | SalaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Salary createManyAndReturn
   */
  export type SalaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * The data used to create many Salaries.
     */
    data: SalaryCreateManyInput | SalaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Salary update
   */
  export type SalaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * The data needed to update a Salary.
     */
    data: XOR<SalaryUpdateInput, SalaryUncheckedUpdateInput>
    /**
     * Choose, which Salary to update.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary updateMany
   */
  export type SalaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Salaries.
     */
    data: XOR<SalaryUpdateManyMutationInput, SalaryUncheckedUpdateManyInput>
    /**
     * Filter which Salaries to update
     */
    where?: SalaryWhereInput
    /**
     * Limit how many Salaries to update.
     */
    limit?: number
  }

  /**
   * Salary updateManyAndReturn
   */
  export type SalaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * The data used to update Salaries.
     */
    data: XOR<SalaryUpdateManyMutationInput, SalaryUncheckedUpdateManyInput>
    /**
     * Filter which Salaries to update
     */
    where?: SalaryWhereInput
    /**
     * Limit how many Salaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Salary upsert
   */
  export type SalaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * The filter to search for the Salary to update in case it exists.
     */
    where: SalaryWhereUniqueInput
    /**
     * In case the Salary found by the `where` argument doesn't exist, create a new Salary with this data.
     */
    create: XOR<SalaryCreateInput, SalaryUncheckedCreateInput>
    /**
     * In case the Salary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryUpdateInput, SalaryUncheckedUpdateInput>
  }

  /**
   * Salary delete
   */
  export type SalaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter which Salary to delete.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary deleteMany
   */
  export type SalaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salaries to delete
     */
    where?: SalaryWhereInput
    /**
     * Limit how many Salaries to delete.
     */
    limit?: number
  }

  /**
   * Salary without action
   */
  export type SalaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
  }


  /**
   * Model UserSalaryBonus
   */

  export type AggregateUserSalaryBonus = {
    _count: UserSalaryBonusCountAggregateOutputType | null
    _avg: UserSalaryBonusAvgAggregateOutputType | null
    _sum: UserSalaryBonusSumAggregateOutputType | null
    _min: UserSalaryBonusMinAggregateOutputType | null
    _max: UserSalaryBonusMaxAggregateOutputType | null
  }

  export type UserSalaryBonusAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    amount: number | null
  }

  export type UserSalaryBonusSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    amount: number | null
  }

  export type UserSalaryBonusMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    amount: number | null
    reason: string | null
    created_at: Date | null
  }

  export type UserSalaryBonusMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    amount: number | null
    reason: string | null
    created_at: Date | null
  }

  export type UserSalaryBonusCountAggregateOutputType = {
    id: number
    user_id: number
    amount: number
    reason: number
    created_at: number
    _all: number
  }


  export type UserSalaryBonusAvgAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
  }

  export type UserSalaryBonusSumAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
  }

  export type UserSalaryBonusMinAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    reason?: true
    created_at?: true
  }

  export type UserSalaryBonusMaxAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    reason?: true
    created_at?: true
  }

  export type UserSalaryBonusCountAggregateInputType = {
    id?: true
    user_id?: true
    amount?: true
    reason?: true
    created_at?: true
    _all?: true
  }

  export type UserSalaryBonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSalaryBonus to aggregate.
     */
    where?: UserSalaryBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSalaryBonuses to fetch.
     */
    orderBy?: UserSalaryBonusOrderByWithRelationInput | UserSalaryBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSalaryBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSalaryBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSalaryBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSalaryBonuses
    **/
    _count?: true | UserSalaryBonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSalaryBonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSalaryBonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSalaryBonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSalaryBonusMaxAggregateInputType
  }

  export type GetUserSalaryBonusAggregateType<T extends UserSalaryBonusAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSalaryBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSalaryBonus[P]>
      : GetScalarType<T[P], AggregateUserSalaryBonus[P]>
  }




  export type UserSalaryBonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSalaryBonusWhereInput
    orderBy?: UserSalaryBonusOrderByWithAggregationInput | UserSalaryBonusOrderByWithAggregationInput[]
    by: UserSalaryBonusScalarFieldEnum[] | UserSalaryBonusScalarFieldEnum
    having?: UserSalaryBonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSalaryBonusCountAggregateInputType | true
    _avg?: UserSalaryBonusAvgAggregateInputType
    _sum?: UserSalaryBonusSumAggregateInputType
    _min?: UserSalaryBonusMinAggregateInputType
    _max?: UserSalaryBonusMaxAggregateInputType
  }

  export type UserSalaryBonusGroupByOutputType = {
    id: number
    user_id: number
    amount: number
    reason: string
    created_at: Date | null
    _count: UserSalaryBonusCountAggregateOutputType | null
    _avg: UserSalaryBonusAvgAggregateOutputType | null
    _sum: UserSalaryBonusSumAggregateOutputType | null
    _min: UserSalaryBonusMinAggregateOutputType | null
    _max: UserSalaryBonusMaxAggregateOutputType | null
  }

  type GetUserSalaryBonusGroupByPayload<T extends UserSalaryBonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSalaryBonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSalaryBonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSalaryBonusGroupByOutputType[P]>
            : GetScalarType<T[P], UserSalaryBonusGroupByOutputType[P]>
        }
      >
    >


  export type UserSalaryBonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    reason?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSalaryBonus"]>

  export type UserSalaryBonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    reason?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSalaryBonus"]>

  export type UserSalaryBonusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    amount?: boolean
    reason?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSalaryBonus"]>

  export type UserSalaryBonusSelectScalar = {
    id?: boolean
    user_id?: boolean
    amount?: boolean
    reason?: boolean
    created_at?: boolean
  }

  export type UserSalaryBonusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "amount" | "reason" | "created_at", ExtArgs["result"]["userSalaryBonus"]>
  export type UserSalaryBonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSalaryBonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSalaryBonusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSalaryBonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSalaryBonus"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      amount: number
      reason: string
      created_at: Date | null
    }, ExtArgs["result"]["userSalaryBonus"]>
    composites: {}
  }

  type UserSalaryBonusGetPayload<S extends boolean | null | undefined | UserSalaryBonusDefaultArgs> = $Result.GetResult<Prisma.$UserSalaryBonusPayload, S>

  type UserSalaryBonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSalaryBonusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSalaryBonusCountAggregateInputType | true
    }

  export interface UserSalaryBonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSalaryBonus'], meta: { name: 'UserSalaryBonus' } }
    /**
     * Find zero or one UserSalaryBonus that matches the filter.
     * @param {UserSalaryBonusFindUniqueArgs} args - Arguments to find a UserSalaryBonus
     * @example
     * // Get one UserSalaryBonus
     * const userSalaryBonus = await prisma.userSalaryBonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSalaryBonusFindUniqueArgs>(args: SelectSubset<T, UserSalaryBonusFindUniqueArgs<ExtArgs>>): Prisma__UserSalaryBonusClient<$Result.GetResult<Prisma.$UserSalaryBonusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSalaryBonus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSalaryBonusFindUniqueOrThrowArgs} args - Arguments to find a UserSalaryBonus
     * @example
     * // Get one UserSalaryBonus
     * const userSalaryBonus = await prisma.userSalaryBonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSalaryBonusFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSalaryBonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSalaryBonusClient<$Result.GetResult<Prisma.$UserSalaryBonusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSalaryBonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSalaryBonusFindFirstArgs} args - Arguments to find a UserSalaryBonus
     * @example
     * // Get one UserSalaryBonus
     * const userSalaryBonus = await prisma.userSalaryBonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSalaryBonusFindFirstArgs>(args?: SelectSubset<T, UserSalaryBonusFindFirstArgs<ExtArgs>>): Prisma__UserSalaryBonusClient<$Result.GetResult<Prisma.$UserSalaryBonusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSalaryBonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSalaryBonusFindFirstOrThrowArgs} args - Arguments to find a UserSalaryBonus
     * @example
     * // Get one UserSalaryBonus
     * const userSalaryBonus = await prisma.userSalaryBonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSalaryBonusFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSalaryBonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSalaryBonusClient<$Result.GetResult<Prisma.$UserSalaryBonusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSalaryBonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSalaryBonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSalaryBonuses
     * const userSalaryBonuses = await prisma.userSalaryBonus.findMany()
     * 
     * // Get first 10 UserSalaryBonuses
     * const userSalaryBonuses = await prisma.userSalaryBonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSalaryBonusWithIdOnly = await prisma.userSalaryBonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSalaryBonusFindManyArgs>(args?: SelectSubset<T, UserSalaryBonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSalaryBonusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSalaryBonus.
     * @param {UserSalaryBonusCreateArgs} args - Arguments to create a UserSalaryBonus.
     * @example
     * // Create one UserSalaryBonus
     * const UserSalaryBonus = await prisma.userSalaryBonus.create({
     *   data: {
     *     // ... data to create a UserSalaryBonus
     *   }
     * })
     * 
     */
    create<T extends UserSalaryBonusCreateArgs>(args: SelectSubset<T, UserSalaryBonusCreateArgs<ExtArgs>>): Prisma__UserSalaryBonusClient<$Result.GetResult<Prisma.$UserSalaryBonusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSalaryBonuses.
     * @param {UserSalaryBonusCreateManyArgs} args - Arguments to create many UserSalaryBonuses.
     * @example
     * // Create many UserSalaryBonuses
     * const userSalaryBonus = await prisma.userSalaryBonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSalaryBonusCreateManyArgs>(args?: SelectSubset<T, UserSalaryBonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSalaryBonuses and returns the data saved in the database.
     * @param {UserSalaryBonusCreateManyAndReturnArgs} args - Arguments to create many UserSalaryBonuses.
     * @example
     * // Create many UserSalaryBonuses
     * const userSalaryBonus = await prisma.userSalaryBonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSalaryBonuses and only return the `id`
     * const userSalaryBonusWithIdOnly = await prisma.userSalaryBonus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSalaryBonusCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSalaryBonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSalaryBonusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSalaryBonus.
     * @param {UserSalaryBonusDeleteArgs} args - Arguments to delete one UserSalaryBonus.
     * @example
     * // Delete one UserSalaryBonus
     * const UserSalaryBonus = await prisma.userSalaryBonus.delete({
     *   where: {
     *     // ... filter to delete one UserSalaryBonus
     *   }
     * })
     * 
     */
    delete<T extends UserSalaryBonusDeleteArgs>(args: SelectSubset<T, UserSalaryBonusDeleteArgs<ExtArgs>>): Prisma__UserSalaryBonusClient<$Result.GetResult<Prisma.$UserSalaryBonusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSalaryBonus.
     * @param {UserSalaryBonusUpdateArgs} args - Arguments to update one UserSalaryBonus.
     * @example
     * // Update one UserSalaryBonus
     * const userSalaryBonus = await prisma.userSalaryBonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSalaryBonusUpdateArgs>(args: SelectSubset<T, UserSalaryBonusUpdateArgs<ExtArgs>>): Prisma__UserSalaryBonusClient<$Result.GetResult<Prisma.$UserSalaryBonusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSalaryBonuses.
     * @param {UserSalaryBonusDeleteManyArgs} args - Arguments to filter UserSalaryBonuses to delete.
     * @example
     * // Delete a few UserSalaryBonuses
     * const { count } = await prisma.userSalaryBonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSalaryBonusDeleteManyArgs>(args?: SelectSubset<T, UserSalaryBonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSalaryBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSalaryBonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSalaryBonuses
     * const userSalaryBonus = await prisma.userSalaryBonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSalaryBonusUpdateManyArgs>(args: SelectSubset<T, UserSalaryBonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSalaryBonuses and returns the data updated in the database.
     * @param {UserSalaryBonusUpdateManyAndReturnArgs} args - Arguments to update many UserSalaryBonuses.
     * @example
     * // Update many UserSalaryBonuses
     * const userSalaryBonus = await prisma.userSalaryBonus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSalaryBonuses and only return the `id`
     * const userSalaryBonusWithIdOnly = await prisma.userSalaryBonus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSalaryBonusUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSalaryBonusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSalaryBonusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSalaryBonus.
     * @param {UserSalaryBonusUpsertArgs} args - Arguments to update or create a UserSalaryBonus.
     * @example
     * // Update or create a UserSalaryBonus
     * const userSalaryBonus = await prisma.userSalaryBonus.upsert({
     *   create: {
     *     // ... data to create a UserSalaryBonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSalaryBonus we want to update
     *   }
     * })
     */
    upsert<T extends UserSalaryBonusUpsertArgs>(args: SelectSubset<T, UserSalaryBonusUpsertArgs<ExtArgs>>): Prisma__UserSalaryBonusClient<$Result.GetResult<Prisma.$UserSalaryBonusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSalaryBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSalaryBonusCountArgs} args - Arguments to filter UserSalaryBonuses to count.
     * @example
     * // Count the number of UserSalaryBonuses
     * const count = await prisma.userSalaryBonus.count({
     *   where: {
     *     // ... the filter for the UserSalaryBonuses we want to count
     *   }
     * })
    **/
    count<T extends UserSalaryBonusCountArgs>(
      args?: Subset<T, UserSalaryBonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSalaryBonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSalaryBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSalaryBonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSalaryBonusAggregateArgs>(args: Subset<T, UserSalaryBonusAggregateArgs>): Prisma.PrismaPromise<GetUserSalaryBonusAggregateType<T>>

    /**
     * Group by UserSalaryBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSalaryBonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSalaryBonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSalaryBonusGroupByArgs['orderBy'] }
        : { orderBy?: UserSalaryBonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSalaryBonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSalaryBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSalaryBonus model
   */
  readonly fields: UserSalaryBonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSalaryBonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSalaryBonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSalaryBonus model
   */
  interface UserSalaryBonusFieldRefs {
    readonly id: FieldRef<"UserSalaryBonus", 'Int'>
    readonly user_id: FieldRef<"UserSalaryBonus", 'Int'>
    readonly amount: FieldRef<"UserSalaryBonus", 'Int'>
    readonly reason: FieldRef<"UserSalaryBonus", 'String'>
    readonly created_at: FieldRef<"UserSalaryBonus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSalaryBonus findUnique
   */
  export type UserSalaryBonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserSalaryBonus to fetch.
     */
    where: UserSalaryBonusWhereUniqueInput
  }

  /**
   * UserSalaryBonus findUniqueOrThrow
   */
  export type UserSalaryBonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserSalaryBonus to fetch.
     */
    where: UserSalaryBonusWhereUniqueInput
  }

  /**
   * UserSalaryBonus findFirst
   */
  export type UserSalaryBonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserSalaryBonus to fetch.
     */
    where?: UserSalaryBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSalaryBonuses to fetch.
     */
    orderBy?: UserSalaryBonusOrderByWithRelationInput | UserSalaryBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSalaryBonuses.
     */
    cursor?: UserSalaryBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSalaryBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSalaryBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSalaryBonuses.
     */
    distinct?: UserSalaryBonusScalarFieldEnum | UserSalaryBonusScalarFieldEnum[]
  }

  /**
   * UserSalaryBonus findFirstOrThrow
   */
  export type UserSalaryBonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserSalaryBonus to fetch.
     */
    where?: UserSalaryBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSalaryBonuses to fetch.
     */
    orderBy?: UserSalaryBonusOrderByWithRelationInput | UserSalaryBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSalaryBonuses.
     */
    cursor?: UserSalaryBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSalaryBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSalaryBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSalaryBonuses.
     */
    distinct?: UserSalaryBonusScalarFieldEnum | UserSalaryBonusScalarFieldEnum[]
  }

  /**
   * UserSalaryBonus findMany
   */
  export type UserSalaryBonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusInclude<ExtArgs> | null
    /**
     * Filter, which UserSalaryBonuses to fetch.
     */
    where?: UserSalaryBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSalaryBonuses to fetch.
     */
    orderBy?: UserSalaryBonusOrderByWithRelationInput | UserSalaryBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSalaryBonuses.
     */
    cursor?: UserSalaryBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSalaryBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSalaryBonuses.
     */
    skip?: number
    distinct?: UserSalaryBonusScalarFieldEnum | UserSalaryBonusScalarFieldEnum[]
  }

  /**
   * UserSalaryBonus create
   */
  export type UserSalaryBonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSalaryBonus.
     */
    data: XOR<UserSalaryBonusCreateInput, UserSalaryBonusUncheckedCreateInput>
  }

  /**
   * UserSalaryBonus createMany
   */
  export type UserSalaryBonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSalaryBonuses.
     */
    data: UserSalaryBonusCreateManyInput | UserSalaryBonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSalaryBonus createManyAndReturn
   */
  export type UserSalaryBonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * The data used to create many UserSalaryBonuses.
     */
    data: UserSalaryBonusCreateManyInput | UserSalaryBonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSalaryBonus update
   */
  export type UserSalaryBonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSalaryBonus.
     */
    data: XOR<UserSalaryBonusUpdateInput, UserSalaryBonusUncheckedUpdateInput>
    /**
     * Choose, which UserSalaryBonus to update.
     */
    where: UserSalaryBonusWhereUniqueInput
  }

  /**
   * UserSalaryBonus updateMany
   */
  export type UserSalaryBonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSalaryBonuses.
     */
    data: XOR<UserSalaryBonusUpdateManyMutationInput, UserSalaryBonusUncheckedUpdateManyInput>
    /**
     * Filter which UserSalaryBonuses to update
     */
    where?: UserSalaryBonusWhereInput
    /**
     * Limit how many UserSalaryBonuses to update.
     */
    limit?: number
  }

  /**
   * UserSalaryBonus updateManyAndReturn
   */
  export type UserSalaryBonusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * The data used to update UserSalaryBonuses.
     */
    data: XOR<UserSalaryBonusUpdateManyMutationInput, UserSalaryBonusUncheckedUpdateManyInput>
    /**
     * Filter which UserSalaryBonuses to update
     */
    where?: UserSalaryBonusWhereInput
    /**
     * Limit how many UserSalaryBonuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSalaryBonus upsert
   */
  export type UserSalaryBonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSalaryBonus to update in case it exists.
     */
    where: UserSalaryBonusWhereUniqueInput
    /**
     * In case the UserSalaryBonus found by the `where` argument doesn't exist, create a new UserSalaryBonus with this data.
     */
    create: XOR<UserSalaryBonusCreateInput, UserSalaryBonusUncheckedCreateInput>
    /**
     * In case the UserSalaryBonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSalaryBonusUpdateInput, UserSalaryBonusUncheckedUpdateInput>
  }

  /**
   * UserSalaryBonus delete
   */
  export type UserSalaryBonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusInclude<ExtArgs> | null
    /**
     * Filter which UserSalaryBonus to delete.
     */
    where: UserSalaryBonusWhereUniqueInput
  }

  /**
   * UserSalaryBonus deleteMany
   */
  export type UserSalaryBonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSalaryBonuses to delete
     */
    where?: UserSalaryBonusWhereInput
    /**
     * Limit how many UserSalaryBonuses to delete.
     */
    limit?: number
  }

  /**
   * UserSalaryBonus without action
   */
  export type UserSalaryBonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSalaryBonus
     */
    select?: UserSalaryBonusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSalaryBonus
     */
    omit?: UserSalaryBonusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSalaryBonusInclude<ExtArgs> | null
  }


  /**
   * Model LinkToken
   */

  export type AggregateLinkToken = {
    _count: LinkTokenCountAggregateOutputType | null
    _avg: LinkTokenAvgAggregateOutputType | null
    _sum: LinkTokenSumAggregateOutputType | null
    _min: LinkTokenMinAggregateOutputType | null
    _max: LinkTokenMaxAggregateOutputType | null
  }

  export type LinkTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LinkTokenSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LinkTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    expiresAt: Date | null
    used: boolean | null
  }

  export type LinkTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    userId: number | null
    expiresAt: Date | null
    used: boolean | null
  }

  export type LinkTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    used: number
    _all: number
  }


  export type LinkTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LinkTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LinkTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    used?: true
  }

  export type LinkTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    used?: true
  }

  export type LinkTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    used?: true
    _all?: true
  }

  export type LinkTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkToken to aggregate.
     */
    where?: LinkTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkTokens to fetch.
     */
    orderBy?: LinkTokenOrderByWithRelationInput | LinkTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LinkTokens
    **/
    _count?: true | LinkTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LinkTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LinkTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkTokenMaxAggregateInputType
  }

  export type GetLinkTokenAggregateType<T extends LinkTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateLinkToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinkToken[P]>
      : GetScalarType<T[P], AggregateLinkToken[P]>
  }




  export type LinkTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkTokenWhereInput
    orderBy?: LinkTokenOrderByWithAggregationInput | LinkTokenOrderByWithAggregationInput[]
    by: LinkTokenScalarFieldEnum[] | LinkTokenScalarFieldEnum
    having?: LinkTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkTokenCountAggregateInputType | true
    _avg?: LinkTokenAvgAggregateInputType
    _sum?: LinkTokenSumAggregateInputType
    _min?: LinkTokenMinAggregateInputType
    _max?: LinkTokenMaxAggregateInputType
  }

  export type LinkTokenGroupByOutputType = {
    id: number
    token: string
    userId: number
    expiresAt: Date
    used: boolean
    _count: LinkTokenCountAggregateOutputType | null
    _avg: LinkTokenAvgAggregateOutputType | null
    _sum: LinkTokenSumAggregateOutputType | null
    _min: LinkTokenMinAggregateOutputType | null
    _max: LinkTokenMaxAggregateOutputType | null
  }

  type GetLinkTokenGroupByPayload<T extends LinkTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkTokenGroupByOutputType[P]>
            : GetScalarType<T[P], LinkTokenGroupByOutputType[P]>
        }
      >
    >


  export type LinkTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    used?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkToken"]>

  export type LinkTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    used?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkToken"]>

  export type LinkTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    used?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkToken"]>

  export type LinkTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    used?: boolean
  }

  export type LinkTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "used", ExtArgs["result"]["linkToken"]>
  export type LinkTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LinkTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LinkTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LinkTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LinkToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      userId: number
      expiresAt: Date
      used: boolean
    }, ExtArgs["result"]["linkToken"]>
    composites: {}
  }

  type LinkTokenGetPayload<S extends boolean | null | undefined | LinkTokenDefaultArgs> = $Result.GetResult<Prisma.$LinkTokenPayload, S>

  type LinkTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LinkTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LinkTokenCountAggregateInputType | true
    }

  export interface LinkTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LinkToken'], meta: { name: 'LinkToken' } }
    /**
     * Find zero or one LinkToken that matches the filter.
     * @param {LinkTokenFindUniqueArgs} args - Arguments to find a LinkToken
     * @example
     * // Get one LinkToken
     * const linkToken = await prisma.linkToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinkTokenFindUniqueArgs>(args: SelectSubset<T, LinkTokenFindUniqueArgs<ExtArgs>>): Prisma__LinkTokenClient<$Result.GetResult<Prisma.$LinkTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LinkToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LinkTokenFindUniqueOrThrowArgs} args - Arguments to find a LinkToken
     * @example
     * // Get one LinkToken
     * const linkToken = await prisma.linkToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinkTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, LinkTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinkTokenClient<$Result.GetResult<Prisma.$LinkTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkTokenFindFirstArgs} args - Arguments to find a LinkToken
     * @example
     * // Get one LinkToken
     * const linkToken = await prisma.linkToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinkTokenFindFirstArgs>(args?: SelectSubset<T, LinkTokenFindFirstArgs<ExtArgs>>): Prisma__LinkTokenClient<$Result.GetResult<Prisma.$LinkTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkTokenFindFirstOrThrowArgs} args - Arguments to find a LinkToken
     * @example
     * // Get one LinkToken
     * const linkToken = await prisma.linkToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinkTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, LinkTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinkTokenClient<$Result.GetResult<Prisma.$LinkTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LinkTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LinkTokens
     * const linkTokens = await prisma.linkToken.findMany()
     * 
     * // Get first 10 LinkTokens
     * const linkTokens = await prisma.linkToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkTokenWithIdOnly = await prisma.linkToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinkTokenFindManyArgs>(args?: SelectSubset<T, LinkTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LinkToken.
     * @param {LinkTokenCreateArgs} args - Arguments to create a LinkToken.
     * @example
     * // Create one LinkToken
     * const LinkToken = await prisma.linkToken.create({
     *   data: {
     *     // ... data to create a LinkToken
     *   }
     * })
     * 
     */
    create<T extends LinkTokenCreateArgs>(args: SelectSubset<T, LinkTokenCreateArgs<ExtArgs>>): Prisma__LinkTokenClient<$Result.GetResult<Prisma.$LinkTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LinkTokens.
     * @param {LinkTokenCreateManyArgs} args - Arguments to create many LinkTokens.
     * @example
     * // Create many LinkTokens
     * const linkToken = await prisma.linkToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinkTokenCreateManyArgs>(args?: SelectSubset<T, LinkTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LinkTokens and returns the data saved in the database.
     * @param {LinkTokenCreateManyAndReturnArgs} args - Arguments to create many LinkTokens.
     * @example
     * // Create many LinkTokens
     * const linkToken = await prisma.linkToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LinkTokens and only return the `id`
     * const linkTokenWithIdOnly = await prisma.linkToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LinkTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, LinkTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LinkToken.
     * @param {LinkTokenDeleteArgs} args - Arguments to delete one LinkToken.
     * @example
     * // Delete one LinkToken
     * const LinkToken = await prisma.linkToken.delete({
     *   where: {
     *     // ... filter to delete one LinkToken
     *   }
     * })
     * 
     */
    delete<T extends LinkTokenDeleteArgs>(args: SelectSubset<T, LinkTokenDeleteArgs<ExtArgs>>): Prisma__LinkTokenClient<$Result.GetResult<Prisma.$LinkTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LinkToken.
     * @param {LinkTokenUpdateArgs} args - Arguments to update one LinkToken.
     * @example
     * // Update one LinkToken
     * const linkToken = await prisma.linkToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinkTokenUpdateArgs>(args: SelectSubset<T, LinkTokenUpdateArgs<ExtArgs>>): Prisma__LinkTokenClient<$Result.GetResult<Prisma.$LinkTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LinkTokens.
     * @param {LinkTokenDeleteManyArgs} args - Arguments to filter LinkTokens to delete.
     * @example
     * // Delete a few LinkTokens
     * const { count } = await prisma.linkToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinkTokenDeleteManyArgs>(args?: SelectSubset<T, LinkTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LinkTokens
     * const linkToken = await prisma.linkToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinkTokenUpdateManyArgs>(args: SelectSubset<T, LinkTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkTokens and returns the data updated in the database.
     * @param {LinkTokenUpdateManyAndReturnArgs} args - Arguments to update many LinkTokens.
     * @example
     * // Update many LinkTokens
     * const linkToken = await prisma.linkToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LinkTokens and only return the `id`
     * const linkTokenWithIdOnly = await prisma.linkToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LinkTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, LinkTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LinkToken.
     * @param {LinkTokenUpsertArgs} args - Arguments to update or create a LinkToken.
     * @example
     * // Update or create a LinkToken
     * const linkToken = await prisma.linkToken.upsert({
     *   create: {
     *     // ... data to create a LinkToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LinkToken we want to update
     *   }
     * })
     */
    upsert<T extends LinkTokenUpsertArgs>(args: SelectSubset<T, LinkTokenUpsertArgs<ExtArgs>>): Prisma__LinkTokenClient<$Result.GetResult<Prisma.$LinkTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LinkTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkTokenCountArgs} args - Arguments to filter LinkTokens to count.
     * @example
     * // Count the number of LinkTokens
     * const count = await prisma.linkToken.count({
     *   where: {
     *     // ... the filter for the LinkTokens we want to count
     *   }
     * })
    **/
    count<T extends LinkTokenCountArgs>(
      args?: Subset<T, LinkTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LinkToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkTokenAggregateArgs>(args: Subset<T, LinkTokenAggregateArgs>): Prisma.PrismaPromise<GetLinkTokenAggregateType<T>>

    /**
     * Group by LinkToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkTokenGroupByArgs['orderBy'] }
        : { orderBy?: LinkTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LinkToken model
   */
  readonly fields: LinkTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LinkToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinkTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LinkToken model
   */
  interface LinkTokenFieldRefs {
    readonly id: FieldRef<"LinkToken", 'Int'>
    readonly token: FieldRef<"LinkToken", 'String'>
    readonly userId: FieldRef<"LinkToken", 'Int'>
    readonly expiresAt: FieldRef<"LinkToken", 'DateTime'>
    readonly used: FieldRef<"LinkToken", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * LinkToken findUnique
   */
  export type LinkTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenInclude<ExtArgs> | null
    /**
     * Filter, which LinkToken to fetch.
     */
    where: LinkTokenWhereUniqueInput
  }

  /**
   * LinkToken findUniqueOrThrow
   */
  export type LinkTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenInclude<ExtArgs> | null
    /**
     * Filter, which LinkToken to fetch.
     */
    where: LinkTokenWhereUniqueInput
  }

  /**
   * LinkToken findFirst
   */
  export type LinkTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenInclude<ExtArgs> | null
    /**
     * Filter, which LinkToken to fetch.
     */
    where?: LinkTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkTokens to fetch.
     */
    orderBy?: LinkTokenOrderByWithRelationInput | LinkTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkTokens.
     */
    cursor?: LinkTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkTokens.
     */
    distinct?: LinkTokenScalarFieldEnum | LinkTokenScalarFieldEnum[]
  }

  /**
   * LinkToken findFirstOrThrow
   */
  export type LinkTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenInclude<ExtArgs> | null
    /**
     * Filter, which LinkToken to fetch.
     */
    where?: LinkTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkTokens to fetch.
     */
    orderBy?: LinkTokenOrderByWithRelationInput | LinkTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkTokens.
     */
    cursor?: LinkTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkTokens.
     */
    distinct?: LinkTokenScalarFieldEnum | LinkTokenScalarFieldEnum[]
  }

  /**
   * LinkToken findMany
   */
  export type LinkTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenInclude<ExtArgs> | null
    /**
     * Filter, which LinkTokens to fetch.
     */
    where?: LinkTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkTokens to fetch.
     */
    orderBy?: LinkTokenOrderByWithRelationInput | LinkTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LinkTokens.
     */
    cursor?: LinkTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkTokens.
     */
    skip?: number
    distinct?: LinkTokenScalarFieldEnum | LinkTokenScalarFieldEnum[]
  }

  /**
   * LinkToken create
   */
  export type LinkTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a LinkToken.
     */
    data: XOR<LinkTokenCreateInput, LinkTokenUncheckedCreateInput>
  }

  /**
   * LinkToken createMany
   */
  export type LinkTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LinkTokens.
     */
    data: LinkTokenCreateManyInput | LinkTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LinkToken createManyAndReturn
   */
  export type LinkTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * The data used to create many LinkTokens.
     */
    data: LinkTokenCreateManyInput | LinkTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkToken update
   */
  export type LinkTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a LinkToken.
     */
    data: XOR<LinkTokenUpdateInput, LinkTokenUncheckedUpdateInput>
    /**
     * Choose, which LinkToken to update.
     */
    where: LinkTokenWhereUniqueInput
  }

  /**
   * LinkToken updateMany
   */
  export type LinkTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LinkTokens.
     */
    data: XOR<LinkTokenUpdateManyMutationInput, LinkTokenUncheckedUpdateManyInput>
    /**
     * Filter which LinkTokens to update
     */
    where?: LinkTokenWhereInput
    /**
     * Limit how many LinkTokens to update.
     */
    limit?: number
  }

  /**
   * LinkToken updateManyAndReturn
   */
  export type LinkTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * The data used to update LinkTokens.
     */
    data: XOR<LinkTokenUpdateManyMutationInput, LinkTokenUncheckedUpdateManyInput>
    /**
     * Filter which LinkTokens to update
     */
    where?: LinkTokenWhereInput
    /**
     * Limit how many LinkTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkToken upsert
   */
  export type LinkTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the LinkToken to update in case it exists.
     */
    where: LinkTokenWhereUniqueInput
    /**
     * In case the LinkToken found by the `where` argument doesn't exist, create a new LinkToken with this data.
     */
    create: XOR<LinkTokenCreateInput, LinkTokenUncheckedCreateInput>
    /**
     * In case the LinkToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkTokenUpdateInput, LinkTokenUncheckedUpdateInput>
  }

  /**
   * LinkToken delete
   */
  export type LinkTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenInclude<ExtArgs> | null
    /**
     * Filter which LinkToken to delete.
     */
    where: LinkTokenWhereUniqueInput
  }

  /**
   * LinkToken deleteMany
   */
  export type LinkTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkTokens to delete
     */
    where?: LinkTokenWhereInput
    /**
     * Limit how many LinkTokens to delete.
     */
    limit?: number
  }

  /**
   * LinkToken without action
   */
  export type LinkTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkToken
     */
    select?: LinkTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkToken
     */
    omit?: LinkTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkTokenInclude<ExtArgs> | null
  }


  /**
   * Model News
   */

  export type AggregateNews = {
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  export type NewsAvgAggregateOutputType = {
    id: number | null
  }

  export type NewsSumAggregateOutputType = {
    id: number | null
  }

  export type NewsMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsAvgAggregateInputType = {
    id?: true
  }

  export type NewsSumAggregateInputType = {
    id?: true
  }

  export type NewsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to aggregate.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned News
    **/
    _count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }




  export type NewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsWhereInput
    orderBy?: NewsOrderByWithAggregationInput | NewsOrderByWithAggregationInput[]
    by: NewsScalarFieldEnum[] | NewsScalarFieldEnum
    having?: NewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsCountAggregateInputType | true
    _avg?: NewsAvgAggregateInputType
    _sum?: NewsSumAggregateInputType
    _min?: NewsMinAggregateInputType
    _max?: NewsMaxAggregateInputType
  }

  export type NewsGroupByOutputType = {
    id: number
    title: string
    content: string
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  type GetNewsGroupByPayload<T extends NewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsGroupByOutputType[P]>
            : GetScalarType<T[P], NewsGroupByOutputType[P]>
        }
      >
    >


  export type NewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["news"]>

  export type NewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["news"]>

  export type NewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["news"]>

  export type NewsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "date" | "createdAt" | "updatedAt", ExtArgs["result"]["news"]>

  export type $NewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "News"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["news"]>
    composites: {}
  }

  type NewsGetPayload<S extends boolean | null | undefined | NewsDefaultArgs> = $Result.GetResult<Prisma.$NewsPayload, S>

  type NewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsCountAggregateInputType | true
    }

  export interface NewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['News'], meta: { name: 'News' } }
    /**
     * Find zero or one News that matches the filter.
     * @param {NewsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsFindUniqueArgs>(args: SelectSubset<T, NewsFindUniqueArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one News that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsFindUniqueOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsFindFirstArgs>(args?: SelectSubset<T, NewsFindFirstArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first News that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindFirstOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsWithIdOnly = await prisma.news.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsFindManyArgs>(args?: SelectSubset<T, NewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a News.
     * @param {NewsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
     */
    create<T extends NewsCreateArgs>(args: SelectSubset<T, NewsCreateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many News.
     * @param {NewsCreateManyArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsCreateManyArgs>(args?: SelectSubset<T, NewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many News and returns the data saved in the database.
     * @param {NewsCreateManyAndReturnArgs} args - Arguments to create many News.
     * @example
     * // Create many News
     * const news = await prisma.news.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many News and only return the `id`
     * const newsWithIdOnly = await prisma.news.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a News.
     * @param {NewsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
     */
    delete<T extends NewsDeleteArgs>(args: SelectSubset<T, NewsDeleteArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one News.
     * @param {NewsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsUpdateArgs>(args: SelectSubset<T, NewsUpdateArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more News.
     * @param {NewsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsDeleteManyArgs>(args?: SelectSubset<T, NewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsUpdateManyArgs>(args: SelectSubset<T, NewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News and returns the data updated in the database.
     * @param {NewsUpdateManyAndReturnArgs} args - Arguments to update many News.
     * @example
     * // Update many News
     * const news = await prisma.news.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more News and only return the `id`
     * const newsWithIdOnly = await prisma.news.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NewsUpdateManyAndReturnArgs>(args: SelectSubset<T, NewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one News.
     * @param {NewsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
     */
    upsert<T extends NewsUpsertArgs>(args: SelectSubset<T, NewsUpsertArgs<ExtArgs>>): Prisma__NewsClient<$Result.GetResult<Prisma.$NewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends NewsCountArgs>(
      args?: Subset<T, NewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): Prisma.PrismaPromise<GetNewsAggregateType<T>>

    /**
     * Group by News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsGroupByArgs['orderBy'] }
        : { orderBy?: NewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the News model
   */
  readonly fields: NewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for News.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the News model
   */
  interface NewsFieldRefs {
    readonly id: FieldRef<"News", 'Int'>
    readonly title: FieldRef<"News", 'String'>
    readonly content: FieldRef<"News", 'String'>
    readonly date: FieldRef<"News", 'DateTime'>
    readonly createdAt: FieldRef<"News", 'DateTime'>
    readonly updatedAt: FieldRef<"News", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * News findUnique
   */
  export type NewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findUniqueOrThrow
   */
  export type NewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News findFirst
   */
  export type NewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findFirstOrThrow
   */
  export type NewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of News.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News findMany
   */
  export type NewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter, which News to fetch.
     */
    where?: NewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of News to fetch.
     */
    orderBy?: NewsOrderByWithRelationInput | NewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing News.
     */
    cursor?: NewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` News from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` News.
     */
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }

  /**
   * News create
   */
  export type NewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data needed to create a News.
     */
    data: XOR<NewsCreateInput, NewsUncheckedCreateInput>
  }

  /**
   * News createMany
   */
  export type NewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * News createManyAndReturn
   */
  export type NewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data used to create many News.
     */
    data: NewsCreateManyInput | NewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * News update
   */
  export type NewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data needed to update a News.
     */
    data: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
    /**
     * Choose, which News to update.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News updateMany
   */
  export type NewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update News.
     */
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to update.
     */
    limit?: number
  }

  /**
   * News updateManyAndReturn
   */
  export type NewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The data used to update News.
     */
    data: XOR<NewsUpdateManyMutationInput, NewsUncheckedUpdateManyInput>
    /**
     * Filter which News to update
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to update.
     */
    limit?: number
  }

  /**
   * News upsert
   */
  export type NewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * The filter to search for the News to update in case it exists.
     */
    where: NewsWhereUniqueInput
    /**
     * In case the News found by the `where` argument doesn't exist, create a new News with this data.
     */
    create: XOR<NewsCreateInput, NewsUncheckedCreateInput>
    /**
     * In case the News was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsUpdateInput, NewsUncheckedUpdateInput>
  }

  /**
   * News delete
   */
  export type NewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
    /**
     * Filter which News to delete.
     */
    where: NewsWhereUniqueInput
  }

  /**
   * News deleteMany
   */
  export type NewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which News to delete
     */
    where?: NewsWhereInput
    /**
     * Limit how many News to delete.
     */
    limit?: number
  }

  /**
   * News without action
   */
  export type NewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News
     */
    select?: NewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the News
     */
    omit?: NewsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    class: 'class',
    secondary_class: 'secondary_class',
    class_gear_score: 'class_gear_score',
    secondary_class_gear_score: 'secondary_class_gear_score',
    vk_name: 'vk_name',
    active: 'active',
    is_eligible_for_salary: 'is_eligible_for_salary',
    joined_at: 'joined_at',
    created_at: 'created_at',
    salaryBonus: 'salaryBonus',
    googleId: 'googleId',
    vkId: 'vkId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserTagsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    tag: 'tag',
    created_at: 'created_at'
  };

  export type UserTagsScalarFieldEnum = (typeof UserTagsScalarFieldEnum)[keyof typeof UserTagsScalarFieldEnum]


  export const UserInventoryScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    type: 'type',
    name: 'name',
    quality: 'quality',
    created_at: 'created_at',
    quantity: 'quantity'
  };

  export type UserInventoryScalarFieldEnum = (typeof UserInventoryScalarFieldEnum)[keyof typeof UserInventoryScalarFieldEnum]


  export const TasksScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    completed_at: 'completed_at',
    created_at: 'created_at'
  };

  export type TasksScalarFieldEnum = (typeof TasksScalarFieldEnum)[keyof typeof TasksScalarFieldEnum]


  export const RaidScalarFieldEnum: {
    id: 'id',
    type: 'type',
    start_date: 'start_date',
    created_at: 'created_at',
    is_pvp: 'is_pvp',
    is_pvp_long: 'is_pvp_long',
    dkp_summary: 'dkp_summary'
  };

  export type RaidScalarFieldEnum = (typeof RaidScalarFieldEnum)[keyof typeof RaidScalarFieldEnum]


  export const BossScalarFieldEnum: {
    id: 'id',
    boss_name: 'boss_name',
    dkp_points: 'dkp_points',
    category: 'category'
  };

  export type BossScalarFieldEnum = (typeof BossScalarFieldEnum)[keyof typeof BossScalarFieldEnum]


  export const RaidBossScalarFieldEnum: {
    raid_id: 'raid_id',
    boss_id: 'boss_id'
  };

  export type RaidBossScalarFieldEnum = (typeof RaidBossScalarFieldEnum)[keyof typeof RaidBossScalarFieldEnum]


  export const RaidAttendanceScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    raid_id: 'raid_id',
    created_at: 'created_at'
  };

  export type RaidAttendanceScalarFieldEnum = (typeof RaidAttendanceScalarFieldEnum)[keyof typeof RaidAttendanceScalarFieldEnum]


  export const ItemTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price'
  };

  export type ItemTypeScalarFieldEnum = (typeof ItemTypeScalarFieldEnum)[keyof typeof ItemTypeScalarFieldEnum]


  export const LootScalarFieldEnum: {
    id: 'id',
    status: 'status',
    sold_at: 'sold_at',
    sold_to: 'sold_to',
    comment: 'comment',
    created_at: 'created_at',
    source: 'source',
    acquired_at: 'acquired_at',
    itemTypeId: 'itemTypeId',
    sold_to_user_id: 'sold_to_user_id',
    quantity: 'quantity',
    price: 'price'
  };

  export type LootScalarFieldEnum = (typeof LootScalarFieldEnum)[keyof typeof LootScalarFieldEnum]


  export const TasksUserScalarFieldEnum: {
    tasks_user_id: 'tasks_user_id',
    user_id: 'user_id'
  };

  export type TasksUserScalarFieldEnum = (typeof TasksUserScalarFieldEnum)[keyof typeof TasksUserScalarFieldEnum]


  export const LootQueueScalarFieldEnum: {
    id: 'id',
    itemTypeId: 'itemTypeId',
    userId: 'userId',
    created_at: 'created_at',
    status: 'status',
    synth_target: 'synth_target',
    remaining: 'remaining',
    required: 'required',
    delivered: 'delivered'
  };

  export type LootQueueScalarFieldEnum = (typeof LootQueueScalarFieldEnum)[keyof typeof LootQueueScalarFieldEnum]


  export const GivenAwayLootScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    date: 'date',
    comment: 'comment',
    created_at: 'created_at',
    status: 'status'
  };

  export type GivenAwayLootScalarFieldEnum = (typeof GivenAwayLootScalarFieldEnum)[keyof typeof GivenAwayLootScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    date: 'date',
    amount: 'amount',
    target: 'target',
    source: 'source',
    comment: 'comment'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const GuildFundsScalarFieldEnum: {
    id: 'id',
    year: 'year',
    month: 'month',
    totalIncome: 'totalIncome',
    totalExpenses: 'totalExpenses',
    profit: 'profit',
    salaryBudget: 'salaryBudget',
    treasuryLeft: 'treasuryLeft'
  };

  export type GuildFundsScalarFieldEnum = (typeof GuildFundsScalarFieldEnum)[keyof typeof GuildFundsScalarFieldEnum]


  export const SalaryScalarFieldEnum: {
    id: 'id',
    year: 'year',
    month: 'month',
    userId: 'userId',
    amount: 'amount',
    bonus: 'bonus',
    total: 'total'
  };

  export type SalaryScalarFieldEnum = (typeof SalaryScalarFieldEnum)[keyof typeof SalaryScalarFieldEnum]


  export const UserSalaryBonusScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    amount: 'amount',
    reason: 'reason',
    created_at: 'created_at'
  };

  export type UserSalaryBonusScalarFieldEnum = (typeof UserSalaryBonusScalarFieldEnum)[keyof typeof UserSalaryBonusScalarFieldEnum]


  export const LinkTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    used: 'used'
  };

  export type LinkTokenScalarFieldEnum = (typeof LinkTokenScalarFieldEnum)[keyof typeof LinkTokenScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    class?: StringNullableFilter<"User"> | string | null
    secondary_class?: StringNullableFilter<"User"> | string | null
    class_gear_score?: IntNullableFilter<"User"> | number | null
    secondary_class_gear_score?: IntNullableFilter<"User"> | number | null
    vk_name?: StringNullableFilter<"User"> | string | null
    active?: BoolFilter<"User"> | boolean
    is_eligible_for_salary?: BoolFilter<"User"> | boolean
    joined_at?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    salaryBonus?: IntNullableFilter<"User"> | number | null
    googleId?: StringNullableFilter<"User"> | string | null
    vkId?: StringNullableFilter<"User"> | string | null
    salaries?: SalaryListRelationFilter
    givenAwayLoot?: GivenAwayLootListRelationFilter
    soldLoot?: LootListRelationFilter
    lootQueue?: LootQueueListRelationFilter
    raidAttendance?: RaidAttendanceListRelationFilter
    tasks?: TasksListRelationFilter
    tasksAssigned?: TasksUserListRelationFilter
    inventory?: UserInventoryListRelationFilter
    salaryBonuses?: UserSalaryBonusListRelationFilter
    tags?: UserTagsListRelationFilter
    linkTokens?: LinkTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    class?: SortOrderInput | SortOrder
    secondary_class?: SortOrderInput | SortOrder
    class_gear_score?: SortOrderInput | SortOrder
    secondary_class_gear_score?: SortOrderInput | SortOrder
    vk_name?: SortOrderInput | SortOrder
    active?: SortOrder
    is_eligible_for_salary?: SortOrder
    joined_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    salaryBonus?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    vkId?: SortOrderInput | SortOrder
    salaries?: SalaryOrderByRelationAggregateInput
    givenAwayLoot?: GivenAwayLootOrderByRelationAggregateInput
    soldLoot?: LootOrderByRelationAggregateInput
    lootQueue?: LootQueueOrderByRelationAggregateInput
    raidAttendance?: RaidAttendanceOrderByRelationAggregateInput
    tasks?: TasksOrderByRelationAggregateInput
    tasksAssigned?: TasksUserOrderByRelationAggregateInput
    inventory?: UserInventoryOrderByRelationAggregateInput
    salaryBonuses?: UserSalaryBonusOrderByRelationAggregateInput
    tags?: UserTagsOrderByRelationAggregateInput
    linkTokens?: LinkTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    googleId?: string
    vkId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    class?: StringNullableFilter<"User"> | string | null
    secondary_class?: StringNullableFilter<"User"> | string | null
    class_gear_score?: IntNullableFilter<"User"> | number | null
    secondary_class_gear_score?: IntNullableFilter<"User"> | number | null
    vk_name?: StringNullableFilter<"User"> | string | null
    active?: BoolFilter<"User"> | boolean
    is_eligible_for_salary?: BoolFilter<"User"> | boolean
    joined_at?: DateTimeNullableFilter<"User"> | Date | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    salaryBonus?: IntNullableFilter<"User"> | number | null
    salaries?: SalaryListRelationFilter
    givenAwayLoot?: GivenAwayLootListRelationFilter
    soldLoot?: LootListRelationFilter
    lootQueue?: LootQueueListRelationFilter
    raidAttendance?: RaidAttendanceListRelationFilter
    tasks?: TasksListRelationFilter
    tasksAssigned?: TasksUserListRelationFilter
    inventory?: UserInventoryListRelationFilter
    salaryBonuses?: UserSalaryBonusListRelationFilter
    tags?: UserTagsListRelationFilter
    linkTokens?: LinkTokenListRelationFilter
  }, "id" | "googleId" | "vkId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    class?: SortOrderInput | SortOrder
    secondary_class?: SortOrderInput | SortOrder
    class_gear_score?: SortOrderInput | SortOrder
    secondary_class_gear_score?: SortOrderInput | SortOrder
    vk_name?: SortOrderInput | SortOrder
    active?: SortOrder
    is_eligible_for_salary?: SortOrder
    joined_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    salaryBonus?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    vkId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    class?: StringNullableWithAggregatesFilter<"User"> | string | null
    secondary_class?: StringNullableWithAggregatesFilter<"User"> | string | null
    class_gear_score?: IntNullableWithAggregatesFilter<"User"> | number | null
    secondary_class_gear_score?: IntNullableWithAggregatesFilter<"User"> | number | null
    vk_name?: StringNullableWithAggregatesFilter<"User"> | string | null
    active?: BoolWithAggregatesFilter<"User"> | boolean
    is_eligible_for_salary?: BoolWithAggregatesFilter<"User"> | boolean
    joined_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    salaryBonus?: IntNullableWithAggregatesFilter<"User"> | number | null
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    vkId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserTagsWhereInput = {
    AND?: UserTagsWhereInput | UserTagsWhereInput[]
    OR?: UserTagsWhereInput[]
    NOT?: UserTagsWhereInput | UserTagsWhereInput[]
    id?: IntFilter<"UserTags"> | number
    user_id?: IntFilter<"UserTags"> | number
    tag?: StringFilter<"UserTags"> | string
    created_at?: DateTimeFilter<"UserTags"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserTagsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    tag?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserTagsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserTagsWhereInput | UserTagsWhereInput[]
    OR?: UserTagsWhereInput[]
    NOT?: UserTagsWhereInput | UserTagsWhereInput[]
    user_id?: IntFilter<"UserTags"> | number
    tag?: StringFilter<"UserTags"> | string
    created_at?: DateTimeFilter<"UserTags"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserTagsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    tag?: SortOrder
    created_at?: SortOrder
    _count?: UserTagsCountOrderByAggregateInput
    _avg?: UserTagsAvgOrderByAggregateInput
    _max?: UserTagsMaxOrderByAggregateInput
    _min?: UserTagsMinOrderByAggregateInput
    _sum?: UserTagsSumOrderByAggregateInput
  }

  export type UserTagsScalarWhereWithAggregatesInput = {
    AND?: UserTagsScalarWhereWithAggregatesInput | UserTagsScalarWhereWithAggregatesInput[]
    OR?: UserTagsScalarWhereWithAggregatesInput[]
    NOT?: UserTagsScalarWhereWithAggregatesInput | UserTagsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserTags"> | number
    user_id?: IntWithAggregatesFilter<"UserTags"> | number
    tag?: StringWithAggregatesFilter<"UserTags"> | string
    created_at?: DateTimeWithAggregatesFilter<"UserTags"> | Date | string
  }

  export type UserInventoryWhereInput = {
    AND?: UserInventoryWhereInput | UserInventoryWhereInput[]
    OR?: UserInventoryWhereInput[]
    NOT?: UserInventoryWhereInput | UserInventoryWhereInput[]
    id?: IntFilter<"UserInventory"> | number
    user_id?: IntFilter<"UserInventory"> | number
    type?: StringNullableFilter<"UserInventory"> | string | null
    name?: StringNullableFilter<"UserInventory"> | string | null
    quality?: StringNullableFilter<"UserInventory"> | string | null
    created_at?: DateTimeFilter<"UserInventory"> | Date | string
    quantity?: IntNullableFilter<"UserInventory"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserInventoryOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    quality?: SortOrderInput | SortOrder
    created_at?: SortOrder
    quantity?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserInventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserInventoryWhereInput | UserInventoryWhereInput[]
    OR?: UserInventoryWhereInput[]
    NOT?: UserInventoryWhereInput | UserInventoryWhereInput[]
    user_id?: IntFilter<"UserInventory"> | number
    type?: StringNullableFilter<"UserInventory"> | string | null
    name?: StringNullableFilter<"UserInventory"> | string | null
    quality?: StringNullableFilter<"UserInventory"> | string | null
    created_at?: DateTimeFilter<"UserInventory"> | Date | string
    quantity?: IntNullableFilter<"UserInventory"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserInventoryOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    quality?: SortOrderInput | SortOrder
    created_at?: SortOrder
    quantity?: SortOrderInput | SortOrder
    _count?: UserInventoryCountOrderByAggregateInput
    _avg?: UserInventoryAvgOrderByAggregateInput
    _max?: UserInventoryMaxOrderByAggregateInput
    _min?: UserInventoryMinOrderByAggregateInput
    _sum?: UserInventorySumOrderByAggregateInput
  }

  export type UserInventoryScalarWhereWithAggregatesInput = {
    AND?: UserInventoryScalarWhereWithAggregatesInput | UserInventoryScalarWhereWithAggregatesInput[]
    OR?: UserInventoryScalarWhereWithAggregatesInput[]
    NOT?: UserInventoryScalarWhereWithAggregatesInput | UserInventoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserInventory"> | number
    user_id?: IntWithAggregatesFilter<"UserInventory"> | number
    type?: StringNullableWithAggregatesFilter<"UserInventory"> | string | null
    name?: StringNullableWithAggregatesFilter<"UserInventory"> | string | null
    quality?: StringNullableWithAggregatesFilter<"UserInventory"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"UserInventory"> | Date | string
    quantity?: IntNullableWithAggregatesFilter<"UserInventory"> | number | null
  }

  export type TasksWhereInput = {
    AND?: TasksWhereInput | TasksWhereInput[]
    OR?: TasksWhereInput[]
    NOT?: TasksWhereInput | TasksWhereInput[]
    id?: IntFilter<"Tasks"> | number
    user_id?: IntFilter<"Tasks"> | number
    name?: StringNullableFilter<"Tasks"> | string | null
    completed_at?: DateTimeNullableFilter<"Tasks"> | Date | string | null
    created_at?: DateTimeFilter<"Tasks"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: TasksUserListRelationFilter
  }

  export type TasksOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
    assignedTo?: TasksUserOrderByRelationAggregateInput
  }

  export type TasksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TasksWhereInput | TasksWhereInput[]
    OR?: TasksWhereInput[]
    NOT?: TasksWhereInput | TasksWhereInput[]
    user_id?: IntFilter<"Tasks"> | number
    name?: StringNullableFilter<"Tasks"> | string | null
    completed_at?: DateTimeNullableFilter<"Tasks"> | Date | string | null
    created_at?: DateTimeFilter<"Tasks"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignedTo?: TasksUserListRelationFilter
  }, "id">

  export type TasksOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: TasksCountOrderByAggregateInput
    _avg?: TasksAvgOrderByAggregateInput
    _max?: TasksMaxOrderByAggregateInput
    _min?: TasksMinOrderByAggregateInput
    _sum?: TasksSumOrderByAggregateInput
  }

  export type TasksScalarWhereWithAggregatesInput = {
    AND?: TasksScalarWhereWithAggregatesInput | TasksScalarWhereWithAggregatesInput[]
    OR?: TasksScalarWhereWithAggregatesInput[]
    NOT?: TasksScalarWhereWithAggregatesInput | TasksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tasks"> | number
    user_id?: IntWithAggregatesFilter<"Tasks"> | number
    name?: StringNullableWithAggregatesFilter<"Tasks"> | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"Tasks"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"Tasks"> | Date | string
  }

  export type RaidWhereInput = {
    AND?: RaidWhereInput | RaidWhereInput[]
    OR?: RaidWhereInput[]
    NOT?: RaidWhereInput | RaidWhereInput[]
    id?: IntFilter<"Raid"> | number
    type?: StringNullableFilter<"Raid"> | string | null
    start_date?: DateTimeNullableFilter<"Raid"> | Date | string | null
    created_at?: DateTimeFilter<"Raid"> | Date | string
    is_pvp?: BoolNullableFilter<"Raid"> | boolean | null
    is_pvp_long?: BoolNullableFilter<"Raid"> | boolean | null
    dkp_summary?: IntNullableFilter<"Raid"> | number | null
    attendance?: RaidAttendanceListRelationFilter
    raidBosses?: RaidBossListRelationFilter
  }

  export type RaidOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    is_pvp?: SortOrderInput | SortOrder
    is_pvp_long?: SortOrderInput | SortOrder
    dkp_summary?: SortOrderInput | SortOrder
    attendance?: RaidAttendanceOrderByRelationAggregateInput
    raidBosses?: RaidBossOrderByRelationAggregateInput
  }

  export type RaidWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RaidWhereInput | RaidWhereInput[]
    OR?: RaidWhereInput[]
    NOT?: RaidWhereInput | RaidWhereInput[]
    type?: StringNullableFilter<"Raid"> | string | null
    start_date?: DateTimeNullableFilter<"Raid"> | Date | string | null
    created_at?: DateTimeFilter<"Raid"> | Date | string
    is_pvp?: BoolNullableFilter<"Raid"> | boolean | null
    is_pvp_long?: BoolNullableFilter<"Raid"> | boolean | null
    dkp_summary?: IntNullableFilter<"Raid"> | number | null
    attendance?: RaidAttendanceListRelationFilter
    raidBosses?: RaidBossListRelationFilter
  }, "id">

  export type RaidOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    is_pvp?: SortOrderInput | SortOrder
    is_pvp_long?: SortOrderInput | SortOrder
    dkp_summary?: SortOrderInput | SortOrder
    _count?: RaidCountOrderByAggregateInput
    _avg?: RaidAvgOrderByAggregateInput
    _max?: RaidMaxOrderByAggregateInput
    _min?: RaidMinOrderByAggregateInput
    _sum?: RaidSumOrderByAggregateInput
  }

  export type RaidScalarWhereWithAggregatesInput = {
    AND?: RaidScalarWhereWithAggregatesInput | RaidScalarWhereWithAggregatesInput[]
    OR?: RaidScalarWhereWithAggregatesInput[]
    NOT?: RaidScalarWhereWithAggregatesInput | RaidScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Raid"> | number
    type?: StringNullableWithAggregatesFilter<"Raid"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"Raid"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"Raid"> | Date | string
    is_pvp?: BoolNullableWithAggregatesFilter<"Raid"> | boolean | null
    is_pvp_long?: BoolNullableWithAggregatesFilter<"Raid"> | boolean | null
    dkp_summary?: IntNullableWithAggregatesFilter<"Raid"> | number | null
  }

  export type BossWhereInput = {
    AND?: BossWhereInput | BossWhereInput[]
    OR?: BossWhereInput[]
    NOT?: BossWhereInput | BossWhereInput[]
    id?: IntFilter<"Boss"> | number
    boss_name?: StringFilter<"Boss"> | string
    dkp_points?: IntFilter<"Boss"> | number
    category?: StringNullableFilter<"Boss"> | string | null
    raidBosses?: RaidBossListRelationFilter
  }

  export type BossOrderByWithRelationInput = {
    id?: SortOrder
    boss_name?: SortOrder
    dkp_points?: SortOrder
    category?: SortOrderInput | SortOrder
    raidBosses?: RaidBossOrderByRelationAggregateInput
  }

  export type BossWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BossWhereInput | BossWhereInput[]
    OR?: BossWhereInput[]
    NOT?: BossWhereInput | BossWhereInput[]
    boss_name?: StringFilter<"Boss"> | string
    dkp_points?: IntFilter<"Boss"> | number
    category?: StringNullableFilter<"Boss"> | string | null
    raidBosses?: RaidBossListRelationFilter
  }, "id">

  export type BossOrderByWithAggregationInput = {
    id?: SortOrder
    boss_name?: SortOrder
    dkp_points?: SortOrder
    category?: SortOrderInput | SortOrder
    _count?: BossCountOrderByAggregateInput
    _avg?: BossAvgOrderByAggregateInput
    _max?: BossMaxOrderByAggregateInput
    _min?: BossMinOrderByAggregateInput
    _sum?: BossSumOrderByAggregateInput
  }

  export type BossScalarWhereWithAggregatesInput = {
    AND?: BossScalarWhereWithAggregatesInput | BossScalarWhereWithAggregatesInput[]
    OR?: BossScalarWhereWithAggregatesInput[]
    NOT?: BossScalarWhereWithAggregatesInput | BossScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Boss"> | number
    boss_name?: StringWithAggregatesFilter<"Boss"> | string
    dkp_points?: IntWithAggregatesFilter<"Boss"> | number
    category?: StringNullableWithAggregatesFilter<"Boss"> | string | null
  }

  export type RaidBossWhereInput = {
    AND?: RaidBossWhereInput | RaidBossWhereInput[]
    OR?: RaidBossWhereInput[]
    NOT?: RaidBossWhereInput | RaidBossWhereInput[]
    raid_id?: IntFilter<"RaidBoss"> | number
    boss_id?: IntFilter<"RaidBoss"> | number
    boss?: XOR<BossScalarRelationFilter, BossWhereInput>
    raid?: XOR<RaidScalarRelationFilter, RaidWhereInput>
  }

  export type RaidBossOrderByWithRelationInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
    boss?: BossOrderByWithRelationInput
    raid?: RaidOrderByWithRelationInput
  }

  export type RaidBossWhereUniqueInput = Prisma.AtLeast<{
    raid_id_boss_id?: RaidBossRaid_idBoss_idCompoundUniqueInput
    AND?: RaidBossWhereInput | RaidBossWhereInput[]
    OR?: RaidBossWhereInput[]
    NOT?: RaidBossWhereInput | RaidBossWhereInput[]
    raid_id?: IntFilter<"RaidBoss"> | number
    boss_id?: IntFilter<"RaidBoss"> | number
    boss?: XOR<BossScalarRelationFilter, BossWhereInput>
    raid?: XOR<RaidScalarRelationFilter, RaidWhereInput>
  }, "raid_id_boss_id">

  export type RaidBossOrderByWithAggregationInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
    _count?: RaidBossCountOrderByAggregateInput
    _avg?: RaidBossAvgOrderByAggregateInput
    _max?: RaidBossMaxOrderByAggregateInput
    _min?: RaidBossMinOrderByAggregateInput
    _sum?: RaidBossSumOrderByAggregateInput
  }

  export type RaidBossScalarWhereWithAggregatesInput = {
    AND?: RaidBossScalarWhereWithAggregatesInput | RaidBossScalarWhereWithAggregatesInput[]
    OR?: RaidBossScalarWhereWithAggregatesInput[]
    NOT?: RaidBossScalarWhereWithAggregatesInput | RaidBossScalarWhereWithAggregatesInput[]
    raid_id?: IntWithAggregatesFilter<"RaidBoss"> | number
    boss_id?: IntWithAggregatesFilter<"RaidBoss"> | number
  }

  export type RaidAttendanceWhereInput = {
    AND?: RaidAttendanceWhereInput | RaidAttendanceWhereInput[]
    OR?: RaidAttendanceWhereInput[]
    NOT?: RaidAttendanceWhereInput | RaidAttendanceWhereInput[]
    id?: IntFilter<"RaidAttendance"> | number
    user_id?: IntFilter<"RaidAttendance"> | number
    raid_id?: IntFilter<"RaidAttendance"> | number
    created_at?: DateTimeFilter<"RaidAttendance"> | Date | string
    raid?: XOR<RaidScalarRelationFilter, RaidWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RaidAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
    created_at?: SortOrder
    raid?: RaidOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RaidAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RaidAttendanceWhereInput | RaidAttendanceWhereInput[]
    OR?: RaidAttendanceWhereInput[]
    NOT?: RaidAttendanceWhereInput | RaidAttendanceWhereInput[]
    user_id?: IntFilter<"RaidAttendance"> | number
    raid_id?: IntFilter<"RaidAttendance"> | number
    created_at?: DateTimeFilter<"RaidAttendance"> | Date | string
    raid?: XOR<RaidScalarRelationFilter, RaidWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RaidAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
    created_at?: SortOrder
    _count?: RaidAttendanceCountOrderByAggregateInput
    _avg?: RaidAttendanceAvgOrderByAggregateInput
    _max?: RaidAttendanceMaxOrderByAggregateInput
    _min?: RaidAttendanceMinOrderByAggregateInput
    _sum?: RaidAttendanceSumOrderByAggregateInput
  }

  export type RaidAttendanceScalarWhereWithAggregatesInput = {
    AND?: RaidAttendanceScalarWhereWithAggregatesInput | RaidAttendanceScalarWhereWithAggregatesInput[]
    OR?: RaidAttendanceScalarWhereWithAggregatesInput[]
    NOT?: RaidAttendanceScalarWhereWithAggregatesInput | RaidAttendanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RaidAttendance"> | number
    user_id?: IntWithAggregatesFilter<"RaidAttendance"> | number
    raid_id?: IntWithAggregatesFilter<"RaidAttendance"> | number
    created_at?: DateTimeWithAggregatesFilter<"RaidAttendance"> | Date | string
  }

  export type ItemTypeWhereInput = {
    AND?: ItemTypeWhereInput | ItemTypeWhereInput[]
    OR?: ItemTypeWhereInput[]
    NOT?: ItemTypeWhereInput | ItemTypeWhereInput[]
    id?: IntFilter<"ItemType"> | number
    name?: StringFilter<"ItemType"> | string
    price?: FloatNullableFilter<"ItemType"> | number | null
    loot?: LootListRelationFilter
    lootQueue?: LootQueueListRelationFilter
  }

  export type ItemTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrderInput | SortOrder
    loot?: LootOrderByRelationAggregateInput
    lootQueue?: LootQueueOrderByRelationAggregateInput
  }

  export type ItemTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ItemTypeWhereInput | ItemTypeWhereInput[]
    OR?: ItemTypeWhereInput[]
    NOT?: ItemTypeWhereInput | ItemTypeWhereInput[]
    price?: FloatNullableFilter<"ItemType"> | number | null
    loot?: LootListRelationFilter
    lootQueue?: LootQueueListRelationFilter
  }, "id" | "name">

  export type ItemTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrderInput | SortOrder
    _count?: ItemTypeCountOrderByAggregateInput
    _avg?: ItemTypeAvgOrderByAggregateInput
    _max?: ItemTypeMaxOrderByAggregateInput
    _min?: ItemTypeMinOrderByAggregateInput
    _sum?: ItemTypeSumOrderByAggregateInput
  }

  export type ItemTypeScalarWhereWithAggregatesInput = {
    AND?: ItemTypeScalarWhereWithAggregatesInput | ItemTypeScalarWhereWithAggregatesInput[]
    OR?: ItemTypeScalarWhereWithAggregatesInput[]
    NOT?: ItemTypeScalarWhereWithAggregatesInput | ItemTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItemType"> | number
    name?: StringWithAggregatesFilter<"ItemType"> | string
    price?: FloatNullableWithAggregatesFilter<"ItemType"> | number | null
  }

  export type LootWhereInput = {
    AND?: LootWhereInput | LootWhereInput[]
    OR?: LootWhereInput[]
    NOT?: LootWhereInput | LootWhereInput[]
    id?: IntFilter<"Loot"> | number
    status?: StringNullableFilter<"Loot"> | string | null
    sold_at?: DateTimeNullableFilter<"Loot"> | Date | string | null
    sold_to?: StringNullableFilter<"Loot"> | string | null
    comment?: StringNullableFilter<"Loot"> | string | null
    created_at?: DateTimeFilter<"Loot"> | Date | string
    source?: StringNullableFilter<"Loot"> | string | null
    acquired_at?: DateTimeNullableFilter<"Loot"> | Date | string | null
    itemTypeId?: IntFilter<"Loot"> | number
    sold_to_user_id?: IntNullableFilter<"Loot"> | number | null
    quantity?: IntFilter<"Loot"> | number
    price?: IntNullableFilter<"Loot"> | number | null
    itemType?: XOR<ItemTypeScalarRelationFilter, ItemTypeWhereInput>
    soldToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LootOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrderInput | SortOrder
    sold_at?: SortOrderInput | SortOrder
    sold_to?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrder
    source?: SortOrderInput | SortOrder
    acquired_at?: SortOrderInput | SortOrder
    itemTypeId?: SortOrder
    sold_to_user_id?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrderInput | SortOrder
    itemType?: ItemTypeOrderByWithRelationInput
    soldToUser?: UserOrderByWithRelationInput
  }

  export type LootWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LootWhereInput | LootWhereInput[]
    OR?: LootWhereInput[]
    NOT?: LootWhereInput | LootWhereInput[]
    status?: StringNullableFilter<"Loot"> | string | null
    sold_at?: DateTimeNullableFilter<"Loot"> | Date | string | null
    sold_to?: StringNullableFilter<"Loot"> | string | null
    comment?: StringNullableFilter<"Loot"> | string | null
    created_at?: DateTimeFilter<"Loot"> | Date | string
    source?: StringNullableFilter<"Loot"> | string | null
    acquired_at?: DateTimeNullableFilter<"Loot"> | Date | string | null
    itemTypeId?: IntFilter<"Loot"> | number
    sold_to_user_id?: IntNullableFilter<"Loot"> | number | null
    quantity?: IntFilter<"Loot"> | number
    price?: IntNullableFilter<"Loot"> | number | null
    itemType?: XOR<ItemTypeScalarRelationFilter, ItemTypeWhereInput>
    soldToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LootOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrderInput | SortOrder
    sold_at?: SortOrderInput | SortOrder
    sold_to?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrder
    source?: SortOrderInput | SortOrder
    acquired_at?: SortOrderInput | SortOrder
    itemTypeId?: SortOrder
    sold_to_user_id?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrderInput | SortOrder
    _count?: LootCountOrderByAggregateInput
    _avg?: LootAvgOrderByAggregateInput
    _max?: LootMaxOrderByAggregateInput
    _min?: LootMinOrderByAggregateInput
    _sum?: LootSumOrderByAggregateInput
  }

  export type LootScalarWhereWithAggregatesInput = {
    AND?: LootScalarWhereWithAggregatesInput | LootScalarWhereWithAggregatesInput[]
    OR?: LootScalarWhereWithAggregatesInput[]
    NOT?: LootScalarWhereWithAggregatesInput | LootScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Loot"> | number
    status?: StringNullableWithAggregatesFilter<"Loot"> | string | null
    sold_at?: DateTimeNullableWithAggregatesFilter<"Loot"> | Date | string | null
    sold_to?: StringNullableWithAggregatesFilter<"Loot"> | string | null
    comment?: StringNullableWithAggregatesFilter<"Loot"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Loot"> | Date | string
    source?: StringNullableWithAggregatesFilter<"Loot"> | string | null
    acquired_at?: DateTimeNullableWithAggregatesFilter<"Loot"> | Date | string | null
    itemTypeId?: IntWithAggregatesFilter<"Loot"> | number
    sold_to_user_id?: IntNullableWithAggregatesFilter<"Loot"> | number | null
    quantity?: IntWithAggregatesFilter<"Loot"> | number
    price?: IntNullableWithAggregatesFilter<"Loot"> | number | null
  }

  export type TasksUserWhereInput = {
    AND?: TasksUserWhereInput | TasksUserWhereInput[]
    OR?: TasksUserWhereInput[]
    NOT?: TasksUserWhereInput | TasksUserWhereInput[]
    tasks_user_id?: IntFilter<"TasksUser"> | number
    user_id?: IntFilter<"TasksUser"> | number
    task?: XOR<TasksScalarRelationFilter, TasksWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TasksUserOrderByWithRelationInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
    task?: TasksOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TasksUserWhereUniqueInput = Prisma.AtLeast<{
    tasks_user_id_user_id?: TasksUserTasks_user_idUser_idCompoundUniqueInput
    AND?: TasksUserWhereInput | TasksUserWhereInput[]
    OR?: TasksUserWhereInput[]
    NOT?: TasksUserWhereInput | TasksUserWhereInput[]
    tasks_user_id?: IntFilter<"TasksUser"> | number
    user_id?: IntFilter<"TasksUser"> | number
    task?: XOR<TasksScalarRelationFilter, TasksWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "tasks_user_id_user_id">

  export type TasksUserOrderByWithAggregationInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
    _count?: TasksUserCountOrderByAggregateInput
    _avg?: TasksUserAvgOrderByAggregateInput
    _max?: TasksUserMaxOrderByAggregateInput
    _min?: TasksUserMinOrderByAggregateInput
    _sum?: TasksUserSumOrderByAggregateInput
  }

  export type TasksUserScalarWhereWithAggregatesInput = {
    AND?: TasksUserScalarWhereWithAggregatesInput | TasksUserScalarWhereWithAggregatesInput[]
    OR?: TasksUserScalarWhereWithAggregatesInput[]
    NOT?: TasksUserScalarWhereWithAggregatesInput | TasksUserScalarWhereWithAggregatesInput[]
    tasks_user_id?: IntWithAggregatesFilter<"TasksUser"> | number
    user_id?: IntWithAggregatesFilter<"TasksUser"> | number
  }

  export type LootQueueWhereInput = {
    AND?: LootQueueWhereInput | LootQueueWhereInput[]
    OR?: LootQueueWhereInput[]
    NOT?: LootQueueWhereInput | LootQueueWhereInput[]
    id?: IntFilter<"LootQueue"> | number
    itemTypeId?: IntFilter<"LootQueue"> | number
    userId?: IntFilter<"LootQueue"> | number
    created_at?: DateTimeNullableFilter<"LootQueue"> | Date | string | null
    status?: StringNullableFilter<"LootQueue"> | string | null
    synth_target?: StringNullableFilter<"LootQueue"> | string | null
    remaining?: IntNullableFilter<"LootQueue"> | number | null
    required?: IntFilter<"LootQueue"> | number
    delivered?: IntFilter<"LootQueue"> | number
    itemType?: XOR<ItemTypeScalarRelationFilter, ItemTypeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LootQueueOrderByWithRelationInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    synth_target?: SortOrderInput | SortOrder
    remaining?: SortOrderInput | SortOrder
    required?: SortOrder
    delivered?: SortOrder
    itemType?: ItemTypeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LootQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LootQueueWhereInput | LootQueueWhereInput[]
    OR?: LootQueueWhereInput[]
    NOT?: LootQueueWhereInput | LootQueueWhereInput[]
    itemTypeId?: IntFilter<"LootQueue"> | number
    userId?: IntFilter<"LootQueue"> | number
    created_at?: DateTimeNullableFilter<"LootQueue"> | Date | string | null
    status?: StringNullableFilter<"LootQueue"> | string | null
    synth_target?: StringNullableFilter<"LootQueue"> | string | null
    remaining?: IntNullableFilter<"LootQueue"> | number | null
    required?: IntFilter<"LootQueue"> | number
    delivered?: IntFilter<"LootQueue"> | number
    itemType?: XOR<ItemTypeScalarRelationFilter, ItemTypeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LootQueueOrderByWithAggregationInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    synth_target?: SortOrderInput | SortOrder
    remaining?: SortOrderInput | SortOrder
    required?: SortOrder
    delivered?: SortOrder
    _count?: LootQueueCountOrderByAggregateInput
    _avg?: LootQueueAvgOrderByAggregateInput
    _max?: LootQueueMaxOrderByAggregateInput
    _min?: LootQueueMinOrderByAggregateInput
    _sum?: LootQueueSumOrderByAggregateInput
  }

  export type LootQueueScalarWhereWithAggregatesInput = {
    AND?: LootQueueScalarWhereWithAggregatesInput | LootQueueScalarWhereWithAggregatesInput[]
    OR?: LootQueueScalarWhereWithAggregatesInput[]
    NOT?: LootQueueScalarWhereWithAggregatesInput | LootQueueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LootQueue"> | number
    itemTypeId?: IntWithAggregatesFilter<"LootQueue"> | number
    userId?: IntWithAggregatesFilter<"LootQueue"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"LootQueue"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"LootQueue"> | string | null
    synth_target?: StringNullableWithAggregatesFilter<"LootQueue"> | string | null
    remaining?: IntNullableWithAggregatesFilter<"LootQueue"> | number | null
    required?: IntWithAggregatesFilter<"LootQueue"> | number
    delivered?: IntWithAggregatesFilter<"LootQueue"> | number
  }

  export type GivenAwayLootWhereInput = {
    AND?: GivenAwayLootWhereInput | GivenAwayLootWhereInput[]
    OR?: GivenAwayLootWhereInput[]
    NOT?: GivenAwayLootWhereInput | GivenAwayLootWhereInput[]
    id?: IntFilter<"GivenAwayLoot"> | number
    user_id?: IntFilter<"GivenAwayLoot"> | number
    name?: StringFilter<"GivenAwayLoot"> | string
    date?: DateTimeFilter<"GivenAwayLoot"> | Date | string
    comment?: StringNullableFilter<"GivenAwayLoot"> | string | null
    created_at?: DateTimeNullableFilter<"GivenAwayLoot"> | Date | string | null
    status?: StringNullableFilter<"GivenAwayLoot"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GivenAwayLootOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GivenAwayLootWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_name?: GivenAwayLootUser_idNameCompoundUniqueInput
    AND?: GivenAwayLootWhereInput | GivenAwayLootWhereInput[]
    OR?: GivenAwayLootWhereInput[]
    NOT?: GivenAwayLootWhereInput | GivenAwayLootWhereInput[]
    user_id?: IntFilter<"GivenAwayLoot"> | number
    name?: StringFilter<"GivenAwayLoot"> | string
    date?: DateTimeFilter<"GivenAwayLoot"> | Date | string
    comment?: StringNullableFilter<"GivenAwayLoot"> | string | null
    created_at?: DateTimeNullableFilter<"GivenAwayLoot"> | Date | string | null
    status?: StringNullableFilter<"GivenAwayLoot"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id_name">

  export type GivenAwayLootOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: GivenAwayLootCountOrderByAggregateInput
    _avg?: GivenAwayLootAvgOrderByAggregateInput
    _max?: GivenAwayLootMaxOrderByAggregateInput
    _min?: GivenAwayLootMinOrderByAggregateInput
    _sum?: GivenAwayLootSumOrderByAggregateInput
  }

  export type GivenAwayLootScalarWhereWithAggregatesInput = {
    AND?: GivenAwayLootScalarWhereWithAggregatesInput | GivenAwayLootScalarWhereWithAggregatesInput[]
    OR?: GivenAwayLootScalarWhereWithAggregatesInput[]
    NOT?: GivenAwayLootScalarWhereWithAggregatesInput | GivenAwayLootScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GivenAwayLoot"> | number
    user_id?: IntWithAggregatesFilter<"GivenAwayLoot"> | number
    name?: StringWithAggregatesFilter<"GivenAwayLoot"> | string
    date?: DateTimeWithAggregatesFilter<"GivenAwayLoot"> | Date | string
    comment?: StringNullableWithAggregatesFilter<"GivenAwayLoot"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"GivenAwayLoot"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"GivenAwayLoot"> | string | null
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: IntFilter<"Expense"> | number
    date?: DateTimeFilter<"Expense"> | Date | string
    amount?: IntFilter<"Expense"> | number
    target?: StringFilter<"Expense"> | string
    source?: StringFilter<"Expense"> | string
    comment?: StringNullableFilter<"Expense"> | string | null
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    target?: SortOrder
    source?: SortOrder
    comment?: SortOrderInput | SortOrder
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    date?: DateTimeFilter<"Expense"> | Date | string
    amount?: IntFilter<"Expense"> | number
    target?: StringFilter<"Expense"> | string
    source?: StringFilter<"Expense"> | string
    comment?: StringNullableFilter<"Expense"> | string | null
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    target?: SortOrder
    source?: SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Expense"> | number
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    amount?: IntWithAggregatesFilter<"Expense"> | number
    target?: StringWithAggregatesFilter<"Expense"> | string
    source?: StringWithAggregatesFilter<"Expense"> | string
    comment?: StringNullableWithAggregatesFilter<"Expense"> | string | null
  }

  export type GuildFundsWhereInput = {
    AND?: GuildFundsWhereInput | GuildFundsWhereInput[]
    OR?: GuildFundsWhereInput[]
    NOT?: GuildFundsWhereInput | GuildFundsWhereInput[]
    id?: IntFilter<"GuildFunds"> | number
    year?: IntFilter<"GuildFunds"> | number
    month?: IntFilter<"GuildFunds"> | number
    totalIncome?: IntFilter<"GuildFunds"> | number
    totalExpenses?: IntFilter<"GuildFunds"> | number
    profit?: IntFilter<"GuildFunds"> | number
    salaryBudget?: IntFilter<"GuildFunds"> | number
    treasuryLeft?: IntFilter<"GuildFunds"> | number
  }

  export type GuildFundsOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    profit?: SortOrder
    salaryBudget?: SortOrder
    treasuryLeft?: SortOrder
  }

  export type GuildFundsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GuildFundsWhereInput | GuildFundsWhereInput[]
    OR?: GuildFundsWhereInput[]
    NOT?: GuildFundsWhereInput | GuildFundsWhereInput[]
    year?: IntFilter<"GuildFunds"> | number
    month?: IntFilter<"GuildFunds"> | number
    totalIncome?: IntFilter<"GuildFunds"> | number
    totalExpenses?: IntFilter<"GuildFunds"> | number
    profit?: IntFilter<"GuildFunds"> | number
    salaryBudget?: IntFilter<"GuildFunds"> | number
    treasuryLeft?: IntFilter<"GuildFunds"> | number
  }, "id">

  export type GuildFundsOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    profit?: SortOrder
    salaryBudget?: SortOrder
    treasuryLeft?: SortOrder
    _count?: GuildFundsCountOrderByAggregateInput
    _avg?: GuildFundsAvgOrderByAggregateInput
    _max?: GuildFundsMaxOrderByAggregateInput
    _min?: GuildFundsMinOrderByAggregateInput
    _sum?: GuildFundsSumOrderByAggregateInput
  }

  export type GuildFundsScalarWhereWithAggregatesInput = {
    AND?: GuildFundsScalarWhereWithAggregatesInput | GuildFundsScalarWhereWithAggregatesInput[]
    OR?: GuildFundsScalarWhereWithAggregatesInput[]
    NOT?: GuildFundsScalarWhereWithAggregatesInput | GuildFundsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GuildFunds"> | number
    year?: IntWithAggregatesFilter<"GuildFunds"> | number
    month?: IntWithAggregatesFilter<"GuildFunds"> | number
    totalIncome?: IntWithAggregatesFilter<"GuildFunds"> | number
    totalExpenses?: IntWithAggregatesFilter<"GuildFunds"> | number
    profit?: IntWithAggregatesFilter<"GuildFunds"> | number
    salaryBudget?: IntWithAggregatesFilter<"GuildFunds"> | number
    treasuryLeft?: IntWithAggregatesFilter<"GuildFunds"> | number
  }

  export type SalaryWhereInput = {
    AND?: SalaryWhereInput | SalaryWhereInput[]
    OR?: SalaryWhereInput[]
    NOT?: SalaryWhereInput | SalaryWhereInput[]
    id?: IntFilter<"Salary"> | number
    year?: IntFilter<"Salary"> | number
    month?: IntFilter<"Salary"> | number
    userId?: IntFilter<"Salary"> | number
    amount?: IntFilter<"Salary"> | number
    bonus?: IntNullableFilter<"Salary"> | number | null
    total?: IntFilter<"Salary"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SalaryOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    bonus?: SortOrderInput | SortOrder
    total?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SalaryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalaryWhereInput | SalaryWhereInput[]
    OR?: SalaryWhereInput[]
    NOT?: SalaryWhereInput | SalaryWhereInput[]
    year?: IntFilter<"Salary"> | number
    month?: IntFilter<"Salary"> | number
    userId?: IntFilter<"Salary"> | number
    amount?: IntFilter<"Salary"> | number
    bonus?: IntNullableFilter<"Salary"> | number | null
    total?: IntFilter<"Salary"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SalaryOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    bonus?: SortOrderInput | SortOrder
    total?: SortOrder
    _count?: SalaryCountOrderByAggregateInput
    _avg?: SalaryAvgOrderByAggregateInput
    _max?: SalaryMaxOrderByAggregateInput
    _min?: SalaryMinOrderByAggregateInput
    _sum?: SalarySumOrderByAggregateInput
  }

  export type SalaryScalarWhereWithAggregatesInput = {
    AND?: SalaryScalarWhereWithAggregatesInput | SalaryScalarWhereWithAggregatesInput[]
    OR?: SalaryScalarWhereWithAggregatesInput[]
    NOT?: SalaryScalarWhereWithAggregatesInput | SalaryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Salary"> | number
    year?: IntWithAggregatesFilter<"Salary"> | number
    month?: IntWithAggregatesFilter<"Salary"> | number
    userId?: IntWithAggregatesFilter<"Salary"> | number
    amount?: IntWithAggregatesFilter<"Salary"> | number
    bonus?: IntNullableWithAggregatesFilter<"Salary"> | number | null
    total?: IntWithAggregatesFilter<"Salary"> | number
  }

  export type UserSalaryBonusWhereInput = {
    AND?: UserSalaryBonusWhereInput | UserSalaryBonusWhereInput[]
    OR?: UserSalaryBonusWhereInput[]
    NOT?: UserSalaryBonusWhereInput | UserSalaryBonusWhereInput[]
    id?: IntFilter<"UserSalaryBonus"> | number
    user_id?: IntFilter<"UserSalaryBonus"> | number
    amount?: IntFilter<"UserSalaryBonus"> | number
    reason?: StringFilter<"UserSalaryBonus"> | string
    created_at?: DateTimeNullableFilter<"UserSalaryBonus"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSalaryBonusOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSalaryBonusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserSalaryBonusWhereInput | UserSalaryBonusWhereInput[]
    OR?: UserSalaryBonusWhereInput[]
    NOT?: UserSalaryBonusWhereInput | UserSalaryBonusWhereInput[]
    user_id?: IntFilter<"UserSalaryBonus"> | number
    amount?: IntFilter<"UserSalaryBonus"> | number
    reason?: StringFilter<"UserSalaryBonus"> | string
    created_at?: DateTimeNullableFilter<"UserSalaryBonus"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserSalaryBonusOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: UserSalaryBonusCountOrderByAggregateInput
    _avg?: UserSalaryBonusAvgOrderByAggregateInput
    _max?: UserSalaryBonusMaxOrderByAggregateInput
    _min?: UserSalaryBonusMinOrderByAggregateInput
    _sum?: UserSalaryBonusSumOrderByAggregateInput
  }

  export type UserSalaryBonusScalarWhereWithAggregatesInput = {
    AND?: UserSalaryBonusScalarWhereWithAggregatesInput | UserSalaryBonusScalarWhereWithAggregatesInput[]
    OR?: UserSalaryBonusScalarWhereWithAggregatesInput[]
    NOT?: UserSalaryBonusScalarWhereWithAggregatesInput | UserSalaryBonusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserSalaryBonus"> | number
    user_id?: IntWithAggregatesFilter<"UserSalaryBonus"> | number
    amount?: IntWithAggregatesFilter<"UserSalaryBonus"> | number
    reason?: StringWithAggregatesFilter<"UserSalaryBonus"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"UserSalaryBonus"> | Date | string | null
  }

  export type LinkTokenWhereInput = {
    AND?: LinkTokenWhereInput | LinkTokenWhereInput[]
    OR?: LinkTokenWhereInput[]
    NOT?: LinkTokenWhereInput | LinkTokenWhereInput[]
    id?: IntFilter<"LinkToken"> | number
    token?: StringFilter<"LinkToken"> | string
    userId?: IntFilter<"LinkToken"> | number
    expiresAt?: DateTimeFilter<"LinkToken"> | Date | string
    used?: BoolFilter<"LinkToken"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LinkTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LinkTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: LinkTokenWhereInput | LinkTokenWhereInput[]
    OR?: LinkTokenWhereInput[]
    NOT?: LinkTokenWhereInput | LinkTokenWhereInput[]
    userId?: IntFilter<"LinkToken"> | number
    expiresAt?: DateTimeFilter<"LinkToken"> | Date | string
    used?: BoolFilter<"LinkToken"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type LinkTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    _count?: LinkTokenCountOrderByAggregateInput
    _avg?: LinkTokenAvgOrderByAggregateInput
    _max?: LinkTokenMaxOrderByAggregateInput
    _min?: LinkTokenMinOrderByAggregateInput
    _sum?: LinkTokenSumOrderByAggregateInput
  }

  export type LinkTokenScalarWhereWithAggregatesInput = {
    AND?: LinkTokenScalarWhereWithAggregatesInput | LinkTokenScalarWhereWithAggregatesInput[]
    OR?: LinkTokenScalarWhereWithAggregatesInput[]
    NOT?: LinkTokenScalarWhereWithAggregatesInput | LinkTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LinkToken"> | number
    token?: StringWithAggregatesFilter<"LinkToken"> | string
    userId?: IntWithAggregatesFilter<"LinkToken"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"LinkToken"> | Date | string
    used?: BoolWithAggregatesFilter<"LinkToken"> | boolean
  }

  export type NewsWhereInput = {
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    id?: IntFilter<"News"> | number
    title?: StringFilter<"News"> | string
    content?: StringFilter<"News"> | string
    date?: DateTimeFilter<"News"> | Date | string
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
  }

  export type NewsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NewsWhereInput | NewsWhereInput[]
    OR?: NewsWhereInput[]
    NOT?: NewsWhereInput | NewsWhereInput[]
    title?: StringFilter<"News"> | string
    content?: StringFilter<"News"> | string
    date?: DateTimeFilter<"News"> | Date | string
    createdAt?: DateTimeFilter<"News"> | Date | string
    updatedAt?: DateTimeFilter<"News"> | Date | string
  }, "id">

  export type NewsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NewsCountOrderByAggregateInput
    _avg?: NewsAvgOrderByAggregateInput
    _max?: NewsMaxOrderByAggregateInput
    _min?: NewsMinOrderByAggregateInput
    _sum?: NewsSumOrderByAggregateInput
  }

  export type NewsScalarWhereWithAggregatesInput = {
    AND?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    OR?: NewsScalarWhereWithAggregatesInput[]
    NOT?: NewsScalarWhereWithAggregatesInput | NewsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"News"> | number
    title?: StringWithAggregatesFilter<"News"> | string
    content?: StringWithAggregatesFilter<"News"> | string
    date?: DateTimeWithAggregatesFilter<"News"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"News"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryUncheckedCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUncheckedUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserTagsCreateInput = {
    tag: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutTagsInput
  }

  export type UserTagsUncheckedCreateInput = {
    id?: number
    user_id: number
    tag: string
    created_at?: Date | string
  }

  export type UserTagsUpdateInput = {
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagsNestedInput
  }

  export type UserTagsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsCreateManyInput = {
    id?: number
    user_id: number
    tag: string
    created_at?: Date | string
  }

  export type UserTagsUpdateManyMutationInput = {
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInventoryCreateInput = {
    type?: string | null
    name?: string | null
    quality?: string | null
    created_at: Date | string
    quantity?: number | null
    user: UserCreateNestedOneWithoutInventoryInput
  }

  export type UserInventoryUncheckedCreateInput = {
    id?: number
    user_id: number
    type?: string | null
    name?: string | null
    quality?: string | null
    created_at: Date | string
    quantity?: number | null
  }

  export type UserInventoryUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type UserInventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserInventoryCreateManyInput = {
    id?: number
    user_id: number
    type?: string | null
    name?: string | null
    quality?: string | null
    created_at: Date | string
    quantity?: number | null
  }

  export type UserInventoryUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserInventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TasksCreateInput = {
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
    user: UserCreateNestedOneWithoutTasksInput
    assignedTo?: TasksUserCreateNestedManyWithoutTaskInput
  }

  export type TasksUncheckedCreateInput = {
    id?: number
    user_id: number
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
    assignedTo?: TasksUserUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TasksUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    assignedTo?: TasksUserUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: TasksUserUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TasksCreateManyInput = {
    id?: number
    user_id: number
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
  }

  export type TasksUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TasksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidCreateInput = {
    type?: string | null
    start_date?: Date | string | null
    created_at: Date | string
    is_pvp?: boolean | null
    is_pvp_long?: boolean | null
    dkp_summary?: number | null
    attendance?: RaidAttendanceCreateNestedManyWithoutRaidInput
    raidBosses?: RaidBossCreateNestedManyWithoutRaidInput
  }

  export type RaidUncheckedCreateInput = {
    id?: number
    type?: string | null
    start_date?: Date | string | null
    created_at: Date | string
    is_pvp?: boolean | null
    is_pvp_long?: boolean | null
    dkp_summary?: number | null
    attendance?: RaidAttendanceUncheckedCreateNestedManyWithoutRaidInput
    raidBosses?: RaidBossUncheckedCreateNestedManyWithoutRaidInput
  }

  export type RaidUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_pvp?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_pvp_long?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dkp_summary?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: RaidAttendanceUpdateManyWithoutRaidNestedInput
    raidBosses?: RaidBossUpdateManyWithoutRaidNestedInput
  }

  export type RaidUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_pvp?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_pvp_long?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dkp_summary?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: RaidAttendanceUncheckedUpdateManyWithoutRaidNestedInput
    raidBosses?: RaidBossUncheckedUpdateManyWithoutRaidNestedInput
  }

  export type RaidCreateManyInput = {
    id?: number
    type?: string | null
    start_date?: Date | string | null
    created_at: Date | string
    is_pvp?: boolean | null
    is_pvp_long?: boolean | null
    dkp_summary?: number | null
  }

  export type RaidUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_pvp?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_pvp_long?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dkp_summary?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RaidUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_pvp?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_pvp_long?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dkp_summary?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BossCreateInput = {
    boss_name: string
    dkp_points: number
    category?: string | null
    raidBosses?: RaidBossCreateNestedManyWithoutBossInput
  }

  export type BossUncheckedCreateInput = {
    id?: number
    boss_name: string
    dkp_points: number
    category?: string | null
    raidBosses?: RaidBossUncheckedCreateNestedManyWithoutBossInput
  }

  export type BossUpdateInput = {
    boss_name?: StringFieldUpdateOperationsInput | string
    dkp_points?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    raidBosses?: RaidBossUpdateManyWithoutBossNestedInput
  }

  export type BossUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    boss_name?: StringFieldUpdateOperationsInput | string
    dkp_points?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    raidBosses?: RaidBossUncheckedUpdateManyWithoutBossNestedInput
  }

  export type BossCreateManyInput = {
    id?: number
    boss_name: string
    dkp_points: number
    category?: string | null
  }

  export type BossUpdateManyMutationInput = {
    boss_name?: StringFieldUpdateOperationsInput | string
    dkp_points?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BossUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    boss_name?: StringFieldUpdateOperationsInput | string
    dkp_points?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RaidBossCreateInput = {
    boss: BossCreateNestedOneWithoutRaidBossesInput
    raid: RaidCreateNestedOneWithoutRaidBossesInput
  }

  export type RaidBossUncheckedCreateInput = {
    raid_id: number
    boss_id: number
  }

  export type RaidBossUpdateInput = {
    boss?: BossUpdateOneRequiredWithoutRaidBossesNestedInput
    raid?: RaidUpdateOneRequiredWithoutRaidBossesNestedInput
  }

  export type RaidBossUncheckedUpdateInput = {
    raid_id?: IntFieldUpdateOperationsInput | number
    boss_id?: IntFieldUpdateOperationsInput | number
  }

  export type RaidBossCreateManyInput = {
    raid_id: number
    boss_id: number
  }

  export type RaidBossUpdateManyMutationInput = {

  }

  export type RaidBossUncheckedUpdateManyInput = {
    raid_id?: IntFieldUpdateOperationsInput | number
    boss_id?: IntFieldUpdateOperationsInput | number
  }

  export type RaidAttendanceCreateInput = {
    created_at: Date | string
    raid: RaidCreateNestedOneWithoutAttendanceInput
    user: UserCreateNestedOneWithoutRaidAttendanceInput
  }

  export type RaidAttendanceUncheckedCreateInput = {
    id?: number
    user_id: number
    raid_id: number
    created_at: Date | string
  }

  export type RaidAttendanceUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    raid?: RaidUpdateOneRequiredWithoutAttendanceNestedInput
    user?: UserUpdateOneRequiredWithoutRaidAttendanceNestedInput
  }

  export type RaidAttendanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    raid_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidAttendanceCreateManyInput = {
    id?: number
    user_id: number
    raid_id: number
    created_at: Date | string
  }

  export type RaidAttendanceUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidAttendanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    raid_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTypeCreateInput = {
    name: string
    price?: number | null
    loot?: LootCreateNestedManyWithoutItemTypeInput
    lootQueue?: LootQueueCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeUncheckedCreateInput = {
    id?: number
    name: string
    price?: number | null
    loot?: LootUncheckedCreateNestedManyWithoutItemTypeInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    loot?: LootUpdateManyWithoutItemTypeNestedInput
    lootQueue?: LootQueueUpdateManyWithoutItemTypeNestedInput
  }

  export type ItemTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    loot?: LootUncheckedUpdateManyWithoutItemTypeNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutItemTypeNestedInput
  }

  export type ItemTypeCreateManyInput = {
    id?: number
    name: string
    price?: number | null
  }

  export type ItemTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ItemTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LootCreateInput = {
    status?: string | null
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    created_at?: Date | string
    source?: string | null
    acquired_at?: Date | string | null
    quantity?: number
    price?: number | null
    itemType: ItemTypeCreateNestedOneWithoutLootInput
    soldToUser?: UserCreateNestedOneWithoutSoldLootInput
  }

  export type LootUncheckedCreateInput = {
    id?: number
    status?: string | null
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    created_at?: Date | string
    source?: string | null
    acquired_at?: Date | string | null
    itemTypeId: number
    sold_to_user_id?: number | null
    quantity?: number
    price?: number | null
  }

  export type LootUpdateInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    acquired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableIntFieldUpdateOperationsInput | number | null
    itemType?: ItemTypeUpdateOneRequiredWithoutLootNestedInput
    soldToUser?: UserUpdateOneWithoutSoldLootNestedInput
  }

  export type LootUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    acquired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemTypeId?: IntFieldUpdateOperationsInput | number
    sold_to_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LootCreateManyInput = {
    id?: number
    status?: string | null
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    created_at?: Date | string
    source?: string | null
    acquired_at?: Date | string | null
    itemTypeId: number
    sold_to_user_id?: number | null
    quantity?: number
    price?: number | null
  }

  export type LootUpdateManyMutationInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    acquired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LootUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    acquired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemTypeId?: IntFieldUpdateOperationsInput | number
    sold_to_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TasksUserCreateInput = {
    task: TasksCreateNestedOneWithoutAssignedToInput
    user: UserCreateNestedOneWithoutTasksAssignedInput
  }

  export type TasksUserUncheckedCreateInput = {
    tasks_user_id: number
    user_id: number
  }

  export type TasksUserUpdateInput = {
    task?: TasksUpdateOneRequiredWithoutAssignedToNestedInput
    user?: UserUpdateOneRequiredWithoutTasksAssignedNestedInput
  }

  export type TasksUserUncheckedUpdateInput = {
    tasks_user_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type TasksUserCreateManyInput = {
    tasks_user_id: number
    user_id: number
  }

  export type TasksUserUpdateManyMutationInput = {

  }

  export type TasksUserUncheckedUpdateManyInput = {
    tasks_user_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type LootQueueCreateInput = {
    created_at?: Date | string | null
    status?: string | null
    synth_target?: string | null
    remaining?: number | null
    required?: number
    delivered?: number
    itemType: ItemTypeCreateNestedOneWithoutLootQueueInput
    user: UserCreateNestedOneWithoutLootQueueInput
  }

  export type LootQueueUncheckedCreateInput = {
    id?: number
    itemTypeId: number
    userId: number
    created_at?: Date | string | null
    status?: string | null
    synth_target?: string | null
    remaining?: number | null
    required?: number
    delivered?: number
  }

  export type LootQueueUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    synth_target?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    required?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    itemType?: ItemTypeUpdateOneRequiredWithoutLootQueueNestedInput
    user?: UserUpdateOneRequiredWithoutLootQueueNestedInput
  }

  export type LootQueueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    synth_target?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    required?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
  }

  export type LootQueueCreateManyInput = {
    id?: number
    itemTypeId: number
    userId: number
    created_at?: Date | string | null
    status?: string | null
    synth_target?: string | null
    remaining?: number | null
    required?: number
    delivered?: number
  }

  export type LootQueueUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    synth_target?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    required?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
  }

  export type LootQueueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    synth_target?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    required?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
  }

  export type GivenAwayLootCreateInput = {
    name: string
    date: Date | string
    comment?: string | null
    created_at?: Date | string | null
    status?: string | null
    user: UserCreateNestedOneWithoutGivenAwayLootInput
  }

  export type GivenAwayLootUncheckedCreateInput = {
    id?: number
    user_id: number
    name: string
    date: Date | string
    comment?: string | null
    created_at?: Date | string | null
    status?: string | null
  }

  export type GivenAwayLootUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutGivenAwayLootNestedInput
  }

  export type GivenAwayLootUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GivenAwayLootCreateManyInput = {
    id?: number
    user_id: number
    name: string
    date: Date | string
    comment?: string | null
    created_at?: Date | string | null
    status?: string | null
  }

  export type GivenAwayLootUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GivenAwayLootUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseCreateInput = {
    date: Date | string
    amount: number
    target: string
    source: string
    comment?: string | null
  }

  export type ExpenseUncheckedCreateInput = {
    id?: number
    date: Date | string
    amount: number
    target: string
    source: string
    comment?: string | null
  }

  export type ExpenseUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    target?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    target?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseCreateManyInput = {
    id?: number
    date: Date | string
    amount: number
    target: string
    source: string
    comment?: string | null
  }

  export type ExpenseUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    target?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    target?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuildFundsCreateInput = {
    year: number
    month: number
    totalIncome: number
    totalExpenses: number
    profit: number
    salaryBudget: number
    treasuryLeft: number
  }

  export type GuildFundsUncheckedCreateInput = {
    id?: number
    year: number
    month: number
    totalIncome: number
    totalExpenses: number
    profit: number
    salaryBudget: number
    treasuryLeft: number
  }

  export type GuildFundsUpdateInput = {
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    totalIncome?: IntFieldUpdateOperationsInput | number
    totalExpenses?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    salaryBudget?: IntFieldUpdateOperationsInput | number
    treasuryLeft?: IntFieldUpdateOperationsInput | number
  }

  export type GuildFundsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    totalIncome?: IntFieldUpdateOperationsInput | number
    totalExpenses?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    salaryBudget?: IntFieldUpdateOperationsInput | number
    treasuryLeft?: IntFieldUpdateOperationsInput | number
  }

  export type GuildFundsCreateManyInput = {
    id?: number
    year: number
    month: number
    totalIncome: number
    totalExpenses: number
    profit: number
    salaryBudget: number
    treasuryLeft: number
  }

  export type GuildFundsUpdateManyMutationInput = {
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    totalIncome?: IntFieldUpdateOperationsInput | number
    totalExpenses?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    salaryBudget?: IntFieldUpdateOperationsInput | number
    treasuryLeft?: IntFieldUpdateOperationsInput | number
  }

  export type GuildFundsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    totalIncome?: IntFieldUpdateOperationsInput | number
    totalExpenses?: IntFieldUpdateOperationsInput | number
    profit?: IntFieldUpdateOperationsInput | number
    salaryBudget?: IntFieldUpdateOperationsInput | number
    treasuryLeft?: IntFieldUpdateOperationsInput | number
  }

  export type SalaryCreateInput = {
    year: number
    month: number
    amount: number
    bonus?: number | null
    total: number
    user: UserCreateNestedOneWithoutSalariesInput
  }

  export type SalaryUncheckedCreateInput = {
    id?: number
    year: number
    month: number
    userId: number
    amount: number
    bonus?: number | null
    total: number
  }

  export type SalaryUpdateInput = {
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    bonus?: NullableIntFieldUpdateOperationsInput | number | null
    total?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutSalariesNestedInput
  }

  export type SalaryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    bonus?: NullableIntFieldUpdateOperationsInput | number | null
    total?: IntFieldUpdateOperationsInput | number
  }

  export type SalaryCreateManyInput = {
    id?: number
    year: number
    month: number
    userId: number
    amount: number
    bonus?: number | null
    total: number
  }

  export type SalaryUpdateManyMutationInput = {
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    bonus?: NullableIntFieldUpdateOperationsInput | number | null
    total?: IntFieldUpdateOperationsInput | number
  }

  export type SalaryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    bonus?: NullableIntFieldUpdateOperationsInput | number | null
    total?: IntFieldUpdateOperationsInput | number
  }

  export type UserSalaryBonusCreateInput = {
    amount: number
    reason: string
    created_at?: Date | string | null
    user: UserCreateNestedOneWithoutSalaryBonusesInput
  }

  export type UserSalaryBonusUncheckedCreateInput = {
    id?: number
    user_id: number
    amount: number
    reason: string
    created_at?: Date | string | null
  }

  export type UserSalaryBonusUpdateInput = {
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSalaryBonusesNestedInput
  }

  export type UserSalaryBonusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSalaryBonusCreateManyInput = {
    id?: number
    user_id: number
    amount: number
    reason: string
    created_at?: Date | string | null
  }

  export type UserSalaryBonusUpdateManyMutationInput = {
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSalaryBonusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LinkTokenCreateInput = {
    token: string
    expiresAt: Date | string
    used?: boolean
    user: UserCreateNestedOneWithoutLinkTokensInput
  }

  export type LinkTokenUncheckedCreateInput = {
    id?: number
    token: string
    userId: number
    expiresAt: Date | string
    used?: boolean
  }

  export type LinkTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutLinkTokensNestedInput
  }

  export type LinkTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LinkTokenCreateManyInput = {
    id?: number
    token: string
    userId: number
    expiresAt: Date | string
    used?: boolean
  }

  export type LinkTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LinkTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NewsCreateInput = {
    title: string
    content: string
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsCreateManyInput = {
    id?: number
    title: string
    content: string
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SalaryListRelationFilter = {
    every?: SalaryWhereInput
    some?: SalaryWhereInput
    none?: SalaryWhereInput
  }

  export type GivenAwayLootListRelationFilter = {
    every?: GivenAwayLootWhereInput
    some?: GivenAwayLootWhereInput
    none?: GivenAwayLootWhereInput
  }

  export type LootListRelationFilter = {
    every?: LootWhereInput
    some?: LootWhereInput
    none?: LootWhereInput
  }

  export type LootQueueListRelationFilter = {
    every?: LootQueueWhereInput
    some?: LootQueueWhereInput
    none?: LootQueueWhereInput
  }

  export type RaidAttendanceListRelationFilter = {
    every?: RaidAttendanceWhereInput
    some?: RaidAttendanceWhereInput
    none?: RaidAttendanceWhereInput
  }

  export type TasksListRelationFilter = {
    every?: TasksWhereInput
    some?: TasksWhereInput
    none?: TasksWhereInput
  }

  export type TasksUserListRelationFilter = {
    every?: TasksUserWhereInput
    some?: TasksUserWhereInput
    none?: TasksUserWhereInput
  }

  export type UserInventoryListRelationFilter = {
    every?: UserInventoryWhereInput
    some?: UserInventoryWhereInput
    none?: UserInventoryWhereInput
  }

  export type UserSalaryBonusListRelationFilter = {
    every?: UserSalaryBonusWhereInput
    some?: UserSalaryBonusWhereInput
    none?: UserSalaryBonusWhereInput
  }

  export type UserTagsListRelationFilter = {
    every?: UserTagsWhereInput
    some?: UserTagsWhereInput
    none?: UserTagsWhereInput
  }

  export type LinkTokenListRelationFilter = {
    every?: LinkTokenWhereInput
    some?: LinkTokenWhereInput
    none?: LinkTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SalaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GivenAwayLootOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LootOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LootQueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaidAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TasksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TasksUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserInventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSalaryBonusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LinkTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    class?: SortOrder
    secondary_class?: SortOrder
    class_gear_score?: SortOrder
    secondary_class_gear_score?: SortOrder
    vk_name?: SortOrder
    active?: SortOrder
    is_eligible_for_salary?: SortOrder
    joined_at?: SortOrder
    created_at?: SortOrder
    salaryBonus?: SortOrder
    googleId?: SortOrder
    vkId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    class_gear_score?: SortOrder
    secondary_class_gear_score?: SortOrder
    salaryBonus?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    class?: SortOrder
    secondary_class?: SortOrder
    class_gear_score?: SortOrder
    secondary_class_gear_score?: SortOrder
    vk_name?: SortOrder
    active?: SortOrder
    is_eligible_for_salary?: SortOrder
    joined_at?: SortOrder
    created_at?: SortOrder
    salaryBonus?: SortOrder
    googleId?: SortOrder
    vkId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    class?: SortOrder
    secondary_class?: SortOrder
    class_gear_score?: SortOrder
    secondary_class_gear_score?: SortOrder
    vk_name?: SortOrder
    active?: SortOrder
    is_eligible_for_salary?: SortOrder
    joined_at?: SortOrder
    created_at?: SortOrder
    salaryBonus?: SortOrder
    googleId?: SortOrder
    vkId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    class_gear_score?: SortOrder
    secondary_class_gear_score?: SortOrder
    salaryBonus?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserTagsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    tag?: SortOrder
    created_at?: SortOrder
  }

  export type UserTagsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type UserTagsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    tag?: SortOrder
    created_at?: SortOrder
  }

  export type UserTagsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    tag?: SortOrder
    created_at?: SortOrder
  }

  export type UserTagsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type UserInventoryCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    quality?: SortOrder
    created_at?: SortOrder
    quantity?: SortOrder
  }

  export type UserInventoryAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    quantity?: SortOrder
  }

  export type UserInventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    quality?: SortOrder
    created_at?: SortOrder
    quantity?: SortOrder
  }

  export type UserInventoryMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    quality?: SortOrder
    created_at?: SortOrder
    quantity?: SortOrder
  }

  export type UserInventorySumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    quantity?: SortOrder
  }

  export type TasksCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
  }

  export type TasksAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type TasksMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
  }

  export type TasksMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
  }

  export type TasksSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type RaidBossListRelationFilter = {
    every?: RaidBossWhereInput
    some?: RaidBossWhereInput
    none?: RaidBossWhereInput
  }

  export type RaidBossOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RaidCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    start_date?: SortOrder
    created_at?: SortOrder
    is_pvp?: SortOrder
    is_pvp_long?: SortOrder
    dkp_summary?: SortOrder
  }

  export type RaidAvgOrderByAggregateInput = {
    id?: SortOrder
    dkp_summary?: SortOrder
  }

  export type RaidMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    start_date?: SortOrder
    created_at?: SortOrder
    is_pvp?: SortOrder
    is_pvp_long?: SortOrder
    dkp_summary?: SortOrder
  }

  export type RaidMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    start_date?: SortOrder
    created_at?: SortOrder
    is_pvp?: SortOrder
    is_pvp_long?: SortOrder
    dkp_summary?: SortOrder
  }

  export type RaidSumOrderByAggregateInput = {
    id?: SortOrder
    dkp_summary?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BossCountOrderByAggregateInput = {
    id?: SortOrder
    boss_name?: SortOrder
    dkp_points?: SortOrder
    category?: SortOrder
  }

  export type BossAvgOrderByAggregateInput = {
    id?: SortOrder
    dkp_points?: SortOrder
  }

  export type BossMaxOrderByAggregateInput = {
    id?: SortOrder
    boss_name?: SortOrder
    dkp_points?: SortOrder
    category?: SortOrder
  }

  export type BossMinOrderByAggregateInput = {
    id?: SortOrder
    boss_name?: SortOrder
    dkp_points?: SortOrder
    category?: SortOrder
  }

  export type BossSumOrderByAggregateInput = {
    id?: SortOrder
    dkp_points?: SortOrder
  }

  export type BossScalarRelationFilter = {
    is?: BossWhereInput
    isNot?: BossWhereInput
  }

  export type RaidScalarRelationFilter = {
    is?: RaidWhereInput
    isNot?: RaidWhereInput
  }

  export type RaidBossRaid_idBoss_idCompoundUniqueInput = {
    raid_id: number
    boss_id: number
  }

  export type RaidBossCountOrderByAggregateInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
  }

  export type RaidBossAvgOrderByAggregateInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
  }

  export type RaidBossMaxOrderByAggregateInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
  }

  export type RaidBossMinOrderByAggregateInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
  }

  export type RaidBossSumOrderByAggregateInput = {
    raid_id?: SortOrder
    boss_id?: SortOrder
  }

  export type RaidAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
    created_at?: SortOrder
  }

  export type RaidAttendanceAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
  }

  export type RaidAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
    created_at?: SortOrder
  }

  export type RaidAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
    created_at?: SortOrder
  }

  export type RaidAttendanceSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    raid_id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ItemTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ItemTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type ItemTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ItemTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ItemTypeSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ItemTypeScalarRelationFilter = {
    is?: ItemTypeWhereInput
    isNot?: ItemTypeWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LootCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    sold_at?: SortOrder
    sold_to?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    source?: SortOrder
    acquired_at?: SortOrder
    itemTypeId?: SortOrder
    sold_to_user_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type LootAvgOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    sold_to_user_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type LootMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    sold_at?: SortOrder
    sold_to?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    source?: SortOrder
    acquired_at?: SortOrder
    itemTypeId?: SortOrder
    sold_to_user_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type LootMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    sold_at?: SortOrder
    sold_to?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    source?: SortOrder
    acquired_at?: SortOrder
    itemTypeId?: SortOrder
    sold_to_user_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type LootSumOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    sold_to_user_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type TasksScalarRelationFilter = {
    is?: TasksWhereInput
    isNot?: TasksWhereInput
  }

  export type TasksUserTasks_user_idUser_idCompoundUniqueInput = {
    tasks_user_id: number
    user_id: number
  }

  export type TasksUserCountOrderByAggregateInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
  }

  export type TasksUserAvgOrderByAggregateInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
  }

  export type TasksUserMaxOrderByAggregateInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
  }

  export type TasksUserMinOrderByAggregateInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
  }

  export type TasksUserSumOrderByAggregateInput = {
    tasks_user_id?: SortOrder
    user_id?: SortOrder
  }

  export type LootQueueCountOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
    synth_target?: SortOrder
    remaining?: SortOrder
    required?: SortOrder
    delivered?: SortOrder
  }

  export type LootQueueAvgOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    remaining?: SortOrder
    required?: SortOrder
    delivered?: SortOrder
  }

  export type LootQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
    synth_target?: SortOrder
    remaining?: SortOrder
    required?: SortOrder
    delivered?: SortOrder
  }

  export type LootQueueMinOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
    synth_target?: SortOrder
    remaining?: SortOrder
    required?: SortOrder
    delivered?: SortOrder
  }

  export type LootQueueSumOrderByAggregateInput = {
    id?: SortOrder
    itemTypeId?: SortOrder
    userId?: SortOrder
    remaining?: SortOrder
    required?: SortOrder
    delivered?: SortOrder
  }

  export type GivenAwayLootUser_idNameCompoundUniqueInput = {
    user_id: number
    name: string
  }

  export type GivenAwayLootCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
  }

  export type GivenAwayLootAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type GivenAwayLootMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
  }

  export type GivenAwayLootMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
  }

  export type GivenAwayLootSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    target?: SortOrder
    source?: SortOrder
    comment?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    target?: SortOrder
    source?: SortOrder
    comment?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    target?: SortOrder
    source?: SortOrder
    comment?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type GuildFundsCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    profit?: SortOrder
    salaryBudget?: SortOrder
    treasuryLeft?: SortOrder
  }

  export type GuildFundsAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    profit?: SortOrder
    salaryBudget?: SortOrder
    treasuryLeft?: SortOrder
  }

  export type GuildFundsMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    profit?: SortOrder
    salaryBudget?: SortOrder
    treasuryLeft?: SortOrder
  }

  export type GuildFundsMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    profit?: SortOrder
    salaryBudget?: SortOrder
    treasuryLeft?: SortOrder
  }

  export type GuildFundsSumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    profit?: SortOrder
    salaryBudget?: SortOrder
    treasuryLeft?: SortOrder
  }

  export type SalaryCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    bonus?: SortOrder
    total?: SortOrder
  }

  export type SalaryAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    bonus?: SortOrder
    total?: SortOrder
  }

  export type SalaryMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    bonus?: SortOrder
    total?: SortOrder
  }

  export type SalaryMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    bonus?: SortOrder
    total?: SortOrder
  }

  export type SalarySumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    bonus?: SortOrder
    total?: SortOrder
  }

  export type UserSalaryBonusCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
  }

  export type UserSalaryBonusAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
  }

  export type UserSalaryBonusMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
  }

  export type UserSalaryBonusMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
  }

  export type UserSalaryBonusSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    amount?: SortOrder
  }

  export type LinkTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
  }

  export type LinkTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LinkTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
  }

  export type LinkTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
  }

  export type LinkTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NewsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NewsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SalaryCreateNestedManyWithoutUserInput = {
    create?: XOR<SalaryCreateWithoutUserInput, SalaryUncheckedCreateWithoutUserInput> | SalaryCreateWithoutUserInput[] | SalaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryCreateOrConnectWithoutUserInput | SalaryCreateOrConnectWithoutUserInput[]
    createMany?: SalaryCreateManyUserInputEnvelope
    connect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
  }

  export type GivenAwayLootCreateNestedManyWithoutUserInput = {
    create?: XOR<GivenAwayLootCreateWithoutUserInput, GivenAwayLootUncheckedCreateWithoutUserInput> | GivenAwayLootCreateWithoutUserInput[] | GivenAwayLootUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GivenAwayLootCreateOrConnectWithoutUserInput | GivenAwayLootCreateOrConnectWithoutUserInput[]
    createMany?: GivenAwayLootCreateManyUserInputEnvelope
    connect?: GivenAwayLootWhereUniqueInput | GivenAwayLootWhereUniqueInput[]
  }

  export type LootCreateNestedManyWithoutSoldToUserInput = {
    create?: XOR<LootCreateWithoutSoldToUserInput, LootUncheckedCreateWithoutSoldToUserInput> | LootCreateWithoutSoldToUserInput[] | LootUncheckedCreateWithoutSoldToUserInput[]
    connectOrCreate?: LootCreateOrConnectWithoutSoldToUserInput | LootCreateOrConnectWithoutSoldToUserInput[]
    createMany?: LootCreateManySoldToUserInputEnvelope
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
  }

  export type LootQueueCreateNestedManyWithoutUserInput = {
    create?: XOR<LootQueueCreateWithoutUserInput, LootQueueUncheckedCreateWithoutUserInput> | LootQueueCreateWithoutUserInput[] | LootQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutUserInput | LootQueueCreateOrConnectWithoutUserInput[]
    createMany?: LootQueueCreateManyUserInputEnvelope
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
  }

  export type RaidAttendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<RaidAttendanceCreateWithoutUserInput, RaidAttendanceUncheckedCreateWithoutUserInput> | RaidAttendanceCreateWithoutUserInput[] | RaidAttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutUserInput | RaidAttendanceCreateOrConnectWithoutUserInput[]
    createMany?: RaidAttendanceCreateManyUserInputEnvelope
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
  }

  export type TasksCreateNestedManyWithoutUserInput = {
    create?: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput> | TasksCreateWithoutUserInput[] | TasksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutUserInput | TasksCreateOrConnectWithoutUserInput[]
    createMany?: TasksCreateManyUserInputEnvelope
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
  }

  export type TasksUserCreateNestedManyWithoutUserInput = {
    create?: XOR<TasksUserCreateWithoutUserInput, TasksUserUncheckedCreateWithoutUserInput> | TasksUserCreateWithoutUserInput[] | TasksUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutUserInput | TasksUserCreateOrConnectWithoutUserInput[]
    createMany?: TasksUserCreateManyUserInputEnvelope
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
  }

  export type UserInventoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInventoryCreateWithoutUserInput, UserInventoryUncheckedCreateWithoutUserInput> | UserInventoryCreateWithoutUserInput[] | UserInventoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryCreateOrConnectWithoutUserInput | UserInventoryCreateOrConnectWithoutUserInput[]
    createMany?: UserInventoryCreateManyUserInputEnvelope
    connect?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
  }

  export type UserSalaryBonusCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSalaryBonusCreateWithoutUserInput, UserSalaryBonusUncheckedCreateWithoutUserInput> | UserSalaryBonusCreateWithoutUserInput[] | UserSalaryBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSalaryBonusCreateOrConnectWithoutUserInput | UserSalaryBonusCreateOrConnectWithoutUserInput[]
    createMany?: UserSalaryBonusCreateManyUserInputEnvelope
    connect?: UserSalaryBonusWhereUniqueInput | UserSalaryBonusWhereUniqueInput[]
  }

  export type UserTagsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput> | UserTagsCreateWithoutUserInput[] | UserTagsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutUserInput | UserTagsCreateOrConnectWithoutUserInput[]
    createMany?: UserTagsCreateManyUserInputEnvelope
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
  }

  export type LinkTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<LinkTokenCreateWithoutUserInput, LinkTokenUncheckedCreateWithoutUserInput> | LinkTokenCreateWithoutUserInput[] | LinkTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LinkTokenCreateOrConnectWithoutUserInput | LinkTokenCreateOrConnectWithoutUserInput[]
    createMany?: LinkTokenCreateManyUserInputEnvelope
    connect?: LinkTokenWhereUniqueInput | LinkTokenWhereUniqueInput[]
  }

  export type SalaryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SalaryCreateWithoutUserInput, SalaryUncheckedCreateWithoutUserInput> | SalaryCreateWithoutUserInput[] | SalaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryCreateOrConnectWithoutUserInput | SalaryCreateOrConnectWithoutUserInput[]
    createMany?: SalaryCreateManyUserInputEnvelope
    connect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
  }

  export type GivenAwayLootUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GivenAwayLootCreateWithoutUserInput, GivenAwayLootUncheckedCreateWithoutUserInput> | GivenAwayLootCreateWithoutUserInput[] | GivenAwayLootUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GivenAwayLootCreateOrConnectWithoutUserInput | GivenAwayLootCreateOrConnectWithoutUserInput[]
    createMany?: GivenAwayLootCreateManyUserInputEnvelope
    connect?: GivenAwayLootWhereUniqueInput | GivenAwayLootWhereUniqueInput[]
  }

  export type LootUncheckedCreateNestedManyWithoutSoldToUserInput = {
    create?: XOR<LootCreateWithoutSoldToUserInput, LootUncheckedCreateWithoutSoldToUserInput> | LootCreateWithoutSoldToUserInput[] | LootUncheckedCreateWithoutSoldToUserInput[]
    connectOrCreate?: LootCreateOrConnectWithoutSoldToUserInput | LootCreateOrConnectWithoutSoldToUserInput[]
    createMany?: LootCreateManySoldToUserInputEnvelope
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
  }

  export type LootQueueUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LootQueueCreateWithoutUserInput, LootQueueUncheckedCreateWithoutUserInput> | LootQueueCreateWithoutUserInput[] | LootQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutUserInput | LootQueueCreateOrConnectWithoutUserInput[]
    createMany?: LootQueueCreateManyUserInputEnvelope
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
  }

  export type RaidAttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RaidAttendanceCreateWithoutUserInput, RaidAttendanceUncheckedCreateWithoutUserInput> | RaidAttendanceCreateWithoutUserInput[] | RaidAttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutUserInput | RaidAttendanceCreateOrConnectWithoutUserInput[]
    createMany?: RaidAttendanceCreateManyUserInputEnvelope
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
  }

  export type TasksUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput> | TasksCreateWithoutUserInput[] | TasksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutUserInput | TasksCreateOrConnectWithoutUserInput[]
    createMany?: TasksCreateManyUserInputEnvelope
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
  }

  export type TasksUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TasksUserCreateWithoutUserInput, TasksUserUncheckedCreateWithoutUserInput> | TasksUserCreateWithoutUserInput[] | TasksUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutUserInput | TasksUserCreateOrConnectWithoutUserInput[]
    createMany?: TasksUserCreateManyUserInputEnvelope
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
  }

  export type UserInventoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserInventoryCreateWithoutUserInput, UserInventoryUncheckedCreateWithoutUserInput> | UserInventoryCreateWithoutUserInput[] | UserInventoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryCreateOrConnectWithoutUserInput | UserInventoryCreateOrConnectWithoutUserInput[]
    createMany?: UserInventoryCreateManyUserInputEnvelope
    connect?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
  }

  export type UserSalaryBonusUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSalaryBonusCreateWithoutUserInput, UserSalaryBonusUncheckedCreateWithoutUserInput> | UserSalaryBonusCreateWithoutUserInput[] | UserSalaryBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSalaryBonusCreateOrConnectWithoutUserInput | UserSalaryBonusCreateOrConnectWithoutUserInput[]
    createMany?: UserSalaryBonusCreateManyUserInputEnvelope
    connect?: UserSalaryBonusWhereUniqueInput | UserSalaryBonusWhereUniqueInput[]
  }

  export type UserTagsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput> | UserTagsCreateWithoutUserInput[] | UserTagsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutUserInput | UserTagsCreateOrConnectWithoutUserInput[]
    createMany?: UserTagsCreateManyUserInputEnvelope
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
  }

  export type LinkTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LinkTokenCreateWithoutUserInput, LinkTokenUncheckedCreateWithoutUserInput> | LinkTokenCreateWithoutUserInput[] | LinkTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LinkTokenCreateOrConnectWithoutUserInput | LinkTokenCreateOrConnectWithoutUserInput[]
    createMany?: LinkTokenCreateManyUserInputEnvelope
    connect?: LinkTokenWhereUniqueInput | LinkTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SalaryUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalaryCreateWithoutUserInput, SalaryUncheckedCreateWithoutUserInput> | SalaryCreateWithoutUserInput[] | SalaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryCreateOrConnectWithoutUserInput | SalaryCreateOrConnectWithoutUserInput[]
    upsert?: SalaryUpsertWithWhereUniqueWithoutUserInput | SalaryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalaryCreateManyUserInputEnvelope
    set?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    disconnect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    delete?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    connect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    update?: SalaryUpdateWithWhereUniqueWithoutUserInput | SalaryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalaryUpdateManyWithWhereWithoutUserInput | SalaryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalaryScalarWhereInput | SalaryScalarWhereInput[]
  }

  export type GivenAwayLootUpdateManyWithoutUserNestedInput = {
    create?: XOR<GivenAwayLootCreateWithoutUserInput, GivenAwayLootUncheckedCreateWithoutUserInput> | GivenAwayLootCreateWithoutUserInput[] | GivenAwayLootUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GivenAwayLootCreateOrConnectWithoutUserInput | GivenAwayLootCreateOrConnectWithoutUserInput[]
    upsert?: GivenAwayLootUpsertWithWhereUniqueWithoutUserInput | GivenAwayLootUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GivenAwayLootCreateManyUserInputEnvelope
    set?: GivenAwayLootWhereUniqueInput | GivenAwayLootWhereUniqueInput[]
    disconnect?: GivenAwayLootWhereUniqueInput | GivenAwayLootWhereUniqueInput[]
    delete?: GivenAwayLootWhereUniqueInput | GivenAwayLootWhereUniqueInput[]
    connect?: GivenAwayLootWhereUniqueInput | GivenAwayLootWhereUniqueInput[]
    update?: GivenAwayLootUpdateWithWhereUniqueWithoutUserInput | GivenAwayLootUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GivenAwayLootUpdateManyWithWhereWithoutUserInput | GivenAwayLootUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GivenAwayLootScalarWhereInput | GivenAwayLootScalarWhereInput[]
  }

  export type LootUpdateManyWithoutSoldToUserNestedInput = {
    create?: XOR<LootCreateWithoutSoldToUserInput, LootUncheckedCreateWithoutSoldToUserInput> | LootCreateWithoutSoldToUserInput[] | LootUncheckedCreateWithoutSoldToUserInput[]
    connectOrCreate?: LootCreateOrConnectWithoutSoldToUserInput | LootCreateOrConnectWithoutSoldToUserInput[]
    upsert?: LootUpsertWithWhereUniqueWithoutSoldToUserInput | LootUpsertWithWhereUniqueWithoutSoldToUserInput[]
    createMany?: LootCreateManySoldToUserInputEnvelope
    set?: LootWhereUniqueInput | LootWhereUniqueInput[]
    disconnect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    delete?: LootWhereUniqueInput | LootWhereUniqueInput[]
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    update?: LootUpdateWithWhereUniqueWithoutSoldToUserInput | LootUpdateWithWhereUniqueWithoutSoldToUserInput[]
    updateMany?: LootUpdateManyWithWhereWithoutSoldToUserInput | LootUpdateManyWithWhereWithoutSoldToUserInput[]
    deleteMany?: LootScalarWhereInput | LootScalarWhereInput[]
  }

  export type LootQueueUpdateManyWithoutUserNestedInput = {
    create?: XOR<LootQueueCreateWithoutUserInput, LootQueueUncheckedCreateWithoutUserInput> | LootQueueCreateWithoutUserInput[] | LootQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutUserInput | LootQueueCreateOrConnectWithoutUserInput[]
    upsert?: LootQueueUpsertWithWhereUniqueWithoutUserInput | LootQueueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LootQueueCreateManyUserInputEnvelope
    set?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    disconnect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    delete?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    update?: LootQueueUpdateWithWhereUniqueWithoutUserInput | LootQueueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LootQueueUpdateManyWithWhereWithoutUserInput | LootQueueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LootQueueScalarWhereInput | LootQueueScalarWhereInput[]
  }

  export type RaidAttendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<RaidAttendanceCreateWithoutUserInput, RaidAttendanceUncheckedCreateWithoutUserInput> | RaidAttendanceCreateWithoutUserInput[] | RaidAttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutUserInput | RaidAttendanceCreateOrConnectWithoutUserInput[]
    upsert?: RaidAttendanceUpsertWithWhereUniqueWithoutUserInput | RaidAttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RaidAttendanceCreateManyUserInputEnvelope
    set?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    disconnect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    delete?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    update?: RaidAttendanceUpdateWithWhereUniqueWithoutUserInput | RaidAttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RaidAttendanceUpdateManyWithWhereWithoutUserInput | RaidAttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RaidAttendanceScalarWhereInput | RaidAttendanceScalarWhereInput[]
  }

  export type TasksUpdateManyWithoutUserNestedInput = {
    create?: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput> | TasksCreateWithoutUserInput[] | TasksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutUserInput | TasksCreateOrConnectWithoutUserInput[]
    upsert?: TasksUpsertWithWhereUniqueWithoutUserInput | TasksUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TasksCreateManyUserInputEnvelope
    set?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    disconnect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    delete?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    update?: TasksUpdateWithWhereUniqueWithoutUserInput | TasksUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TasksUpdateManyWithWhereWithoutUserInput | TasksUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TasksScalarWhereInput | TasksScalarWhereInput[]
  }

  export type TasksUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<TasksUserCreateWithoutUserInput, TasksUserUncheckedCreateWithoutUserInput> | TasksUserCreateWithoutUserInput[] | TasksUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutUserInput | TasksUserCreateOrConnectWithoutUserInput[]
    upsert?: TasksUserUpsertWithWhereUniqueWithoutUserInput | TasksUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TasksUserCreateManyUserInputEnvelope
    set?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    disconnect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    delete?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    update?: TasksUserUpdateWithWhereUniqueWithoutUserInput | TasksUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TasksUserUpdateManyWithWhereWithoutUserInput | TasksUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TasksUserScalarWhereInput | TasksUserScalarWhereInput[]
  }

  export type UserInventoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInventoryCreateWithoutUserInput, UserInventoryUncheckedCreateWithoutUserInput> | UserInventoryCreateWithoutUserInput[] | UserInventoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryCreateOrConnectWithoutUserInput | UserInventoryCreateOrConnectWithoutUserInput[]
    upsert?: UserInventoryUpsertWithWhereUniqueWithoutUserInput | UserInventoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInventoryCreateManyUserInputEnvelope
    set?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    disconnect?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    delete?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    connect?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    update?: UserInventoryUpdateWithWhereUniqueWithoutUserInput | UserInventoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInventoryUpdateManyWithWhereWithoutUserInput | UserInventoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInventoryScalarWhereInput | UserInventoryScalarWhereInput[]
  }

  export type UserSalaryBonusUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSalaryBonusCreateWithoutUserInput, UserSalaryBonusUncheckedCreateWithoutUserInput> | UserSalaryBonusCreateWithoutUserInput[] | UserSalaryBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSalaryBonusCreateOrConnectWithoutUserInput | UserSalaryBonusCreateOrConnectWithoutUserInput[]
    upsert?: UserSalaryBonusUpsertWithWhereUniqueWithoutUserInput | UserSalaryBonusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSalaryBonusCreateManyUserInputEnvelope
    set?: UserSalaryBonusWhereUniqueInput | UserSalaryBonusWhereUniqueInput[]
    disconnect?: UserSalaryBonusWhereUniqueInput | UserSalaryBonusWhereUniqueInput[]
    delete?: UserSalaryBonusWhereUniqueInput | UserSalaryBonusWhereUniqueInput[]
    connect?: UserSalaryBonusWhereUniqueInput | UserSalaryBonusWhereUniqueInput[]
    update?: UserSalaryBonusUpdateWithWhereUniqueWithoutUserInput | UserSalaryBonusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSalaryBonusUpdateManyWithWhereWithoutUserInput | UserSalaryBonusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSalaryBonusScalarWhereInput | UserSalaryBonusScalarWhereInput[]
  }

  export type UserTagsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput> | UserTagsCreateWithoutUserInput[] | UserTagsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutUserInput | UserTagsCreateOrConnectWithoutUserInput[]
    upsert?: UserTagsUpsertWithWhereUniqueWithoutUserInput | UserTagsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTagsCreateManyUserInputEnvelope
    set?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    disconnect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    delete?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    update?: UserTagsUpdateWithWhereUniqueWithoutUserInput | UserTagsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTagsUpdateManyWithWhereWithoutUserInput | UserTagsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
  }

  export type LinkTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<LinkTokenCreateWithoutUserInput, LinkTokenUncheckedCreateWithoutUserInput> | LinkTokenCreateWithoutUserInput[] | LinkTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LinkTokenCreateOrConnectWithoutUserInput | LinkTokenCreateOrConnectWithoutUserInput[]
    upsert?: LinkTokenUpsertWithWhereUniqueWithoutUserInput | LinkTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LinkTokenCreateManyUserInputEnvelope
    set?: LinkTokenWhereUniqueInput | LinkTokenWhereUniqueInput[]
    disconnect?: LinkTokenWhereUniqueInput | LinkTokenWhereUniqueInput[]
    delete?: LinkTokenWhereUniqueInput | LinkTokenWhereUniqueInput[]
    connect?: LinkTokenWhereUniqueInput | LinkTokenWhereUniqueInput[]
    update?: LinkTokenUpdateWithWhereUniqueWithoutUserInput | LinkTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LinkTokenUpdateManyWithWhereWithoutUserInput | LinkTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LinkTokenScalarWhereInput | LinkTokenScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SalaryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalaryCreateWithoutUserInput, SalaryUncheckedCreateWithoutUserInput> | SalaryCreateWithoutUserInput[] | SalaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalaryCreateOrConnectWithoutUserInput | SalaryCreateOrConnectWithoutUserInput[]
    upsert?: SalaryUpsertWithWhereUniqueWithoutUserInput | SalaryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalaryCreateManyUserInputEnvelope
    set?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    disconnect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    delete?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    connect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    update?: SalaryUpdateWithWhereUniqueWithoutUserInput | SalaryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalaryUpdateManyWithWhereWithoutUserInput | SalaryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalaryScalarWhereInput | SalaryScalarWhereInput[]
  }

  export type GivenAwayLootUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GivenAwayLootCreateWithoutUserInput, GivenAwayLootUncheckedCreateWithoutUserInput> | GivenAwayLootCreateWithoutUserInput[] | GivenAwayLootUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GivenAwayLootCreateOrConnectWithoutUserInput | GivenAwayLootCreateOrConnectWithoutUserInput[]
    upsert?: GivenAwayLootUpsertWithWhereUniqueWithoutUserInput | GivenAwayLootUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GivenAwayLootCreateManyUserInputEnvelope
    set?: GivenAwayLootWhereUniqueInput | GivenAwayLootWhereUniqueInput[]
    disconnect?: GivenAwayLootWhereUniqueInput | GivenAwayLootWhereUniqueInput[]
    delete?: GivenAwayLootWhereUniqueInput | GivenAwayLootWhereUniqueInput[]
    connect?: GivenAwayLootWhereUniqueInput | GivenAwayLootWhereUniqueInput[]
    update?: GivenAwayLootUpdateWithWhereUniqueWithoutUserInput | GivenAwayLootUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GivenAwayLootUpdateManyWithWhereWithoutUserInput | GivenAwayLootUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GivenAwayLootScalarWhereInput | GivenAwayLootScalarWhereInput[]
  }

  export type LootUncheckedUpdateManyWithoutSoldToUserNestedInput = {
    create?: XOR<LootCreateWithoutSoldToUserInput, LootUncheckedCreateWithoutSoldToUserInput> | LootCreateWithoutSoldToUserInput[] | LootUncheckedCreateWithoutSoldToUserInput[]
    connectOrCreate?: LootCreateOrConnectWithoutSoldToUserInput | LootCreateOrConnectWithoutSoldToUserInput[]
    upsert?: LootUpsertWithWhereUniqueWithoutSoldToUserInput | LootUpsertWithWhereUniqueWithoutSoldToUserInput[]
    createMany?: LootCreateManySoldToUserInputEnvelope
    set?: LootWhereUniqueInput | LootWhereUniqueInput[]
    disconnect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    delete?: LootWhereUniqueInput | LootWhereUniqueInput[]
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    update?: LootUpdateWithWhereUniqueWithoutSoldToUserInput | LootUpdateWithWhereUniqueWithoutSoldToUserInput[]
    updateMany?: LootUpdateManyWithWhereWithoutSoldToUserInput | LootUpdateManyWithWhereWithoutSoldToUserInput[]
    deleteMany?: LootScalarWhereInput | LootScalarWhereInput[]
  }

  export type LootQueueUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LootQueueCreateWithoutUserInput, LootQueueUncheckedCreateWithoutUserInput> | LootQueueCreateWithoutUserInput[] | LootQueueUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutUserInput | LootQueueCreateOrConnectWithoutUserInput[]
    upsert?: LootQueueUpsertWithWhereUniqueWithoutUserInput | LootQueueUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LootQueueCreateManyUserInputEnvelope
    set?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    disconnect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    delete?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    update?: LootQueueUpdateWithWhereUniqueWithoutUserInput | LootQueueUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LootQueueUpdateManyWithWhereWithoutUserInput | LootQueueUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LootQueueScalarWhereInput | LootQueueScalarWhereInput[]
  }

  export type RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RaidAttendanceCreateWithoutUserInput, RaidAttendanceUncheckedCreateWithoutUserInput> | RaidAttendanceCreateWithoutUserInput[] | RaidAttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutUserInput | RaidAttendanceCreateOrConnectWithoutUserInput[]
    upsert?: RaidAttendanceUpsertWithWhereUniqueWithoutUserInput | RaidAttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RaidAttendanceCreateManyUserInputEnvelope
    set?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    disconnect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    delete?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    update?: RaidAttendanceUpdateWithWhereUniqueWithoutUserInput | RaidAttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RaidAttendanceUpdateManyWithWhereWithoutUserInput | RaidAttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RaidAttendanceScalarWhereInput | RaidAttendanceScalarWhereInput[]
  }

  export type TasksUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput> | TasksCreateWithoutUserInput[] | TasksUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksCreateOrConnectWithoutUserInput | TasksCreateOrConnectWithoutUserInput[]
    upsert?: TasksUpsertWithWhereUniqueWithoutUserInput | TasksUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TasksCreateManyUserInputEnvelope
    set?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    disconnect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    delete?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    connect?: TasksWhereUniqueInput | TasksWhereUniqueInput[]
    update?: TasksUpdateWithWhereUniqueWithoutUserInput | TasksUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TasksUpdateManyWithWhereWithoutUserInput | TasksUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TasksScalarWhereInput | TasksScalarWhereInput[]
  }

  export type TasksUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TasksUserCreateWithoutUserInput, TasksUserUncheckedCreateWithoutUserInput> | TasksUserCreateWithoutUserInput[] | TasksUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutUserInput | TasksUserCreateOrConnectWithoutUserInput[]
    upsert?: TasksUserUpsertWithWhereUniqueWithoutUserInput | TasksUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TasksUserCreateManyUserInputEnvelope
    set?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    disconnect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    delete?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    update?: TasksUserUpdateWithWhereUniqueWithoutUserInput | TasksUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TasksUserUpdateManyWithWhereWithoutUserInput | TasksUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TasksUserScalarWhereInput | TasksUserScalarWhereInput[]
  }

  export type UserInventoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserInventoryCreateWithoutUserInput, UserInventoryUncheckedCreateWithoutUserInput> | UserInventoryCreateWithoutUserInput[] | UserInventoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserInventoryCreateOrConnectWithoutUserInput | UserInventoryCreateOrConnectWithoutUserInput[]
    upsert?: UserInventoryUpsertWithWhereUniqueWithoutUserInput | UserInventoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserInventoryCreateManyUserInputEnvelope
    set?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    disconnect?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    delete?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    connect?: UserInventoryWhereUniqueInput | UserInventoryWhereUniqueInput[]
    update?: UserInventoryUpdateWithWhereUniqueWithoutUserInput | UserInventoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserInventoryUpdateManyWithWhereWithoutUserInput | UserInventoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserInventoryScalarWhereInput | UserInventoryScalarWhereInput[]
  }

  export type UserSalaryBonusUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSalaryBonusCreateWithoutUserInput, UserSalaryBonusUncheckedCreateWithoutUserInput> | UserSalaryBonusCreateWithoutUserInput[] | UserSalaryBonusUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSalaryBonusCreateOrConnectWithoutUserInput | UserSalaryBonusCreateOrConnectWithoutUserInput[]
    upsert?: UserSalaryBonusUpsertWithWhereUniqueWithoutUserInput | UserSalaryBonusUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSalaryBonusCreateManyUserInputEnvelope
    set?: UserSalaryBonusWhereUniqueInput | UserSalaryBonusWhereUniqueInput[]
    disconnect?: UserSalaryBonusWhereUniqueInput | UserSalaryBonusWhereUniqueInput[]
    delete?: UserSalaryBonusWhereUniqueInput | UserSalaryBonusWhereUniqueInput[]
    connect?: UserSalaryBonusWhereUniqueInput | UserSalaryBonusWhereUniqueInput[]
    update?: UserSalaryBonusUpdateWithWhereUniqueWithoutUserInput | UserSalaryBonusUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSalaryBonusUpdateManyWithWhereWithoutUserInput | UserSalaryBonusUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSalaryBonusScalarWhereInput | UserSalaryBonusScalarWhereInput[]
  }

  export type UserTagsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput> | UserTagsCreateWithoutUserInput[] | UserTagsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagsCreateOrConnectWithoutUserInput | UserTagsCreateOrConnectWithoutUserInput[]
    upsert?: UserTagsUpsertWithWhereUniqueWithoutUserInput | UserTagsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTagsCreateManyUserInputEnvelope
    set?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    disconnect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    delete?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    connect?: UserTagsWhereUniqueInput | UserTagsWhereUniqueInput[]
    update?: UserTagsUpdateWithWhereUniqueWithoutUserInput | UserTagsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTagsUpdateManyWithWhereWithoutUserInput | UserTagsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
  }

  export type LinkTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LinkTokenCreateWithoutUserInput, LinkTokenUncheckedCreateWithoutUserInput> | LinkTokenCreateWithoutUserInput[] | LinkTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LinkTokenCreateOrConnectWithoutUserInput | LinkTokenCreateOrConnectWithoutUserInput[]
    upsert?: LinkTokenUpsertWithWhereUniqueWithoutUserInput | LinkTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LinkTokenCreateManyUserInputEnvelope
    set?: LinkTokenWhereUniqueInput | LinkTokenWhereUniqueInput[]
    disconnect?: LinkTokenWhereUniqueInput | LinkTokenWhereUniqueInput[]
    delete?: LinkTokenWhereUniqueInput | LinkTokenWhereUniqueInput[]
    connect?: LinkTokenWhereUniqueInput | LinkTokenWhereUniqueInput[]
    update?: LinkTokenUpdateWithWhereUniqueWithoutUserInput | LinkTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LinkTokenUpdateManyWithWhereWithoutUserInput | LinkTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LinkTokenScalarWhereInput | LinkTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTagsInput = {
    create?: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagsInput
    upsert?: UserUpsertWithoutTagsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTagsInput, UserUpdateWithoutTagsInput>, UserUncheckedUpdateWithoutTagsInput>
  }

  export type UserCreateNestedOneWithoutInventoryInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryInput
    upsert?: UserUpsertWithoutInventoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryInput, UserUpdateWithoutInventoryInput>, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    connect?: UserWhereUniqueInput
  }

  export type TasksUserCreateNestedManyWithoutTaskInput = {
    create?: XOR<TasksUserCreateWithoutTaskInput, TasksUserUncheckedCreateWithoutTaskInput> | TasksUserCreateWithoutTaskInput[] | TasksUserUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutTaskInput | TasksUserCreateOrConnectWithoutTaskInput[]
    createMany?: TasksUserCreateManyTaskInputEnvelope
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
  }

  export type TasksUserUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TasksUserCreateWithoutTaskInput, TasksUserUncheckedCreateWithoutTaskInput> | TasksUserCreateWithoutTaskInput[] | TasksUserUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutTaskInput | TasksUserCreateOrConnectWithoutTaskInput[]
    createMany?: TasksUserCreateManyTaskInputEnvelope
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    upsert?: UserUpsertWithoutTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksInput, UserUpdateWithoutTasksInput>, UserUncheckedUpdateWithoutTasksInput>
  }

  export type TasksUserUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TasksUserCreateWithoutTaskInput, TasksUserUncheckedCreateWithoutTaskInput> | TasksUserCreateWithoutTaskInput[] | TasksUserUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutTaskInput | TasksUserCreateOrConnectWithoutTaskInput[]
    upsert?: TasksUserUpsertWithWhereUniqueWithoutTaskInput | TasksUserUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TasksUserCreateManyTaskInputEnvelope
    set?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    disconnect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    delete?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    update?: TasksUserUpdateWithWhereUniqueWithoutTaskInput | TasksUserUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TasksUserUpdateManyWithWhereWithoutTaskInput | TasksUserUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TasksUserScalarWhereInput | TasksUserScalarWhereInput[]
  }

  export type TasksUserUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TasksUserCreateWithoutTaskInput, TasksUserUncheckedCreateWithoutTaskInput> | TasksUserCreateWithoutTaskInput[] | TasksUserUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TasksUserCreateOrConnectWithoutTaskInput | TasksUserCreateOrConnectWithoutTaskInput[]
    upsert?: TasksUserUpsertWithWhereUniqueWithoutTaskInput | TasksUserUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TasksUserCreateManyTaskInputEnvelope
    set?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    disconnect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    delete?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    connect?: TasksUserWhereUniqueInput | TasksUserWhereUniqueInput[]
    update?: TasksUserUpdateWithWhereUniqueWithoutTaskInput | TasksUserUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TasksUserUpdateManyWithWhereWithoutTaskInput | TasksUserUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TasksUserScalarWhereInput | TasksUserScalarWhereInput[]
  }

  export type RaidAttendanceCreateNestedManyWithoutRaidInput = {
    create?: XOR<RaidAttendanceCreateWithoutRaidInput, RaidAttendanceUncheckedCreateWithoutRaidInput> | RaidAttendanceCreateWithoutRaidInput[] | RaidAttendanceUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutRaidInput | RaidAttendanceCreateOrConnectWithoutRaidInput[]
    createMany?: RaidAttendanceCreateManyRaidInputEnvelope
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
  }

  export type RaidBossCreateNestedManyWithoutRaidInput = {
    create?: XOR<RaidBossCreateWithoutRaidInput, RaidBossUncheckedCreateWithoutRaidInput> | RaidBossCreateWithoutRaidInput[] | RaidBossUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutRaidInput | RaidBossCreateOrConnectWithoutRaidInput[]
    createMany?: RaidBossCreateManyRaidInputEnvelope
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
  }

  export type RaidAttendanceUncheckedCreateNestedManyWithoutRaidInput = {
    create?: XOR<RaidAttendanceCreateWithoutRaidInput, RaidAttendanceUncheckedCreateWithoutRaidInput> | RaidAttendanceCreateWithoutRaidInput[] | RaidAttendanceUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutRaidInput | RaidAttendanceCreateOrConnectWithoutRaidInput[]
    createMany?: RaidAttendanceCreateManyRaidInputEnvelope
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
  }

  export type RaidBossUncheckedCreateNestedManyWithoutRaidInput = {
    create?: XOR<RaidBossCreateWithoutRaidInput, RaidBossUncheckedCreateWithoutRaidInput> | RaidBossCreateWithoutRaidInput[] | RaidBossUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutRaidInput | RaidBossCreateOrConnectWithoutRaidInput[]
    createMany?: RaidBossCreateManyRaidInputEnvelope
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type RaidAttendanceUpdateManyWithoutRaidNestedInput = {
    create?: XOR<RaidAttendanceCreateWithoutRaidInput, RaidAttendanceUncheckedCreateWithoutRaidInput> | RaidAttendanceCreateWithoutRaidInput[] | RaidAttendanceUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutRaidInput | RaidAttendanceCreateOrConnectWithoutRaidInput[]
    upsert?: RaidAttendanceUpsertWithWhereUniqueWithoutRaidInput | RaidAttendanceUpsertWithWhereUniqueWithoutRaidInput[]
    createMany?: RaidAttendanceCreateManyRaidInputEnvelope
    set?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    disconnect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    delete?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    update?: RaidAttendanceUpdateWithWhereUniqueWithoutRaidInput | RaidAttendanceUpdateWithWhereUniqueWithoutRaidInput[]
    updateMany?: RaidAttendanceUpdateManyWithWhereWithoutRaidInput | RaidAttendanceUpdateManyWithWhereWithoutRaidInput[]
    deleteMany?: RaidAttendanceScalarWhereInput | RaidAttendanceScalarWhereInput[]
  }

  export type RaidBossUpdateManyWithoutRaidNestedInput = {
    create?: XOR<RaidBossCreateWithoutRaidInput, RaidBossUncheckedCreateWithoutRaidInput> | RaidBossCreateWithoutRaidInput[] | RaidBossUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutRaidInput | RaidBossCreateOrConnectWithoutRaidInput[]
    upsert?: RaidBossUpsertWithWhereUniqueWithoutRaidInput | RaidBossUpsertWithWhereUniqueWithoutRaidInput[]
    createMany?: RaidBossCreateManyRaidInputEnvelope
    set?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    disconnect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    delete?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    update?: RaidBossUpdateWithWhereUniqueWithoutRaidInput | RaidBossUpdateWithWhereUniqueWithoutRaidInput[]
    updateMany?: RaidBossUpdateManyWithWhereWithoutRaidInput | RaidBossUpdateManyWithWhereWithoutRaidInput[]
    deleteMany?: RaidBossScalarWhereInput | RaidBossScalarWhereInput[]
  }

  export type RaidAttendanceUncheckedUpdateManyWithoutRaidNestedInput = {
    create?: XOR<RaidAttendanceCreateWithoutRaidInput, RaidAttendanceUncheckedCreateWithoutRaidInput> | RaidAttendanceCreateWithoutRaidInput[] | RaidAttendanceUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidAttendanceCreateOrConnectWithoutRaidInput | RaidAttendanceCreateOrConnectWithoutRaidInput[]
    upsert?: RaidAttendanceUpsertWithWhereUniqueWithoutRaidInput | RaidAttendanceUpsertWithWhereUniqueWithoutRaidInput[]
    createMany?: RaidAttendanceCreateManyRaidInputEnvelope
    set?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    disconnect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    delete?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    connect?: RaidAttendanceWhereUniqueInput | RaidAttendanceWhereUniqueInput[]
    update?: RaidAttendanceUpdateWithWhereUniqueWithoutRaidInput | RaidAttendanceUpdateWithWhereUniqueWithoutRaidInput[]
    updateMany?: RaidAttendanceUpdateManyWithWhereWithoutRaidInput | RaidAttendanceUpdateManyWithWhereWithoutRaidInput[]
    deleteMany?: RaidAttendanceScalarWhereInput | RaidAttendanceScalarWhereInput[]
  }

  export type RaidBossUncheckedUpdateManyWithoutRaidNestedInput = {
    create?: XOR<RaidBossCreateWithoutRaidInput, RaidBossUncheckedCreateWithoutRaidInput> | RaidBossCreateWithoutRaidInput[] | RaidBossUncheckedCreateWithoutRaidInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutRaidInput | RaidBossCreateOrConnectWithoutRaidInput[]
    upsert?: RaidBossUpsertWithWhereUniqueWithoutRaidInput | RaidBossUpsertWithWhereUniqueWithoutRaidInput[]
    createMany?: RaidBossCreateManyRaidInputEnvelope
    set?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    disconnect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    delete?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    update?: RaidBossUpdateWithWhereUniqueWithoutRaidInput | RaidBossUpdateWithWhereUniqueWithoutRaidInput[]
    updateMany?: RaidBossUpdateManyWithWhereWithoutRaidInput | RaidBossUpdateManyWithWhereWithoutRaidInput[]
    deleteMany?: RaidBossScalarWhereInput | RaidBossScalarWhereInput[]
  }

  export type RaidBossCreateNestedManyWithoutBossInput = {
    create?: XOR<RaidBossCreateWithoutBossInput, RaidBossUncheckedCreateWithoutBossInput> | RaidBossCreateWithoutBossInput[] | RaidBossUncheckedCreateWithoutBossInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutBossInput | RaidBossCreateOrConnectWithoutBossInput[]
    createMany?: RaidBossCreateManyBossInputEnvelope
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
  }

  export type RaidBossUncheckedCreateNestedManyWithoutBossInput = {
    create?: XOR<RaidBossCreateWithoutBossInput, RaidBossUncheckedCreateWithoutBossInput> | RaidBossCreateWithoutBossInput[] | RaidBossUncheckedCreateWithoutBossInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutBossInput | RaidBossCreateOrConnectWithoutBossInput[]
    createMany?: RaidBossCreateManyBossInputEnvelope
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
  }

  export type RaidBossUpdateManyWithoutBossNestedInput = {
    create?: XOR<RaidBossCreateWithoutBossInput, RaidBossUncheckedCreateWithoutBossInput> | RaidBossCreateWithoutBossInput[] | RaidBossUncheckedCreateWithoutBossInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutBossInput | RaidBossCreateOrConnectWithoutBossInput[]
    upsert?: RaidBossUpsertWithWhereUniqueWithoutBossInput | RaidBossUpsertWithWhereUniqueWithoutBossInput[]
    createMany?: RaidBossCreateManyBossInputEnvelope
    set?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    disconnect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    delete?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    update?: RaidBossUpdateWithWhereUniqueWithoutBossInput | RaidBossUpdateWithWhereUniqueWithoutBossInput[]
    updateMany?: RaidBossUpdateManyWithWhereWithoutBossInput | RaidBossUpdateManyWithWhereWithoutBossInput[]
    deleteMany?: RaidBossScalarWhereInput | RaidBossScalarWhereInput[]
  }

  export type RaidBossUncheckedUpdateManyWithoutBossNestedInput = {
    create?: XOR<RaidBossCreateWithoutBossInput, RaidBossUncheckedCreateWithoutBossInput> | RaidBossCreateWithoutBossInput[] | RaidBossUncheckedCreateWithoutBossInput[]
    connectOrCreate?: RaidBossCreateOrConnectWithoutBossInput | RaidBossCreateOrConnectWithoutBossInput[]
    upsert?: RaidBossUpsertWithWhereUniqueWithoutBossInput | RaidBossUpsertWithWhereUniqueWithoutBossInput[]
    createMany?: RaidBossCreateManyBossInputEnvelope
    set?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    disconnect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    delete?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    connect?: RaidBossWhereUniqueInput | RaidBossWhereUniqueInput[]
    update?: RaidBossUpdateWithWhereUniqueWithoutBossInput | RaidBossUpdateWithWhereUniqueWithoutBossInput[]
    updateMany?: RaidBossUpdateManyWithWhereWithoutBossInput | RaidBossUpdateManyWithWhereWithoutBossInput[]
    deleteMany?: RaidBossScalarWhereInput | RaidBossScalarWhereInput[]
  }

  export type BossCreateNestedOneWithoutRaidBossesInput = {
    create?: XOR<BossCreateWithoutRaidBossesInput, BossUncheckedCreateWithoutRaidBossesInput>
    connectOrCreate?: BossCreateOrConnectWithoutRaidBossesInput
    connect?: BossWhereUniqueInput
  }

  export type RaidCreateNestedOneWithoutRaidBossesInput = {
    create?: XOR<RaidCreateWithoutRaidBossesInput, RaidUncheckedCreateWithoutRaidBossesInput>
    connectOrCreate?: RaidCreateOrConnectWithoutRaidBossesInput
    connect?: RaidWhereUniqueInput
  }

  export type BossUpdateOneRequiredWithoutRaidBossesNestedInput = {
    create?: XOR<BossCreateWithoutRaidBossesInput, BossUncheckedCreateWithoutRaidBossesInput>
    connectOrCreate?: BossCreateOrConnectWithoutRaidBossesInput
    upsert?: BossUpsertWithoutRaidBossesInput
    connect?: BossWhereUniqueInput
    update?: XOR<XOR<BossUpdateToOneWithWhereWithoutRaidBossesInput, BossUpdateWithoutRaidBossesInput>, BossUncheckedUpdateWithoutRaidBossesInput>
  }

  export type RaidUpdateOneRequiredWithoutRaidBossesNestedInput = {
    create?: XOR<RaidCreateWithoutRaidBossesInput, RaidUncheckedCreateWithoutRaidBossesInput>
    connectOrCreate?: RaidCreateOrConnectWithoutRaidBossesInput
    upsert?: RaidUpsertWithoutRaidBossesInput
    connect?: RaidWhereUniqueInput
    update?: XOR<XOR<RaidUpdateToOneWithWhereWithoutRaidBossesInput, RaidUpdateWithoutRaidBossesInput>, RaidUncheckedUpdateWithoutRaidBossesInput>
  }

  export type RaidCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<RaidCreateWithoutAttendanceInput, RaidUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: RaidCreateOrConnectWithoutAttendanceInput
    connect?: RaidWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRaidAttendanceInput = {
    create?: XOR<UserCreateWithoutRaidAttendanceInput, UserUncheckedCreateWithoutRaidAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutRaidAttendanceInput
    connect?: UserWhereUniqueInput
  }

  export type RaidUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<RaidCreateWithoutAttendanceInput, RaidUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: RaidCreateOrConnectWithoutAttendanceInput
    upsert?: RaidUpsertWithoutAttendanceInput
    connect?: RaidWhereUniqueInput
    update?: XOR<XOR<RaidUpdateToOneWithWhereWithoutAttendanceInput, RaidUpdateWithoutAttendanceInput>, RaidUncheckedUpdateWithoutAttendanceInput>
  }

  export type UserUpdateOneRequiredWithoutRaidAttendanceNestedInput = {
    create?: XOR<UserCreateWithoutRaidAttendanceInput, UserUncheckedCreateWithoutRaidAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutRaidAttendanceInput
    upsert?: UserUpsertWithoutRaidAttendanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRaidAttendanceInput, UserUpdateWithoutRaidAttendanceInput>, UserUncheckedUpdateWithoutRaidAttendanceInput>
  }

  export type LootCreateNestedManyWithoutItemTypeInput = {
    create?: XOR<LootCreateWithoutItemTypeInput, LootUncheckedCreateWithoutItemTypeInput> | LootCreateWithoutItemTypeInput[] | LootUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootCreateOrConnectWithoutItemTypeInput | LootCreateOrConnectWithoutItemTypeInput[]
    createMany?: LootCreateManyItemTypeInputEnvelope
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
  }

  export type LootQueueCreateNestedManyWithoutItemTypeInput = {
    create?: XOR<LootQueueCreateWithoutItemTypeInput, LootQueueUncheckedCreateWithoutItemTypeInput> | LootQueueCreateWithoutItemTypeInput[] | LootQueueUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutItemTypeInput | LootQueueCreateOrConnectWithoutItemTypeInput[]
    createMany?: LootQueueCreateManyItemTypeInputEnvelope
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
  }

  export type LootUncheckedCreateNestedManyWithoutItemTypeInput = {
    create?: XOR<LootCreateWithoutItemTypeInput, LootUncheckedCreateWithoutItemTypeInput> | LootCreateWithoutItemTypeInput[] | LootUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootCreateOrConnectWithoutItemTypeInput | LootCreateOrConnectWithoutItemTypeInput[]
    createMany?: LootCreateManyItemTypeInputEnvelope
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
  }

  export type LootQueueUncheckedCreateNestedManyWithoutItemTypeInput = {
    create?: XOR<LootQueueCreateWithoutItemTypeInput, LootQueueUncheckedCreateWithoutItemTypeInput> | LootQueueCreateWithoutItemTypeInput[] | LootQueueUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutItemTypeInput | LootQueueCreateOrConnectWithoutItemTypeInput[]
    createMany?: LootQueueCreateManyItemTypeInputEnvelope
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LootUpdateManyWithoutItemTypeNestedInput = {
    create?: XOR<LootCreateWithoutItemTypeInput, LootUncheckedCreateWithoutItemTypeInput> | LootCreateWithoutItemTypeInput[] | LootUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootCreateOrConnectWithoutItemTypeInput | LootCreateOrConnectWithoutItemTypeInput[]
    upsert?: LootUpsertWithWhereUniqueWithoutItemTypeInput | LootUpsertWithWhereUniqueWithoutItemTypeInput[]
    createMany?: LootCreateManyItemTypeInputEnvelope
    set?: LootWhereUniqueInput | LootWhereUniqueInput[]
    disconnect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    delete?: LootWhereUniqueInput | LootWhereUniqueInput[]
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    update?: LootUpdateWithWhereUniqueWithoutItemTypeInput | LootUpdateWithWhereUniqueWithoutItemTypeInput[]
    updateMany?: LootUpdateManyWithWhereWithoutItemTypeInput | LootUpdateManyWithWhereWithoutItemTypeInput[]
    deleteMany?: LootScalarWhereInput | LootScalarWhereInput[]
  }

  export type LootQueueUpdateManyWithoutItemTypeNestedInput = {
    create?: XOR<LootQueueCreateWithoutItemTypeInput, LootQueueUncheckedCreateWithoutItemTypeInput> | LootQueueCreateWithoutItemTypeInput[] | LootQueueUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutItemTypeInput | LootQueueCreateOrConnectWithoutItemTypeInput[]
    upsert?: LootQueueUpsertWithWhereUniqueWithoutItemTypeInput | LootQueueUpsertWithWhereUniqueWithoutItemTypeInput[]
    createMany?: LootQueueCreateManyItemTypeInputEnvelope
    set?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    disconnect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    delete?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    update?: LootQueueUpdateWithWhereUniqueWithoutItemTypeInput | LootQueueUpdateWithWhereUniqueWithoutItemTypeInput[]
    updateMany?: LootQueueUpdateManyWithWhereWithoutItemTypeInput | LootQueueUpdateManyWithWhereWithoutItemTypeInput[]
    deleteMany?: LootQueueScalarWhereInput | LootQueueScalarWhereInput[]
  }

  export type LootUncheckedUpdateManyWithoutItemTypeNestedInput = {
    create?: XOR<LootCreateWithoutItemTypeInput, LootUncheckedCreateWithoutItemTypeInput> | LootCreateWithoutItemTypeInput[] | LootUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootCreateOrConnectWithoutItemTypeInput | LootCreateOrConnectWithoutItemTypeInput[]
    upsert?: LootUpsertWithWhereUniqueWithoutItemTypeInput | LootUpsertWithWhereUniqueWithoutItemTypeInput[]
    createMany?: LootCreateManyItemTypeInputEnvelope
    set?: LootWhereUniqueInput | LootWhereUniqueInput[]
    disconnect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    delete?: LootWhereUniqueInput | LootWhereUniqueInput[]
    connect?: LootWhereUniqueInput | LootWhereUniqueInput[]
    update?: LootUpdateWithWhereUniqueWithoutItemTypeInput | LootUpdateWithWhereUniqueWithoutItemTypeInput[]
    updateMany?: LootUpdateManyWithWhereWithoutItemTypeInput | LootUpdateManyWithWhereWithoutItemTypeInput[]
    deleteMany?: LootScalarWhereInput | LootScalarWhereInput[]
  }

  export type LootQueueUncheckedUpdateManyWithoutItemTypeNestedInput = {
    create?: XOR<LootQueueCreateWithoutItemTypeInput, LootQueueUncheckedCreateWithoutItemTypeInput> | LootQueueCreateWithoutItemTypeInput[] | LootQueueUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: LootQueueCreateOrConnectWithoutItemTypeInput | LootQueueCreateOrConnectWithoutItemTypeInput[]
    upsert?: LootQueueUpsertWithWhereUniqueWithoutItemTypeInput | LootQueueUpsertWithWhereUniqueWithoutItemTypeInput[]
    createMany?: LootQueueCreateManyItemTypeInputEnvelope
    set?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    disconnect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    delete?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    connect?: LootQueueWhereUniqueInput | LootQueueWhereUniqueInput[]
    update?: LootQueueUpdateWithWhereUniqueWithoutItemTypeInput | LootQueueUpdateWithWhereUniqueWithoutItemTypeInput[]
    updateMany?: LootQueueUpdateManyWithWhereWithoutItemTypeInput | LootQueueUpdateManyWithWhereWithoutItemTypeInput[]
    deleteMany?: LootQueueScalarWhereInput | LootQueueScalarWhereInput[]
  }

  export type ItemTypeCreateNestedOneWithoutLootInput = {
    create?: XOR<ItemTypeCreateWithoutLootInput, ItemTypeUncheckedCreateWithoutLootInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutLootInput
    connect?: ItemTypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSoldLootInput = {
    create?: XOR<UserCreateWithoutSoldLootInput, UserUncheckedCreateWithoutSoldLootInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoldLootInput
    connect?: UserWhereUniqueInput
  }

  export type ItemTypeUpdateOneRequiredWithoutLootNestedInput = {
    create?: XOR<ItemTypeCreateWithoutLootInput, ItemTypeUncheckedCreateWithoutLootInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutLootInput
    upsert?: ItemTypeUpsertWithoutLootInput
    connect?: ItemTypeWhereUniqueInput
    update?: XOR<XOR<ItemTypeUpdateToOneWithWhereWithoutLootInput, ItemTypeUpdateWithoutLootInput>, ItemTypeUncheckedUpdateWithoutLootInput>
  }

  export type UserUpdateOneWithoutSoldLootNestedInput = {
    create?: XOR<UserCreateWithoutSoldLootInput, UserUncheckedCreateWithoutSoldLootInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoldLootInput
    upsert?: UserUpsertWithoutSoldLootInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSoldLootInput, UserUpdateWithoutSoldLootInput>, UserUncheckedUpdateWithoutSoldLootInput>
  }

  export type TasksCreateNestedOneWithoutAssignedToInput = {
    create?: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput>
    connectOrCreate?: TasksCreateOrConnectWithoutAssignedToInput
    connect?: TasksWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksAssignedInput = {
    create?: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksAssignedInput
    connect?: UserWhereUniqueInput
  }

  export type TasksUpdateOneRequiredWithoutAssignedToNestedInput = {
    create?: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput>
    connectOrCreate?: TasksCreateOrConnectWithoutAssignedToInput
    upsert?: TasksUpsertWithoutAssignedToInput
    connect?: TasksWhereUniqueInput
    update?: XOR<XOR<TasksUpdateToOneWithWhereWithoutAssignedToInput, TasksUpdateWithoutAssignedToInput>, TasksUncheckedUpdateWithoutAssignedToInput>
  }

  export type UserUpdateOneRequiredWithoutTasksAssignedNestedInput = {
    create?: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksAssignedInput
    upsert?: UserUpsertWithoutTasksAssignedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksAssignedInput, UserUpdateWithoutTasksAssignedInput>, UserUncheckedUpdateWithoutTasksAssignedInput>
  }

  export type ItemTypeCreateNestedOneWithoutLootQueueInput = {
    create?: XOR<ItemTypeCreateWithoutLootQueueInput, ItemTypeUncheckedCreateWithoutLootQueueInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutLootQueueInput
    connect?: ItemTypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLootQueueInput = {
    create?: XOR<UserCreateWithoutLootQueueInput, UserUncheckedCreateWithoutLootQueueInput>
    connectOrCreate?: UserCreateOrConnectWithoutLootQueueInput
    connect?: UserWhereUniqueInput
  }

  export type ItemTypeUpdateOneRequiredWithoutLootQueueNestedInput = {
    create?: XOR<ItemTypeCreateWithoutLootQueueInput, ItemTypeUncheckedCreateWithoutLootQueueInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutLootQueueInput
    upsert?: ItemTypeUpsertWithoutLootQueueInput
    connect?: ItemTypeWhereUniqueInput
    update?: XOR<XOR<ItemTypeUpdateToOneWithWhereWithoutLootQueueInput, ItemTypeUpdateWithoutLootQueueInput>, ItemTypeUncheckedUpdateWithoutLootQueueInput>
  }

  export type UserUpdateOneRequiredWithoutLootQueueNestedInput = {
    create?: XOR<UserCreateWithoutLootQueueInput, UserUncheckedCreateWithoutLootQueueInput>
    connectOrCreate?: UserCreateOrConnectWithoutLootQueueInput
    upsert?: UserUpsertWithoutLootQueueInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLootQueueInput, UserUpdateWithoutLootQueueInput>, UserUncheckedUpdateWithoutLootQueueInput>
  }

  export type UserCreateNestedOneWithoutGivenAwayLootInput = {
    create?: XOR<UserCreateWithoutGivenAwayLootInput, UserUncheckedCreateWithoutGivenAwayLootInput>
    connectOrCreate?: UserCreateOrConnectWithoutGivenAwayLootInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGivenAwayLootNestedInput = {
    create?: XOR<UserCreateWithoutGivenAwayLootInput, UserUncheckedCreateWithoutGivenAwayLootInput>
    connectOrCreate?: UserCreateOrConnectWithoutGivenAwayLootInput
    upsert?: UserUpsertWithoutGivenAwayLootInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGivenAwayLootInput, UserUpdateWithoutGivenAwayLootInput>, UserUncheckedUpdateWithoutGivenAwayLootInput>
  }

  export type UserCreateNestedOneWithoutSalariesInput = {
    create?: XOR<UserCreateWithoutSalariesInput, UserUncheckedCreateWithoutSalariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalariesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSalariesNestedInput = {
    create?: XOR<UserCreateWithoutSalariesInput, UserUncheckedCreateWithoutSalariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalariesInput
    upsert?: UserUpsertWithoutSalariesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalariesInput, UserUpdateWithoutSalariesInput>, UserUncheckedUpdateWithoutSalariesInput>
  }

  export type UserCreateNestedOneWithoutSalaryBonusesInput = {
    create?: XOR<UserCreateWithoutSalaryBonusesInput, UserUncheckedCreateWithoutSalaryBonusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryBonusesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSalaryBonusesNestedInput = {
    create?: XOR<UserCreateWithoutSalaryBonusesInput, UserUncheckedCreateWithoutSalaryBonusesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryBonusesInput
    upsert?: UserUpsertWithoutSalaryBonusesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalaryBonusesInput, UserUpdateWithoutSalaryBonusesInput>, UserUncheckedUpdateWithoutSalaryBonusesInput>
  }

  export type UserCreateNestedOneWithoutLinkTokensInput = {
    create?: XOR<UserCreateWithoutLinkTokensInput, UserUncheckedCreateWithoutLinkTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinkTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLinkTokensNestedInput = {
    create?: XOR<UserCreateWithoutLinkTokensInput, UserUncheckedCreateWithoutLinkTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinkTokensInput
    upsert?: UserUpsertWithoutLinkTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLinkTokensInput, UserUpdateWithoutLinkTokensInput>, UserUncheckedUpdateWithoutLinkTokensInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SalaryCreateWithoutUserInput = {
    year: number
    month: number
    amount: number
    bonus?: number | null
    total: number
  }

  export type SalaryUncheckedCreateWithoutUserInput = {
    id?: number
    year: number
    month: number
    amount: number
    bonus?: number | null
    total: number
  }

  export type SalaryCreateOrConnectWithoutUserInput = {
    where: SalaryWhereUniqueInput
    create: XOR<SalaryCreateWithoutUserInput, SalaryUncheckedCreateWithoutUserInput>
  }

  export type SalaryCreateManyUserInputEnvelope = {
    data: SalaryCreateManyUserInput | SalaryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GivenAwayLootCreateWithoutUserInput = {
    name: string
    date: Date | string
    comment?: string | null
    created_at?: Date | string | null
    status?: string | null
  }

  export type GivenAwayLootUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    date: Date | string
    comment?: string | null
    created_at?: Date | string | null
    status?: string | null
  }

  export type GivenAwayLootCreateOrConnectWithoutUserInput = {
    where: GivenAwayLootWhereUniqueInput
    create: XOR<GivenAwayLootCreateWithoutUserInput, GivenAwayLootUncheckedCreateWithoutUserInput>
  }

  export type GivenAwayLootCreateManyUserInputEnvelope = {
    data: GivenAwayLootCreateManyUserInput | GivenAwayLootCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LootCreateWithoutSoldToUserInput = {
    status?: string | null
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    created_at?: Date | string
    source?: string | null
    acquired_at?: Date | string | null
    quantity?: number
    price?: number | null
    itemType: ItemTypeCreateNestedOneWithoutLootInput
  }

  export type LootUncheckedCreateWithoutSoldToUserInput = {
    id?: number
    status?: string | null
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    created_at?: Date | string
    source?: string | null
    acquired_at?: Date | string | null
    itemTypeId: number
    quantity?: number
    price?: number | null
  }

  export type LootCreateOrConnectWithoutSoldToUserInput = {
    where: LootWhereUniqueInput
    create: XOR<LootCreateWithoutSoldToUserInput, LootUncheckedCreateWithoutSoldToUserInput>
  }

  export type LootCreateManySoldToUserInputEnvelope = {
    data: LootCreateManySoldToUserInput | LootCreateManySoldToUserInput[]
    skipDuplicates?: boolean
  }

  export type LootQueueCreateWithoutUserInput = {
    created_at?: Date | string | null
    status?: string | null
    synth_target?: string | null
    remaining?: number | null
    required?: number
    delivered?: number
    itemType: ItemTypeCreateNestedOneWithoutLootQueueInput
  }

  export type LootQueueUncheckedCreateWithoutUserInput = {
    id?: number
    itemTypeId: number
    created_at?: Date | string | null
    status?: string | null
    synth_target?: string | null
    remaining?: number | null
    required?: number
    delivered?: number
  }

  export type LootQueueCreateOrConnectWithoutUserInput = {
    where: LootQueueWhereUniqueInput
    create: XOR<LootQueueCreateWithoutUserInput, LootQueueUncheckedCreateWithoutUserInput>
  }

  export type LootQueueCreateManyUserInputEnvelope = {
    data: LootQueueCreateManyUserInput | LootQueueCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RaidAttendanceCreateWithoutUserInput = {
    created_at: Date | string
    raid: RaidCreateNestedOneWithoutAttendanceInput
  }

  export type RaidAttendanceUncheckedCreateWithoutUserInput = {
    id?: number
    raid_id: number
    created_at: Date | string
  }

  export type RaidAttendanceCreateOrConnectWithoutUserInput = {
    where: RaidAttendanceWhereUniqueInput
    create: XOR<RaidAttendanceCreateWithoutUserInput, RaidAttendanceUncheckedCreateWithoutUserInput>
  }

  export type RaidAttendanceCreateManyUserInputEnvelope = {
    data: RaidAttendanceCreateManyUserInput | RaidAttendanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TasksCreateWithoutUserInput = {
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
    assignedTo?: TasksUserCreateNestedManyWithoutTaskInput
  }

  export type TasksUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
    assignedTo?: TasksUserUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TasksCreateOrConnectWithoutUserInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput>
  }

  export type TasksCreateManyUserInputEnvelope = {
    data: TasksCreateManyUserInput | TasksCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TasksUserCreateWithoutUserInput = {
    task: TasksCreateNestedOneWithoutAssignedToInput
  }

  export type TasksUserUncheckedCreateWithoutUserInput = {
    tasks_user_id: number
  }

  export type TasksUserCreateOrConnectWithoutUserInput = {
    where: TasksUserWhereUniqueInput
    create: XOR<TasksUserCreateWithoutUserInput, TasksUserUncheckedCreateWithoutUserInput>
  }

  export type TasksUserCreateManyUserInputEnvelope = {
    data: TasksUserCreateManyUserInput | TasksUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserInventoryCreateWithoutUserInput = {
    type?: string | null
    name?: string | null
    quality?: string | null
    created_at: Date | string
    quantity?: number | null
  }

  export type UserInventoryUncheckedCreateWithoutUserInput = {
    id?: number
    type?: string | null
    name?: string | null
    quality?: string | null
    created_at: Date | string
    quantity?: number | null
  }

  export type UserInventoryCreateOrConnectWithoutUserInput = {
    where: UserInventoryWhereUniqueInput
    create: XOR<UserInventoryCreateWithoutUserInput, UserInventoryUncheckedCreateWithoutUserInput>
  }

  export type UserInventoryCreateManyUserInputEnvelope = {
    data: UserInventoryCreateManyUserInput | UserInventoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSalaryBonusCreateWithoutUserInput = {
    amount: number
    reason: string
    created_at?: Date | string | null
  }

  export type UserSalaryBonusUncheckedCreateWithoutUserInput = {
    id?: number
    amount: number
    reason: string
    created_at?: Date | string | null
  }

  export type UserSalaryBonusCreateOrConnectWithoutUserInput = {
    where: UserSalaryBonusWhereUniqueInput
    create: XOR<UserSalaryBonusCreateWithoutUserInput, UserSalaryBonusUncheckedCreateWithoutUserInput>
  }

  export type UserSalaryBonusCreateManyUserInputEnvelope = {
    data: UserSalaryBonusCreateManyUserInput | UserSalaryBonusCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserTagsCreateWithoutUserInput = {
    tag: string
    created_at?: Date | string
  }

  export type UserTagsUncheckedCreateWithoutUserInput = {
    id?: number
    tag: string
    created_at?: Date | string
  }

  export type UserTagsCreateOrConnectWithoutUserInput = {
    where: UserTagsWhereUniqueInput
    create: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput>
  }

  export type UserTagsCreateManyUserInputEnvelope = {
    data: UserTagsCreateManyUserInput | UserTagsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LinkTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    used?: boolean
  }

  export type LinkTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    used?: boolean
  }

  export type LinkTokenCreateOrConnectWithoutUserInput = {
    where: LinkTokenWhereUniqueInput
    create: XOR<LinkTokenCreateWithoutUserInput, LinkTokenUncheckedCreateWithoutUserInput>
  }

  export type LinkTokenCreateManyUserInputEnvelope = {
    data: LinkTokenCreateManyUserInput | LinkTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SalaryUpsertWithWhereUniqueWithoutUserInput = {
    where: SalaryWhereUniqueInput
    update: XOR<SalaryUpdateWithoutUserInput, SalaryUncheckedUpdateWithoutUserInput>
    create: XOR<SalaryCreateWithoutUserInput, SalaryUncheckedCreateWithoutUserInput>
  }

  export type SalaryUpdateWithWhereUniqueWithoutUserInput = {
    where: SalaryWhereUniqueInput
    data: XOR<SalaryUpdateWithoutUserInput, SalaryUncheckedUpdateWithoutUserInput>
  }

  export type SalaryUpdateManyWithWhereWithoutUserInput = {
    where: SalaryScalarWhereInput
    data: XOR<SalaryUpdateManyMutationInput, SalaryUncheckedUpdateManyWithoutUserInput>
  }

  export type SalaryScalarWhereInput = {
    AND?: SalaryScalarWhereInput | SalaryScalarWhereInput[]
    OR?: SalaryScalarWhereInput[]
    NOT?: SalaryScalarWhereInput | SalaryScalarWhereInput[]
    id?: IntFilter<"Salary"> | number
    year?: IntFilter<"Salary"> | number
    month?: IntFilter<"Salary"> | number
    userId?: IntFilter<"Salary"> | number
    amount?: IntFilter<"Salary"> | number
    bonus?: IntNullableFilter<"Salary"> | number | null
    total?: IntFilter<"Salary"> | number
  }

  export type GivenAwayLootUpsertWithWhereUniqueWithoutUserInput = {
    where: GivenAwayLootWhereUniqueInput
    update: XOR<GivenAwayLootUpdateWithoutUserInput, GivenAwayLootUncheckedUpdateWithoutUserInput>
    create: XOR<GivenAwayLootCreateWithoutUserInput, GivenAwayLootUncheckedCreateWithoutUserInput>
  }

  export type GivenAwayLootUpdateWithWhereUniqueWithoutUserInput = {
    where: GivenAwayLootWhereUniqueInput
    data: XOR<GivenAwayLootUpdateWithoutUserInput, GivenAwayLootUncheckedUpdateWithoutUserInput>
  }

  export type GivenAwayLootUpdateManyWithWhereWithoutUserInput = {
    where: GivenAwayLootScalarWhereInput
    data: XOR<GivenAwayLootUpdateManyMutationInput, GivenAwayLootUncheckedUpdateManyWithoutUserInput>
  }

  export type GivenAwayLootScalarWhereInput = {
    AND?: GivenAwayLootScalarWhereInput | GivenAwayLootScalarWhereInput[]
    OR?: GivenAwayLootScalarWhereInput[]
    NOT?: GivenAwayLootScalarWhereInput | GivenAwayLootScalarWhereInput[]
    id?: IntFilter<"GivenAwayLoot"> | number
    user_id?: IntFilter<"GivenAwayLoot"> | number
    name?: StringFilter<"GivenAwayLoot"> | string
    date?: DateTimeFilter<"GivenAwayLoot"> | Date | string
    comment?: StringNullableFilter<"GivenAwayLoot"> | string | null
    created_at?: DateTimeNullableFilter<"GivenAwayLoot"> | Date | string | null
    status?: StringNullableFilter<"GivenAwayLoot"> | string | null
  }

  export type LootUpsertWithWhereUniqueWithoutSoldToUserInput = {
    where: LootWhereUniqueInput
    update: XOR<LootUpdateWithoutSoldToUserInput, LootUncheckedUpdateWithoutSoldToUserInput>
    create: XOR<LootCreateWithoutSoldToUserInput, LootUncheckedCreateWithoutSoldToUserInput>
  }

  export type LootUpdateWithWhereUniqueWithoutSoldToUserInput = {
    where: LootWhereUniqueInput
    data: XOR<LootUpdateWithoutSoldToUserInput, LootUncheckedUpdateWithoutSoldToUserInput>
  }

  export type LootUpdateManyWithWhereWithoutSoldToUserInput = {
    where: LootScalarWhereInput
    data: XOR<LootUpdateManyMutationInput, LootUncheckedUpdateManyWithoutSoldToUserInput>
  }

  export type LootScalarWhereInput = {
    AND?: LootScalarWhereInput | LootScalarWhereInput[]
    OR?: LootScalarWhereInput[]
    NOT?: LootScalarWhereInput | LootScalarWhereInput[]
    id?: IntFilter<"Loot"> | number
    status?: StringNullableFilter<"Loot"> | string | null
    sold_at?: DateTimeNullableFilter<"Loot"> | Date | string | null
    sold_to?: StringNullableFilter<"Loot"> | string | null
    comment?: StringNullableFilter<"Loot"> | string | null
    created_at?: DateTimeFilter<"Loot"> | Date | string
    source?: StringNullableFilter<"Loot"> | string | null
    acquired_at?: DateTimeNullableFilter<"Loot"> | Date | string | null
    itemTypeId?: IntFilter<"Loot"> | number
    sold_to_user_id?: IntNullableFilter<"Loot"> | number | null
    quantity?: IntFilter<"Loot"> | number
    price?: IntNullableFilter<"Loot"> | number | null
  }

  export type LootQueueUpsertWithWhereUniqueWithoutUserInput = {
    where: LootQueueWhereUniqueInput
    update: XOR<LootQueueUpdateWithoutUserInput, LootQueueUncheckedUpdateWithoutUserInput>
    create: XOR<LootQueueCreateWithoutUserInput, LootQueueUncheckedCreateWithoutUserInput>
  }

  export type LootQueueUpdateWithWhereUniqueWithoutUserInput = {
    where: LootQueueWhereUniqueInput
    data: XOR<LootQueueUpdateWithoutUserInput, LootQueueUncheckedUpdateWithoutUserInput>
  }

  export type LootQueueUpdateManyWithWhereWithoutUserInput = {
    where: LootQueueScalarWhereInput
    data: XOR<LootQueueUpdateManyMutationInput, LootQueueUncheckedUpdateManyWithoutUserInput>
  }

  export type LootQueueScalarWhereInput = {
    AND?: LootQueueScalarWhereInput | LootQueueScalarWhereInput[]
    OR?: LootQueueScalarWhereInput[]
    NOT?: LootQueueScalarWhereInput | LootQueueScalarWhereInput[]
    id?: IntFilter<"LootQueue"> | number
    itemTypeId?: IntFilter<"LootQueue"> | number
    userId?: IntFilter<"LootQueue"> | number
    created_at?: DateTimeNullableFilter<"LootQueue"> | Date | string | null
    status?: StringNullableFilter<"LootQueue"> | string | null
    synth_target?: StringNullableFilter<"LootQueue"> | string | null
    remaining?: IntNullableFilter<"LootQueue"> | number | null
    required?: IntFilter<"LootQueue"> | number
    delivered?: IntFilter<"LootQueue"> | number
  }

  export type RaidAttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: RaidAttendanceWhereUniqueInput
    update: XOR<RaidAttendanceUpdateWithoutUserInput, RaidAttendanceUncheckedUpdateWithoutUserInput>
    create: XOR<RaidAttendanceCreateWithoutUserInput, RaidAttendanceUncheckedCreateWithoutUserInput>
  }

  export type RaidAttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: RaidAttendanceWhereUniqueInput
    data: XOR<RaidAttendanceUpdateWithoutUserInput, RaidAttendanceUncheckedUpdateWithoutUserInput>
  }

  export type RaidAttendanceUpdateManyWithWhereWithoutUserInput = {
    where: RaidAttendanceScalarWhereInput
    data: XOR<RaidAttendanceUpdateManyMutationInput, RaidAttendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type RaidAttendanceScalarWhereInput = {
    AND?: RaidAttendanceScalarWhereInput | RaidAttendanceScalarWhereInput[]
    OR?: RaidAttendanceScalarWhereInput[]
    NOT?: RaidAttendanceScalarWhereInput | RaidAttendanceScalarWhereInput[]
    id?: IntFilter<"RaidAttendance"> | number
    user_id?: IntFilter<"RaidAttendance"> | number
    raid_id?: IntFilter<"RaidAttendance"> | number
    created_at?: DateTimeFilter<"RaidAttendance"> | Date | string
  }

  export type TasksUpsertWithWhereUniqueWithoutUserInput = {
    where: TasksWhereUniqueInput
    update: XOR<TasksUpdateWithoutUserInput, TasksUncheckedUpdateWithoutUserInput>
    create: XOR<TasksCreateWithoutUserInput, TasksUncheckedCreateWithoutUserInput>
  }

  export type TasksUpdateWithWhereUniqueWithoutUserInput = {
    where: TasksWhereUniqueInput
    data: XOR<TasksUpdateWithoutUserInput, TasksUncheckedUpdateWithoutUserInput>
  }

  export type TasksUpdateManyWithWhereWithoutUserInput = {
    where: TasksScalarWhereInput
    data: XOR<TasksUpdateManyMutationInput, TasksUncheckedUpdateManyWithoutUserInput>
  }

  export type TasksScalarWhereInput = {
    AND?: TasksScalarWhereInput | TasksScalarWhereInput[]
    OR?: TasksScalarWhereInput[]
    NOT?: TasksScalarWhereInput | TasksScalarWhereInput[]
    id?: IntFilter<"Tasks"> | number
    user_id?: IntFilter<"Tasks"> | number
    name?: StringNullableFilter<"Tasks"> | string | null
    completed_at?: DateTimeNullableFilter<"Tasks"> | Date | string | null
    created_at?: DateTimeFilter<"Tasks"> | Date | string
  }

  export type TasksUserUpsertWithWhereUniqueWithoutUserInput = {
    where: TasksUserWhereUniqueInput
    update: XOR<TasksUserUpdateWithoutUserInput, TasksUserUncheckedUpdateWithoutUserInput>
    create: XOR<TasksUserCreateWithoutUserInput, TasksUserUncheckedCreateWithoutUserInput>
  }

  export type TasksUserUpdateWithWhereUniqueWithoutUserInput = {
    where: TasksUserWhereUniqueInput
    data: XOR<TasksUserUpdateWithoutUserInput, TasksUserUncheckedUpdateWithoutUserInput>
  }

  export type TasksUserUpdateManyWithWhereWithoutUserInput = {
    where: TasksUserScalarWhereInput
    data: XOR<TasksUserUpdateManyMutationInput, TasksUserUncheckedUpdateManyWithoutUserInput>
  }

  export type TasksUserScalarWhereInput = {
    AND?: TasksUserScalarWhereInput | TasksUserScalarWhereInput[]
    OR?: TasksUserScalarWhereInput[]
    NOT?: TasksUserScalarWhereInput | TasksUserScalarWhereInput[]
    tasks_user_id?: IntFilter<"TasksUser"> | number
    user_id?: IntFilter<"TasksUser"> | number
  }

  export type UserInventoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserInventoryWhereUniqueInput
    update: XOR<UserInventoryUpdateWithoutUserInput, UserInventoryUncheckedUpdateWithoutUserInput>
    create: XOR<UserInventoryCreateWithoutUserInput, UserInventoryUncheckedCreateWithoutUserInput>
  }

  export type UserInventoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserInventoryWhereUniqueInput
    data: XOR<UserInventoryUpdateWithoutUserInput, UserInventoryUncheckedUpdateWithoutUserInput>
  }

  export type UserInventoryUpdateManyWithWhereWithoutUserInput = {
    where: UserInventoryScalarWhereInput
    data: XOR<UserInventoryUpdateManyMutationInput, UserInventoryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserInventoryScalarWhereInput = {
    AND?: UserInventoryScalarWhereInput | UserInventoryScalarWhereInput[]
    OR?: UserInventoryScalarWhereInput[]
    NOT?: UserInventoryScalarWhereInput | UserInventoryScalarWhereInput[]
    id?: IntFilter<"UserInventory"> | number
    user_id?: IntFilter<"UserInventory"> | number
    type?: StringNullableFilter<"UserInventory"> | string | null
    name?: StringNullableFilter<"UserInventory"> | string | null
    quality?: StringNullableFilter<"UserInventory"> | string | null
    created_at?: DateTimeFilter<"UserInventory"> | Date | string
    quantity?: IntNullableFilter<"UserInventory"> | number | null
  }

  export type UserSalaryBonusUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSalaryBonusWhereUniqueInput
    update: XOR<UserSalaryBonusUpdateWithoutUserInput, UserSalaryBonusUncheckedUpdateWithoutUserInput>
    create: XOR<UserSalaryBonusCreateWithoutUserInput, UserSalaryBonusUncheckedCreateWithoutUserInput>
  }

  export type UserSalaryBonusUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSalaryBonusWhereUniqueInput
    data: XOR<UserSalaryBonusUpdateWithoutUserInput, UserSalaryBonusUncheckedUpdateWithoutUserInput>
  }

  export type UserSalaryBonusUpdateManyWithWhereWithoutUserInput = {
    where: UserSalaryBonusScalarWhereInput
    data: XOR<UserSalaryBonusUpdateManyMutationInput, UserSalaryBonusUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSalaryBonusScalarWhereInput = {
    AND?: UserSalaryBonusScalarWhereInput | UserSalaryBonusScalarWhereInput[]
    OR?: UserSalaryBonusScalarWhereInput[]
    NOT?: UserSalaryBonusScalarWhereInput | UserSalaryBonusScalarWhereInput[]
    id?: IntFilter<"UserSalaryBonus"> | number
    user_id?: IntFilter<"UserSalaryBonus"> | number
    amount?: IntFilter<"UserSalaryBonus"> | number
    reason?: StringFilter<"UserSalaryBonus"> | string
    created_at?: DateTimeNullableFilter<"UserSalaryBonus"> | Date | string | null
  }

  export type UserTagsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTagsWhereUniqueInput
    update: XOR<UserTagsUpdateWithoutUserInput, UserTagsUncheckedUpdateWithoutUserInput>
    create: XOR<UserTagsCreateWithoutUserInput, UserTagsUncheckedCreateWithoutUserInput>
  }

  export type UserTagsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTagsWhereUniqueInput
    data: XOR<UserTagsUpdateWithoutUserInput, UserTagsUncheckedUpdateWithoutUserInput>
  }

  export type UserTagsUpdateManyWithWhereWithoutUserInput = {
    where: UserTagsScalarWhereInput
    data: XOR<UserTagsUpdateManyMutationInput, UserTagsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserTagsScalarWhereInput = {
    AND?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
    OR?: UserTagsScalarWhereInput[]
    NOT?: UserTagsScalarWhereInput | UserTagsScalarWhereInput[]
    id?: IntFilter<"UserTags"> | number
    user_id?: IntFilter<"UserTags"> | number
    tag?: StringFilter<"UserTags"> | string
    created_at?: DateTimeFilter<"UserTags"> | Date | string
  }

  export type LinkTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: LinkTokenWhereUniqueInput
    update: XOR<LinkTokenUpdateWithoutUserInput, LinkTokenUncheckedUpdateWithoutUserInput>
    create: XOR<LinkTokenCreateWithoutUserInput, LinkTokenUncheckedCreateWithoutUserInput>
  }

  export type LinkTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: LinkTokenWhereUniqueInput
    data: XOR<LinkTokenUpdateWithoutUserInput, LinkTokenUncheckedUpdateWithoutUserInput>
  }

  export type LinkTokenUpdateManyWithWhereWithoutUserInput = {
    where: LinkTokenScalarWhereInput
    data: XOR<LinkTokenUpdateManyMutationInput, LinkTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type LinkTokenScalarWhereInput = {
    AND?: LinkTokenScalarWhereInput | LinkTokenScalarWhereInput[]
    OR?: LinkTokenScalarWhereInput[]
    NOT?: LinkTokenScalarWhereInput | LinkTokenScalarWhereInput[]
    id?: IntFilter<"LinkToken"> | number
    token?: StringFilter<"LinkToken"> | string
    userId?: IntFilter<"LinkToken"> | number
    expiresAt?: DateTimeFilter<"LinkToken"> | Date | string
    used?: BoolFilter<"LinkToken"> | boolean
  }

  export type UserCreateWithoutTagsInput = {
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTagsInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryUncheckedCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusUncheckedCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTagsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
  }

  export type UserUpsertWithoutTagsInput = {
    update: XOR<UserUpdateWithoutTagsInput, UserUncheckedUpdateWithoutTagsInput>
    create: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTagsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTagsInput, UserUncheckedUpdateWithoutTagsInput>
  }

  export type UserUpdateWithoutTagsInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUncheckedUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUncheckedUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInventoryInput = {
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoryInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryUncheckedCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
  }

  export type UserUpsertWithoutInventoryInput = {
    update: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
    create: XOR<UserCreateWithoutInventoryInput, UserUncheckedCreateWithoutInventoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryInput, UserUncheckedUpdateWithoutInventoryInput>
  }

  export type UserUpdateWithoutInventoryInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUncheckedUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTasksInput = {
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryUncheckedCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type TasksUserCreateWithoutTaskInput = {
    user: UserCreateNestedOneWithoutTasksAssignedInput
  }

  export type TasksUserUncheckedCreateWithoutTaskInput = {
    user_id: number
  }

  export type TasksUserCreateOrConnectWithoutTaskInput = {
    where: TasksUserWhereUniqueInput
    create: XOR<TasksUserCreateWithoutTaskInput, TasksUserUncheckedCreateWithoutTaskInput>
  }

  export type TasksUserCreateManyTaskInputEnvelope = {
    data: TasksUserCreateManyTaskInput | TasksUserCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTasksInput = {
    update: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateWithoutTasksInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUncheckedUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TasksUserUpsertWithWhereUniqueWithoutTaskInput = {
    where: TasksUserWhereUniqueInput
    update: XOR<TasksUserUpdateWithoutTaskInput, TasksUserUncheckedUpdateWithoutTaskInput>
    create: XOR<TasksUserCreateWithoutTaskInput, TasksUserUncheckedCreateWithoutTaskInput>
  }

  export type TasksUserUpdateWithWhereUniqueWithoutTaskInput = {
    where: TasksUserWhereUniqueInput
    data: XOR<TasksUserUpdateWithoutTaskInput, TasksUserUncheckedUpdateWithoutTaskInput>
  }

  export type TasksUserUpdateManyWithWhereWithoutTaskInput = {
    where: TasksUserScalarWhereInput
    data: XOR<TasksUserUpdateManyMutationInput, TasksUserUncheckedUpdateManyWithoutTaskInput>
  }

  export type RaidAttendanceCreateWithoutRaidInput = {
    created_at: Date | string
    user: UserCreateNestedOneWithoutRaidAttendanceInput
  }

  export type RaidAttendanceUncheckedCreateWithoutRaidInput = {
    id?: number
    user_id: number
    created_at: Date | string
  }

  export type RaidAttendanceCreateOrConnectWithoutRaidInput = {
    where: RaidAttendanceWhereUniqueInput
    create: XOR<RaidAttendanceCreateWithoutRaidInput, RaidAttendanceUncheckedCreateWithoutRaidInput>
  }

  export type RaidAttendanceCreateManyRaidInputEnvelope = {
    data: RaidAttendanceCreateManyRaidInput | RaidAttendanceCreateManyRaidInput[]
    skipDuplicates?: boolean
  }

  export type RaidBossCreateWithoutRaidInput = {
    boss: BossCreateNestedOneWithoutRaidBossesInput
  }

  export type RaidBossUncheckedCreateWithoutRaidInput = {
    boss_id: number
  }

  export type RaidBossCreateOrConnectWithoutRaidInput = {
    where: RaidBossWhereUniqueInput
    create: XOR<RaidBossCreateWithoutRaidInput, RaidBossUncheckedCreateWithoutRaidInput>
  }

  export type RaidBossCreateManyRaidInputEnvelope = {
    data: RaidBossCreateManyRaidInput | RaidBossCreateManyRaidInput[]
    skipDuplicates?: boolean
  }

  export type RaidAttendanceUpsertWithWhereUniqueWithoutRaidInput = {
    where: RaidAttendanceWhereUniqueInput
    update: XOR<RaidAttendanceUpdateWithoutRaidInput, RaidAttendanceUncheckedUpdateWithoutRaidInput>
    create: XOR<RaidAttendanceCreateWithoutRaidInput, RaidAttendanceUncheckedCreateWithoutRaidInput>
  }

  export type RaidAttendanceUpdateWithWhereUniqueWithoutRaidInput = {
    where: RaidAttendanceWhereUniqueInput
    data: XOR<RaidAttendanceUpdateWithoutRaidInput, RaidAttendanceUncheckedUpdateWithoutRaidInput>
  }

  export type RaidAttendanceUpdateManyWithWhereWithoutRaidInput = {
    where: RaidAttendanceScalarWhereInput
    data: XOR<RaidAttendanceUpdateManyMutationInput, RaidAttendanceUncheckedUpdateManyWithoutRaidInput>
  }

  export type RaidBossUpsertWithWhereUniqueWithoutRaidInput = {
    where: RaidBossWhereUniqueInput
    update: XOR<RaidBossUpdateWithoutRaidInput, RaidBossUncheckedUpdateWithoutRaidInput>
    create: XOR<RaidBossCreateWithoutRaidInput, RaidBossUncheckedCreateWithoutRaidInput>
  }

  export type RaidBossUpdateWithWhereUniqueWithoutRaidInput = {
    where: RaidBossWhereUniqueInput
    data: XOR<RaidBossUpdateWithoutRaidInput, RaidBossUncheckedUpdateWithoutRaidInput>
  }

  export type RaidBossUpdateManyWithWhereWithoutRaidInput = {
    where: RaidBossScalarWhereInput
    data: XOR<RaidBossUpdateManyMutationInput, RaidBossUncheckedUpdateManyWithoutRaidInput>
  }

  export type RaidBossScalarWhereInput = {
    AND?: RaidBossScalarWhereInput | RaidBossScalarWhereInput[]
    OR?: RaidBossScalarWhereInput[]
    NOT?: RaidBossScalarWhereInput | RaidBossScalarWhereInput[]
    raid_id?: IntFilter<"RaidBoss"> | number
    boss_id?: IntFilter<"RaidBoss"> | number
  }

  export type RaidBossCreateWithoutBossInput = {
    raid: RaidCreateNestedOneWithoutRaidBossesInput
  }

  export type RaidBossUncheckedCreateWithoutBossInput = {
    raid_id: number
  }

  export type RaidBossCreateOrConnectWithoutBossInput = {
    where: RaidBossWhereUniqueInput
    create: XOR<RaidBossCreateWithoutBossInput, RaidBossUncheckedCreateWithoutBossInput>
  }

  export type RaidBossCreateManyBossInputEnvelope = {
    data: RaidBossCreateManyBossInput | RaidBossCreateManyBossInput[]
    skipDuplicates?: boolean
  }

  export type RaidBossUpsertWithWhereUniqueWithoutBossInput = {
    where: RaidBossWhereUniqueInput
    update: XOR<RaidBossUpdateWithoutBossInput, RaidBossUncheckedUpdateWithoutBossInput>
    create: XOR<RaidBossCreateWithoutBossInput, RaidBossUncheckedCreateWithoutBossInput>
  }

  export type RaidBossUpdateWithWhereUniqueWithoutBossInput = {
    where: RaidBossWhereUniqueInput
    data: XOR<RaidBossUpdateWithoutBossInput, RaidBossUncheckedUpdateWithoutBossInput>
  }

  export type RaidBossUpdateManyWithWhereWithoutBossInput = {
    where: RaidBossScalarWhereInput
    data: XOR<RaidBossUpdateManyMutationInput, RaidBossUncheckedUpdateManyWithoutBossInput>
  }

  export type BossCreateWithoutRaidBossesInput = {
    boss_name: string
    dkp_points: number
    category?: string | null
  }

  export type BossUncheckedCreateWithoutRaidBossesInput = {
    id?: number
    boss_name: string
    dkp_points: number
    category?: string | null
  }

  export type BossCreateOrConnectWithoutRaidBossesInput = {
    where: BossWhereUniqueInput
    create: XOR<BossCreateWithoutRaidBossesInput, BossUncheckedCreateWithoutRaidBossesInput>
  }

  export type RaidCreateWithoutRaidBossesInput = {
    type?: string | null
    start_date?: Date | string | null
    created_at: Date | string
    is_pvp?: boolean | null
    is_pvp_long?: boolean | null
    dkp_summary?: number | null
    attendance?: RaidAttendanceCreateNestedManyWithoutRaidInput
  }

  export type RaidUncheckedCreateWithoutRaidBossesInput = {
    id?: number
    type?: string | null
    start_date?: Date | string | null
    created_at: Date | string
    is_pvp?: boolean | null
    is_pvp_long?: boolean | null
    dkp_summary?: number | null
    attendance?: RaidAttendanceUncheckedCreateNestedManyWithoutRaidInput
  }

  export type RaidCreateOrConnectWithoutRaidBossesInput = {
    where: RaidWhereUniqueInput
    create: XOR<RaidCreateWithoutRaidBossesInput, RaidUncheckedCreateWithoutRaidBossesInput>
  }

  export type BossUpsertWithoutRaidBossesInput = {
    update: XOR<BossUpdateWithoutRaidBossesInput, BossUncheckedUpdateWithoutRaidBossesInput>
    create: XOR<BossCreateWithoutRaidBossesInput, BossUncheckedCreateWithoutRaidBossesInput>
    where?: BossWhereInput
  }

  export type BossUpdateToOneWithWhereWithoutRaidBossesInput = {
    where?: BossWhereInput
    data: XOR<BossUpdateWithoutRaidBossesInput, BossUncheckedUpdateWithoutRaidBossesInput>
  }

  export type BossUpdateWithoutRaidBossesInput = {
    boss_name?: StringFieldUpdateOperationsInput | string
    dkp_points?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BossUncheckedUpdateWithoutRaidBossesInput = {
    id?: IntFieldUpdateOperationsInput | number
    boss_name?: StringFieldUpdateOperationsInput | string
    dkp_points?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RaidUpsertWithoutRaidBossesInput = {
    update: XOR<RaidUpdateWithoutRaidBossesInput, RaidUncheckedUpdateWithoutRaidBossesInput>
    create: XOR<RaidCreateWithoutRaidBossesInput, RaidUncheckedCreateWithoutRaidBossesInput>
    where?: RaidWhereInput
  }

  export type RaidUpdateToOneWithWhereWithoutRaidBossesInput = {
    where?: RaidWhereInput
    data: XOR<RaidUpdateWithoutRaidBossesInput, RaidUncheckedUpdateWithoutRaidBossesInput>
  }

  export type RaidUpdateWithoutRaidBossesInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_pvp?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_pvp_long?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dkp_summary?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: RaidAttendanceUpdateManyWithoutRaidNestedInput
  }

  export type RaidUncheckedUpdateWithoutRaidBossesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_pvp?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_pvp_long?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dkp_summary?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: RaidAttendanceUncheckedUpdateManyWithoutRaidNestedInput
  }

  export type RaidCreateWithoutAttendanceInput = {
    type?: string | null
    start_date?: Date | string | null
    created_at: Date | string
    is_pvp?: boolean | null
    is_pvp_long?: boolean | null
    dkp_summary?: number | null
    raidBosses?: RaidBossCreateNestedManyWithoutRaidInput
  }

  export type RaidUncheckedCreateWithoutAttendanceInput = {
    id?: number
    type?: string | null
    start_date?: Date | string | null
    created_at: Date | string
    is_pvp?: boolean | null
    is_pvp_long?: boolean | null
    dkp_summary?: number | null
    raidBosses?: RaidBossUncheckedCreateNestedManyWithoutRaidInput
  }

  export type RaidCreateOrConnectWithoutAttendanceInput = {
    where: RaidWhereUniqueInput
    create: XOR<RaidCreateWithoutAttendanceInput, RaidUncheckedCreateWithoutAttendanceInput>
  }

  export type UserCreateWithoutRaidAttendanceInput = {
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRaidAttendanceInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryUncheckedCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRaidAttendanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRaidAttendanceInput, UserUncheckedCreateWithoutRaidAttendanceInput>
  }

  export type RaidUpsertWithoutAttendanceInput = {
    update: XOR<RaidUpdateWithoutAttendanceInput, RaidUncheckedUpdateWithoutAttendanceInput>
    create: XOR<RaidCreateWithoutAttendanceInput, RaidUncheckedCreateWithoutAttendanceInput>
    where?: RaidWhereInput
  }

  export type RaidUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: RaidWhereInput
    data: XOR<RaidUpdateWithoutAttendanceInput, RaidUncheckedUpdateWithoutAttendanceInput>
  }

  export type RaidUpdateWithoutAttendanceInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_pvp?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_pvp_long?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dkp_summary?: NullableIntFieldUpdateOperationsInput | number | null
    raidBosses?: RaidBossUpdateManyWithoutRaidNestedInput
  }

  export type RaidUncheckedUpdateWithoutAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_pvp?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_pvp_long?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dkp_summary?: NullableIntFieldUpdateOperationsInput | number | null
    raidBosses?: RaidBossUncheckedUpdateManyWithoutRaidNestedInput
  }

  export type UserUpsertWithoutRaidAttendanceInput = {
    update: XOR<UserUpdateWithoutRaidAttendanceInput, UserUncheckedUpdateWithoutRaidAttendanceInput>
    create: XOR<UserCreateWithoutRaidAttendanceInput, UserUncheckedCreateWithoutRaidAttendanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRaidAttendanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRaidAttendanceInput, UserUncheckedUpdateWithoutRaidAttendanceInput>
  }

  export type UserUpdateWithoutRaidAttendanceInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRaidAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUncheckedUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LootCreateWithoutItemTypeInput = {
    status?: string | null
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    created_at?: Date | string
    source?: string | null
    acquired_at?: Date | string | null
    quantity?: number
    price?: number | null
    soldToUser?: UserCreateNestedOneWithoutSoldLootInput
  }

  export type LootUncheckedCreateWithoutItemTypeInput = {
    id?: number
    status?: string | null
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    created_at?: Date | string
    source?: string | null
    acquired_at?: Date | string | null
    sold_to_user_id?: number | null
    quantity?: number
    price?: number | null
  }

  export type LootCreateOrConnectWithoutItemTypeInput = {
    where: LootWhereUniqueInput
    create: XOR<LootCreateWithoutItemTypeInput, LootUncheckedCreateWithoutItemTypeInput>
  }

  export type LootCreateManyItemTypeInputEnvelope = {
    data: LootCreateManyItemTypeInput | LootCreateManyItemTypeInput[]
    skipDuplicates?: boolean
  }

  export type LootQueueCreateWithoutItemTypeInput = {
    created_at?: Date | string | null
    status?: string | null
    synth_target?: string | null
    remaining?: number | null
    required?: number
    delivered?: number
    user: UserCreateNestedOneWithoutLootQueueInput
  }

  export type LootQueueUncheckedCreateWithoutItemTypeInput = {
    id?: number
    userId: number
    created_at?: Date | string | null
    status?: string | null
    synth_target?: string | null
    remaining?: number | null
    required?: number
    delivered?: number
  }

  export type LootQueueCreateOrConnectWithoutItemTypeInput = {
    where: LootQueueWhereUniqueInput
    create: XOR<LootQueueCreateWithoutItemTypeInput, LootQueueUncheckedCreateWithoutItemTypeInput>
  }

  export type LootQueueCreateManyItemTypeInputEnvelope = {
    data: LootQueueCreateManyItemTypeInput | LootQueueCreateManyItemTypeInput[]
    skipDuplicates?: boolean
  }

  export type LootUpsertWithWhereUniqueWithoutItemTypeInput = {
    where: LootWhereUniqueInput
    update: XOR<LootUpdateWithoutItemTypeInput, LootUncheckedUpdateWithoutItemTypeInput>
    create: XOR<LootCreateWithoutItemTypeInput, LootUncheckedCreateWithoutItemTypeInput>
  }

  export type LootUpdateWithWhereUniqueWithoutItemTypeInput = {
    where: LootWhereUniqueInput
    data: XOR<LootUpdateWithoutItemTypeInput, LootUncheckedUpdateWithoutItemTypeInput>
  }

  export type LootUpdateManyWithWhereWithoutItemTypeInput = {
    where: LootScalarWhereInput
    data: XOR<LootUpdateManyMutationInput, LootUncheckedUpdateManyWithoutItemTypeInput>
  }

  export type LootQueueUpsertWithWhereUniqueWithoutItemTypeInput = {
    where: LootQueueWhereUniqueInput
    update: XOR<LootQueueUpdateWithoutItemTypeInput, LootQueueUncheckedUpdateWithoutItemTypeInput>
    create: XOR<LootQueueCreateWithoutItemTypeInput, LootQueueUncheckedCreateWithoutItemTypeInput>
  }

  export type LootQueueUpdateWithWhereUniqueWithoutItemTypeInput = {
    where: LootQueueWhereUniqueInput
    data: XOR<LootQueueUpdateWithoutItemTypeInput, LootQueueUncheckedUpdateWithoutItemTypeInput>
  }

  export type LootQueueUpdateManyWithWhereWithoutItemTypeInput = {
    where: LootQueueScalarWhereInput
    data: XOR<LootQueueUpdateManyMutationInput, LootQueueUncheckedUpdateManyWithoutItemTypeInput>
  }

  export type ItemTypeCreateWithoutLootInput = {
    name: string
    price?: number | null
    lootQueue?: LootQueueCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeUncheckedCreateWithoutLootInput = {
    id?: number
    name: string
    price?: number | null
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeCreateOrConnectWithoutLootInput = {
    where: ItemTypeWhereUniqueInput
    create: XOR<ItemTypeCreateWithoutLootInput, ItemTypeUncheckedCreateWithoutLootInput>
  }

  export type UserCreateWithoutSoldLootInput = {
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootCreateNestedManyWithoutUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSoldLootInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryUncheckedCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootUncheckedCreateNestedManyWithoutUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSoldLootInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSoldLootInput, UserUncheckedCreateWithoutSoldLootInput>
  }

  export type ItemTypeUpsertWithoutLootInput = {
    update: XOR<ItemTypeUpdateWithoutLootInput, ItemTypeUncheckedUpdateWithoutLootInput>
    create: XOR<ItemTypeCreateWithoutLootInput, ItemTypeUncheckedCreateWithoutLootInput>
    where?: ItemTypeWhereInput
  }

  export type ItemTypeUpdateToOneWithWhereWithoutLootInput = {
    where?: ItemTypeWhereInput
    data: XOR<ItemTypeUpdateWithoutLootInput, ItemTypeUncheckedUpdateWithoutLootInput>
  }

  export type ItemTypeUpdateWithoutLootInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    lootQueue?: LootQueueUpdateManyWithoutItemTypeNestedInput
  }

  export type ItemTypeUncheckedUpdateWithoutLootInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    lootQueue?: LootQueueUncheckedUpdateManyWithoutItemTypeNestedInput
  }

  export type UserUpsertWithoutSoldLootInput = {
    update: XOR<UserUpdateWithoutSoldLootInput, UserUncheckedUpdateWithoutSoldLootInput>
    create: XOR<UserCreateWithoutSoldLootInput, UserUncheckedCreateWithoutSoldLootInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSoldLootInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSoldLootInput, UserUncheckedUpdateWithoutSoldLootInput>
  }

  export type UserUpdateWithoutSoldLootInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUpdateManyWithoutUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSoldLootInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUncheckedUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUncheckedUpdateManyWithoutUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TasksCreateWithoutAssignedToInput = {
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
    user: UserCreateNestedOneWithoutTasksInput
  }

  export type TasksUncheckedCreateWithoutAssignedToInput = {
    id?: number
    user_id: number
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
  }

  export type TasksCreateOrConnectWithoutAssignedToInput = {
    where: TasksWhereUniqueInput
    create: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput>
  }

  export type UserCreateWithoutTasksAssignedInput = {
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksAssignedInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryUncheckedCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksAssignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
  }

  export type TasksUpsertWithoutAssignedToInput = {
    update: XOR<TasksUpdateWithoutAssignedToInput, TasksUncheckedUpdateWithoutAssignedToInput>
    create: XOR<TasksCreateWithoutAssignedToInput, TasksUncheckedCreateWithoutAssignedToInput>
    where?: TasksWhereInput
  }

  export type TasksUpdateToOneWithWhereWithoutAssignedToInput = {
    where?: TasksWhereInput
    data: XOR<TasksUpdateWithoutAssignedToInput, TasksUncheckedUpdateWithoutAssignedToInput>
  }

  export type TasksUpdateWithoutAssignedToInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TasksUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTasksAssignedInput = {
    update: XOR<UserUpdateWithoutTasksAssignedInput, UserUncheckedUpdateWithoutTasksAssignedInput>
    create: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksAssignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksAssignedInput, UserUncheckedUpdateWithoutTasksAssignedInput>
  }

  export type UserUpdateWithoutTasksAssignedInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksAssignedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUncheckedUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ItemTypeCreateWithoutLootQueueInput = {
    name: string
    price?: number | null
    loot?: LootCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeUncheckedCreateWithoutLootQueueInput = {
    id?: number
    name: string
    price?: number | null
    loot?: LootUncheckedCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeCreateOrConnectWithoutLootQueueInput = {
    where: ItemTypeWhereUniqueInput
    create: XOR<ItemTypeCreateWithoutLootQueueInput, ItemTypeUncheckedCreateWithoutLootQueueInput>
  }

  export type UserCreateWithoutLootQueueInput = {
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLootQueueInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryUncheckedCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLootQueueInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLootQueueInput, UserUncheckedCreateWithoutLootQueueInput>
  }

  export type ItemTypeUpsertWithoutLootQueueInput = {
    update: XOR<ItemTypeUpdateWithoutLootQueueInput, ItemTypeUncheckedUpdateWithoutLootQueueInput>
    create: XOR<ItemTypeCreateWithoutLootQueueInput, ItemTypeUncheckedCreateWithoutLootQueueInput>
    where?: ItemTypeWhereInput
  }

  export type ItemTypeUpdateToOneWithWhereWithoutLootQueueInput = {
    where?: ItemTypeWhereInput
    data: XOR<ItemTypeUpdateWithoutLootQueueInput, ItemTypeUncheckedUpdateWithoutLootQueueInput>
  }

  export type ItemTypeUpdateWithoutLootQueueInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    loot?: LootUpdateManyWithoutItemTypeNestedInput
  }

  export type ItemTypeUncheckedUpdateWithoutLootQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    loot?: LootUncheckedUpdateManyWithoutItemTypeNestedInput
  }

  export type UserUpsertWithoutLootQueueInput = {
    update: XOR<UserUpdateWithoutLootQueueInput, UserUncheckedUpdateWithoutLootQueueInput>
    create: XOR<UserCreateWithoutLootQueueInput, UserUncheckedCreateWithoutLootQueueInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLootQueueInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLootQueueInput, UserUncheckedUpdateWithoutLootQueueInput>
  }

  export type UserUpdateWithoutLootQueueInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLootQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUncheckedUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGivenAwayLootInput = {
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGivenAwayLootInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGivenAwayLootInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGivenAwayLootInput, UserUncheckedCreateWithoutGivenAwayLootInput>
  }

  export type UserUpsertWithoutGivenAwayLootInput = {
    update: XOR<UserUpdateWithoutGivenAwayLootInput, UserUncheckedUpdateWithoutGivenAwayLootInput>
    create: XOR<UserCreateWithoutGivenAwayLootInput, UserUncheckedCreateWithoutGivenAwayLootInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGivenAwayLootInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGivenAwayLootInput, UserUncheckedUpdateWithoutGivenAwayLootInput>
  }

  export type UserUpdateWithoutGivenAwayLootInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGivenAwayLootInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSalariesInput = {
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    givenAwayLoot?: GivenAwayLootCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalariesInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    givenAwayLoot?: GivenAwayLootUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalariesInput, UserUncheckedCreateWithoutSalariesInput>
  }

  export type UserUpsertWithoutSalariesInput = {
    update: XOR<UserUpdateWithoutSalariesInput, UserUncheckedUpdateWithoutSalariesInput>
    create: XOR<UserCreateWithoutSalariesInput, UserUncheckedCreateWithoutSalariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalariesInput, UserUncheckedUpdateWithoutSalariesInput>
  }

  export type UserUpdateWithoutSalariesInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    givenAwayLoot?: GivenAwayLootUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    givenAwayLoot?: GivenAwayLootUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSalaryBonusesInput = {
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalaryBonusesInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryUncheckedCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
    linkTokens?: LinkTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalaryBonusesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalaryBonusesInput, UserUncheckedCreateWithoutSalaryBonusesInput>
  }

  export type UserUpsertWithoutSalaryBonusesInput = {
    update: XOR<UserUpdateWithoutSalaryBonusesInput, UserUncheckedUpdateWithoutSalaryBonusesInput>
    create: XOR<UserCreateWithoutSalaryBonusesInput, UserUncheckedCreateWithoutSalaryBonusesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalaryBonusesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalaryBonusesInput, UserUncheckedUpdateWithoutSalaryBonusesInput>
  }

  export type UserUpdateWithoutSalaryBonusesInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalaryBonusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUncheckedUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
    linkTokens?: LinkTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLinkTokensInput = {
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootCreateNestedManyWithoutUserInput
    soldLoot?: LootCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceCreateNestedManyWithoutUserInput
    tasks?: TasksCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserCreateNestedManyWithoutUserInput
    inventory?: UserInventoryCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusCreateNestedManyWithoutUserInput
    tags?: UserTagsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLinkTokensInput = {
    id?: number
    username: string
    class?: string | null
    secondary_class?: string | null
    class_gear_score?: number | null
    secondary_class_gear_score?: number | null
    vk_name?: string | null
    active: boolean
    is_eligible_for_salary: boolean
    joined_at?: Date | string | null
    created_at: Date | string
    salaryBonus?: number | null
    googleId?: string | null
    vkId?: string | null
    salaries?: SalaryUncheckedCreateNestedManyWithoutUserInput
    givenAwayLoot?: GivenAwayLootUncheckedCreateNestedManyWithoutUserInput
    soldLoot?: LootUncheckedCreateNestedManyWithoutSoldToUserInput
    lootQueue?: LootQueueUncheckedCreateNestedManyWithoutUserInput
    raidAttendance?: RaidAttendanceUncheckedCreateNestedManyWithoutUserInput
    tasks?: TasksUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TasksUserUncheckedCreateNestedManyWithoutUserInput
    inventory?: UserInventoryUncheckedCreateNestedManyWithoutUserInput
    salaryBonuses?: UserSalaryBonusUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLinkTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLinkTokensInput, UserUncheckedCreateWithoutLinkTokensInput>
  }

  export type UserUpsertWithoutLinkTokensInput = {
    update: XOR<UserUpdateWithoutLinkTokensInput, UserUncheckedUpdateWithoutLinkTokensInput>
    create: XOR<UserCreateWithoutLinkTokensInput, UserUncheckedCreateWithoutLinkTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLinkTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLinkTokensInput, UserUncheckedUpdateWithoutLinkTokensInput>
  }

  export type UserUpdateWithoutLinkTokensInput = {
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUpdateManyWithoutUserNestedInput
    soldLoot?: LootUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUpdateManyWithoutUserNestedInput
    tasks?: TasksUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUpdateManyWithoutUserNestedInput
    tags?: UserTagsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLinkTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    class?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_class?: NullableStringFieldUpdateOperationsInput | string | null
    class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    secondary_class_gear_score?: NullableIntFieldUpdateOperationsInput | number | null
    vk_name?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    is_eligible_for_salary?: BoolFieldUpdateOperationsInput | boolean
    joined_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryBonus?: NullableIntFieldUpdateOperationsInput | number | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    vkId?: NullableStringFieldUpdateOperationsInput | string | null
    salaries?: SalaryUncheckedUpdateManyWithoutUserNestedInput
    givenAwayLoot?: GivenAwayLootUncheckedUpdateManyWithoutUserNestedInput
    soldLoot?: LootUncheckedUpdateManyWithoutSoldToUserNestedInput
    lootQueue?: LootQueueUncheckedUpdateManyWithoutUserNestedInput
    raidAttendance?: RaidAttendanceUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TasksUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TasksUserUncheckedUpdateManyWithoutUserNestedInput
    inventory?: UserInventoryUncheckedUpdateManyWithoutUserNestedInput
    salaryBonuses?: UserSalaryBonusUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SalaryCreateManyUserInput = {
    id?: number
    year: number
    month: number
    amount: number
    bonus?: number | null
    total: number
  }

  export type GivenAwayLootCreateManyUserInput = {
    id?: number
    name: string
    date: Date | string
    comment?: string | null
    created_at?: Date | string | null
    status?: string | null
  }

  export type LootCreateManySoldToUserInput = {
    id?: number
    status?: string | null
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    created_at?: Date | string
    source?: string | null
    acquired_at?: Date | string | null
    itemTypeId: number
    quantity?: number
    price?: number | null
  }

  export type LootQueueCreateManyUserInput = {
    id?: number
    itemTypeId: number
    created_at?: Date | string | null
    status?: string | null
    synth_target?: string | null
    remaining?: number | null
    required?: number
    delivered?: number
  }

  export type RaidAttendanceCreateManyUserInput = {
    id?: number
    raid_id: number
    created_at: Date | string
  }

  export type TasksCreateManyUserInput = {
    id?: number
    name?: string | null
    completed_at?: Date | string | null
    created_at: Date | string
  }

  export type TasksUserCreateManyUserInput = {
    tasks_user_id: number
  }

  export type UserInventoryCreateManyUserInput = {
    id?: number
    type?: string | null
    name?: string | null
    quality?: string | null
    created_at: Date | string
    quantity?: number | null
  }

  export type UserSalaryBonusCreateManyUserInput = {
    id?: number
    amount: number
    reason: string
    created_at?: Date | string | null
  }

  export type UserTagsCreateManyUserInput = {
    id?: number
    tag: string
    created_at?: Date | string
  }

  export type LinkTokenCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    used?: boolean
  }

  export type SalaryUpdateWithoutUserInput = {
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    bonus?: NullableIntFieldUpdateOperationsInput | number | null
    total?: IntFieldUpdateOperationsInput | number
  }

  export type SalaryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    bonus?: NullableIntFieldUpdateOperationsInput | number | null
    total?: IntFieldUpdateOperationsInput | number
  }

  export type SalaryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    bonus?: NullableIntFieldUpdateOperationsInput | number | null
    total?: IntFieldUpdateOperationsInput | number
  }

  export type GivenAwayLootUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GivenAwayLootUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GivenAwayLootUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LootUpdateWithoutSoldToUserInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    acquired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableIntFieldUpdateOperationsInput | number | null
    itemType?: ItemTypeUpdateOneRequiredWithoutLootNestedInput
  }

  export type LootUncheckedUpdateWithoutSoldToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    acquired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemTypeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LootUncheckedUpdateManyWithoutSoldToUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    acquired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemTypeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LootQueueUpdateWithoutUserInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    synth_target?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    required?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    itemType?: ItemTypeUpdateOneRequiredWithoutLootQueueNestedInput
  }

  export type LootQueueUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    synth_target?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    required?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
  }

  export type LootQueueUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemTypeId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    synth_target?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    required?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
  }

  export type RaidAttendanceUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    raid?: RaidUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type RaidAttendanceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    raid_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidAttendanceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    raid_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TasksUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: TasksUserUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: TasksUserUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TasksUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TasksUserUpdateWithoutUserInput = {
    task?: TasksUpdateOneRequiredWithoutAssignedToNestedInput
  }

  export type TasksUserUncheckedUpdateWithoutUserInput = {
    tasks_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type TasksUserUncheckedUpdateManyWithoutUserInput = {
    tasks_user_id?: IntFieldUpdateOperationsInput | number
  }

  export type UserInventoryUpdateWithoutUserInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserInventoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserInventoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserSalaryBonusUpdateWithoutUserInput = {
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSalaryBonusUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSalaryBonusUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserTagsUpdateWithoutUserInput = {
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LinkTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LinkTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TasksUserCreateManyTaskInput = {
    user_id: number
  }

  export type TasksUserUpdateWithoutTaskInput = {
    user?: UserUpdateOneRequiredWithoutTasksAssignedNestedInput
  }

  export type TasksUserUncheckedUpdateWithoutTaskInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type TasksUserUncheckedUpdateManyWithoutTaskInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type RaidAttendanceCreateManyRaidInput = {
    id?: number
    user_id: number
    created_at: Date | string
  }

  export type RaidBossCreateManyRaidInput = {
    boss_id: number
  }

  export type RaidAttendanceUpdateWithoutRaidInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRaidAttendanceNestedInput
  }

  export type RaidAttendanceUncheckedUpdateWithoutRaidInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidAttendanceUncheckedUpdateManyWithoutRaidInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaidBossUpdateWithoutRaidInput = {
    boss?: BossUpdateOneRequiredWithoutRaidBossesNestedInput
  }

  export type RaidBossUncheckedUpdateWithoutRaidInput = {
    boss_id?: IntFieldUpdateOperationsInput | number
  }

  export type RaidBossUncheckedUpdateManyWithoutRaidInput = {
    boss_id?: IntFieldUpdateOperationsInput | number
  }

  export type RaidBossCreateManyBossInput = {
    raid_id: number
  }

  export type RaidBossUpdateWithoutBossInput = {
    raid?: RaidUpdateOneRequiredWithoutRaidBossesNestedInput
  }

  export type RaidBossUncheckedUpdateWithoutBossInput = {
    raid_id?: IntFieldUpdateOperationsInput | number
  }

  export type RaidBossUncheckedUpdateManyWithoutBossInput = {
    raid_id?: IntFieldUpdateOperationsInput | number
  }

  export type LootCreateManyItemTypeInput = {
    id?: number
    status?: string | null
    sold_at?: Date | string | null
    sold_to?: string | null
    comment?: string | null
    created_at?: Date | string
    source?: string | null
    acquired_at?: Date | string | null
    sold_to_user_id?: number | null
    quantity?: number
    price?: number | null
  }

  export type LootQueueCreateManyItemTypeInput = {
    id?: number
    userId: number
    created_at?: Date | string | null
    status?: string | null
    synth_target?: string | null
    remaining?: number | null
    required?: number
    delivered?: number
  }

  export type LootUpdateWithoutItemTypeInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    acquired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableIntFieldUpdateOperationsInput | number | null
    soldToUser?: UserUpdateOneWithoutSoldLootNestedInput
  }

  export type LootUncheckedUpdateWithoutItemTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    acquired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LootUncheckedUpdateManyWithoutItemTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sold_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    acquired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sold_to_user_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LootQueueUpdateWithoutItemTypeInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    synth_target?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    required?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutLootQueueNestedInput
  }

  export type LootQueueUncheckedUpdateWithoutItemTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    synth_target?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    required?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
  }

  export type LootQueueUncheckedUpdateManyWithoutItemTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    synth_target?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableIntFieldUpdateOperationsInput | number | null
    required?: IntFieldUpdateOperationsInput | number
    delivered?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}