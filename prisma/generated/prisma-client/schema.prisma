generator client {
  provider = "prisma-client-js"
  output   = "./generated/prisma-client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                         Int       @id @default(autoincrement())
  username                   String
  class                      String?
  secondary_class            String?
  class_gear_score           Int?
  secondary_class_gear_score Int?
  vk_name                    String?
  active                     Boolean
  is_eligible_for_salary     Boolean
  joined_at                  DateTime?
  created_at                 DateTime
  salaryBonus                Int?      @default(0)
  googleId                   String?   @unique @map("google_id")
  vkId                       String?   @unique @map("vk_id")

  salaries       Salary[]
  givenAwayLoot  GivenAwayLoot[]
  soldLoot       Loot[]            @relation("UserSoldLoot")
  lootQueue      LootQueue[]
  raidAttendance RaidAttendance[]
  tasks          Tasks[]
  tasksAssigned  TasksUser[]
  inventory      UserInventory[]
  salaryBonuses  UserSalaryBonus[]
  tags           UserTags[]        @relation("UserTags")
  linkTokens     LinkToken[]       @relation("UserToLinkTokens")

  @@map("user")
}

model UserTags {
  id         Int      @id @default(autoincrement())
  user_id    Int
  tag        String
  created_at DateTime @default(now())
  user       User     @relation("UserTags", fields: [user_id], references: [id])

  @@map("user_tags")
}

model UserInventory {
  id         Int      @id @default(autoincrement())
  user_id    Int
  type       String?
  name       String?
  quality    String?
  created_at DateTime
  quantity   Int?     @default(1)
  user       User     @relation(fields: [user_id], references: [id])

  @@map("user_inventory")
}

model Tasks {
  id           Int         @id @default(autoincrement())
  user_id      Int
  name         String?
  completed_at DateTime?
  created_at   DateTime
  user         User        @relation(fields: [user_id], references: [id])
  assignedTo   TasksUser[] @relation("tasks_assigned")

  @@map("tasks")
}

model Raid {
  id          Int              @id @default(autoincrement())
  type        String?
  start_date  DateTime?
  created_at  DateTime
  is_pvp      Boolean?         @default(false)
  is_pvp_long Boolean?         @default(false)
  dkp_summary Int?             @default(0)
  attendance  RaidAttendance[]
  raidBosses  RaidBoss[]

  @@map("raid")
}

model Boss {
  id         Int        @id @default(autoincrement())
  boss_name  String
  dkp_points Int
  category   String?
  raidBosses RaidBoss[]

  @@map("boss")
}

model RaidBoss {
  raid_id Int
  boss_id Int
  boss    Boss @relation(fields: [boss_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  raid    Raid @relation(fields: [raid_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([raid_id, boss_id])
  @@map("raid_boss")
}

model RaidAttendance {
  id         Int      @id @default(autoincrement())
  user_id    Int
  raid_id    Int
  created_at DateTime
  raid       Raid     @relation(fields: [raid_id], references: [id])
  user       User     @relation(fields: [user_id], references: [id])

  @@map("raid_attendance")
}

model ItemType {
  id        Int         @id @default(autoincrement())
  name      String      @unique @db.VarChar(255)
  price     Float?
  loot      Loot[]
  lootQueue LootQueue[]

  @@map("item_type")
}

model Loot {
  id              Int       @id @default(autoincrement())
  status          String?
  sold_at         DateTime?
  sold_to         String?
  comment         String?
  created_at      DateTime  @default(now())
  source          String?   @db.VarChar(255)
  acquired_at     DateTime? @db.Timestamp(6)
  itemTypeId      Int       @map("item_type_id")
  sold_to_user_id Int?
  quantity        Int       @default(1)
  price           Int?
  itemType        ItemType  @relation(fields: [itemTypeId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_item_type")
  soldToUser      User?     @relation("UserSoldLoot", fields: [sold_to_user_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "fk_sold_to_user")

  @@map("loot")
}

model TasksUser {
  tasks_user_id Int
  user_id       Int
  task          Tasks @relation("tasks_assigned", fields: [tasks_user_id], references: [id])
  user          User  @relation(fields: [user_id], references: [id])

  @@id([tasks_user_id, user_id])
  @@map("tasks_user")
}

model LootQueue {
  id           Int       @id @default(autoincrement())
  itemTypeId   Int       @map("item_type_id")
  userId       Int       @map("user_id")
  created_at   DateTime? @default(now()) @db.Timestamp(6)
  status       String?   @default("ожидание")
  synth_target String?
  remaining    Int?
  required     Int       @default(1)
  delivered    Int       @default(0)
  itemType     ItemType  @relation(fields: [itemTypeId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@map("loot_queue")
}

model GivenAwayLoot {
  id         Int       @id @default(autoincrement())
  user_id    Int
  name       String
  date       DateTime  @db.Date
  comment    String?
  created_at DateTime? @default(now()) @db.Timestamp(6)
  status     String?
  user       User      @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([user_id, name], map: "user_loot_unique")
  @@map("givenawayloot")
}

model Expense {
  id      Int      @id @default(autoincrement())
  date    DateTime @db.Timestamp(6)
  amount  Int
  target  String
  source  String
  comment String?
}

model GuildFunds {
  id            Int @id @default(autoincrement())
  year          Int
  month         Int
  totalIncome   Int
  totalExpenses Int
  profit        Int
  salaryBudget  Int
  treasuryLeft  Int
}

model Salary {
  id     Int  @id @default(autoincrement())
  year   Int
  month  Int
  userId Int
  amount Int
  bonus  Int?
  total  Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model UserSalaryBonus {
  id         Int       @id @default(autoincrement())
  user_id    Int
  amount     Int
  reason     String
  created_at DateTime? @default(now()) @db.Timestamp(6)
  user       User      @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@map("user_salary_bonus")
}

model LinkToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  user      User     @relation("UserToLinkTokens", fields: [userId], references: [id])
  userId    Int
  expiresAt DateTime
  used      Boolean  @default(false)

  @@map("link_token")
}

model News {
  id        Int      @id @default(autoincrement())
  title     String
  content   String
  date      DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
